
build/gpsdo.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
                .align  2
                .thumb_func
                .global Reset_Handler
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001c0:	b672      	cpsid	i

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001c2:	4834      	ldr	r0, [pc, #208]	; (8000294 <endfiniloop+0x4>)
                msr     PSP, r0
 80001c4:	f380 8809 	msr	PSP, r0

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
 80001c8:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
 80001cc:	f2cc 0000 	movt	r0, #49152	; 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
 80001d0:	f64e 7134 	movw	r1, #61236	; 0xef34
                movt    r1, #SCB_FPCCR >> 16
 80001d4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001d8:	6008      	str	r0, [r1, #0]
                dsb
 80001da:	f3bf 8f4f 	dsb	sy
                isb
 80001de:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
 80001e2:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
 80001e6:	f2c0 00f0 	movt	r0, #240	; 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
 80001ea:	f64e 5188 	movw	r1, #60808	; 0xed88
                movt    r1, #SCB_CPACR >> 16
 80001ee:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001f2:	6008      	str	r0, [r1, #0]
                dsb
 80001f4:	f3bf 8f4f 	dsb	sy
                isb
 80001f8:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
 80001fc:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
 8000200:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
 8000204:	f64e 713c 	movw	r1, #61244	; 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
 8000208:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800020c:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA
 800020e:	2006      	movs	r0, #6
#else
                movs    r0, #CRT0_CONTROL_INIT
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8000210:	f380 8814 	msr	CONTROL, r0
                isb
 8000214:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000218:	f000 f922 	bl	8000460 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 800021c:	f009 f808 	bl	8009230 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000220:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000224:	491c      	ldr	r1, [pc, #112]	; (8000298 <endfiniloop+0x8>)
                ldr     r2, =__main_stack_end__
 8000226:	4a1d      	ldr	r2, [pc, #116]	; (800029c <endfiniloop+0xc>)

08000228 <msloop>:
msloop:
                cmp     r1, r2
 8000228:	4291      	cmp	r1, r2
                itt     lo
 800022a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800022c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000230:	e7fa      	bcc.n	8000228 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000232:	491b      	ldr	r1, [pc, #108]	; (80002a0 <endfiniloop+0x10>)
                ldr     r2, =__process_stack_end__
 8000234:	4a17      	ldr	r2, [pc, #92]	; (8000294 <endfiniloop+0x4>)

08000236 <psloop>:
psloop:
                cmp     r1, r2
 8000236:	4291      	cmp	r1, r2
                itt     lo
 8000238:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800023a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800023e:	e7fa      	bcc.n	8000236 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8000240:	4918      	ldr	r1, [pc, #96]	; (80002a4 <endfiniloop+0x14>)
                ldr     r2, =_data_start
 8000242:	4a19      	ldr	r2, [pc, #100]	; (80002a8 <endfiniloop+0x18>)
                ldr     r3, =_data_end
 8000244:	4b19      	ldr	r3, [pc, #100]	; (80002ac <endfiniloop+0x1c>)

08000246 <dloop>:
dloop:
                cmp     r2, r3
 8000246:	429a      	cmp	r2, r3
                ittt    lo
 8000248:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800024a:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800024e:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000252:	e7f8      	bcc.n	8000246 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000254:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000256:	4916      	ldr	r1, [pc, #88]	; (80002b0 <endfiniloop+0x20>)
                ldr     r2, =_bss_end
 8000258:	4a16      	ldr	r2, [pc, #88]	; (80002b4 <endfiniloop+0x24>)

0800025a <bloop>:
bloop:
                cmp     r1, r2
 800025a:	4291      	cmp	r1, r2
                itt     lo
 800025c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800025e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000262:	e7fa      	bcc.n	800025a <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000264:	f000 f914 	bl	8000490 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000268:	f000 f902 	bl	8000470 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800026c:	4c12      	ldr	r4, [pc, #72]	; (80002b8 <endfiniloop+0x28>)
                ldr     r5, =__init_array_end
 800026e:	4d13      	ldr	r5, [pc, #76]	; (80002bc <endfiniloop+0x2c>)

08000270 <initloop>:
initloop:
                cmp     r4, r5
 8000270:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000272:	da03      	bge.n	800027c <endinitloop>
                ldr     r1, [r4], #4
 8000274:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000278:	4788      	blx	r1
                b       initloop
 800027a:	e7f9      	b.n	8000270 <initloop>

0800027c <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 800027c:	f008 fff8 	bl	8009270 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8000280:	4c0f      	ldr	r4, [pc, #60]	; (80002c0 <endfiniloop+0x30>)
                ldr     r5, =__fini_array_end
 8000282:	4d10      	ldr	r5, [pc, #64]	; (80002c4 <endfiniloop+0x34>)

08000284 <finiloop>:
finiloop:
                cmp     r4, r5
 8000284:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000286:	da03      	bge.n	8000290 <endfiniloop>
                ldr     r1, [r4], #4
 8000288:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800028c:	4788      	blx	r1
                b       finiloop
 800028e:	e7f9      	b.n	8000284 <finiloop>

08000290 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000290:	f000 b8f6 	b.w	8000480 <__default_exit>
                ldr     r0, =__process_stack_end__
 8000294:	10000800 	.word	0x10000800
                ldr     r1, =__main_stack_base__
 8000298:	10000000 	.word	0x10000000
                ldr     r2, =__main_stack_end__
 800029c:	10000400 	.word	0x10000400
                ldr     r1, =__process_stack_base__
 80002a0:	10000400 	.word	0x10000400
                ldr     r1, =_textdata_start
 80002a4:	0800af90 	.word	0x0800af90
                ldr     r2, =_data_start
 80002a8:	20000000 	.word	0x20000000
                ldr     r3, =_data_end
 80002ac:	20000024 	.word	0x20000024
                ldr     r1, =_bss_start
 80002b0:	20002128 	.word	0x20002128
                ldr     r2, =_bss_end
 80002b4:	20003e20 	.word	0x20003e20
                ldr     r4, =__init_array_start
 80002b8:	080001c0 	.word	0x080001c0
                ldr     r5, =__init_array_end
 80002bc:	080001c0 	.word	0x080001c0
                ldr     r4, =__fini_array_start
 80002c0:	080001c0 	.word	0x080001c0
                ldr     r5, =__fini_array_end
 80002c4:	080001c0 	.word	0x080001c0
	...

080002d0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
 80002d4:	ed2d 8a10 	vpush	{s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002d8:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002dc:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002de:	469d      	mov	sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
 80002e0:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002e8 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80002e8:	f000 fb32 	bl	8000950 <_dbg_check_unlock>
#endif
#if CH_DBG_STATISTICS
                bl      _stats_stop_measure_crit_thd
 80002ec:	f001 fb00 	bl	80018f0 <_stats_stop_measure_crit_thd>
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002f0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002f2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002f6:	4628      	mov	r0, r5
                blx     r4
 80002f8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002fa:	2000      	movs	r0, #0
                bl      chThdExit
 80002fc:	f001 f8d8 	bl	80014b0 <chThdExit>

08000300 <_port_switch_from_isr>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch_from_isr
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
 8000300:	f001 faee 	bl	80018e0 <_stats_start_measure_crit_thd>
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 8000304:	f000 fb0c 	bl	8000920 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 8000308:	f000 fef2 	bl	80010f0 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 800030c:	f000 fb20 	bl	8000950 <_dbg_check_unlock>
#endif
#if CH_DBG_STATISTICS
                bl      _stats_stop_measure_crit_thd
 8000310:	f001 faee 	bl	80018f0 <_stats_stop_measure_crit_thd>

08000314 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000314:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000316:	e7fe      	b.n	8000316 <_port_exit_from_isr+0x2>
	...

08000320 <memcpy>:
 8000320:	4684      	mov	ip, r0
 8000322:	ea41 0300 	orr.w	r3, r1, r0
 8000326:	f013 0303 	ands.w	r3, r3, #3
 800032a:	d16d      	bne.n	8000408 <memcpy+0xe8>
 800032c:	3a40      	subs	r2, #64	; 0x40
 800032e:	d341      	bcc.n	80003b4 <memcpy+0x94>
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	f851 3b04 	ldr.w	r3, [r1], #4
 800033c:	f840 3b04 	str.w	r3, [r0], #4
 8000340:	f851 3b04 	ldr.w	r3, [r1], #4
 8000344:	f840 3b04 	str.w	r3, [r0], #4
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	f851 3b04 	ldr.w	r3, [r1], #4
 8000354:	f840 3b04 	str.w	r3, [r0], #4
 8000358:	f851 3b04 	ldr.w	r3, [r1], #4
 800035c:	f840 3b04 	str.w	r3, [r0], #4
 8000360:	f851 3b04 	ldr.w	r3, [r1], #4
 8000364:	f840 3b04 	str.w	r3, [r0], #4
 8000368:	f851 3b04 	ldr.w	r3, [r1], #4
 800036c:	f840 3b04 	str.w	r3, [r0], #4
 8000370:	f851 3b04 	ldr.w	r3, [r1], #4
 8000374:	f840 3b04 	str.w	r3, [r0], #4
 8000378:	f851 3b04 	ldr.w	r3, [r1], #4
 800037c:	f840 3b04 	str.w	r3, [r0], #4
 8000380:	f851 3b04 	ldr.w	r3, [r1], #4
 8000384:	f840 3b04 	str.w	r3, [r0], #4
 8000388:	f851 3b04 	ldr.w	r3, [r1], #4
 800038c:	f840 3b04 	str.w	r3, [r0], #4
 8000390:	f851 3b04 	ldr.w	r3, [r1], #4
 8000394:	f840 3b04 	str.w	r3, [r0], #4
 8000398:	f851 3b04 	ldr.w	r3, [r1], #4
 800039c:	f840 3b04 	str.w	r3, [r0], #4
 80003a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a4:	f840 3b04 	str.w	r3, [r0], #4
 80003a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003ac:	f840 3b04 	str.w	r3, [r0], #4
 80003b0:	3a40      	subs	r2, #64	; 0x40
 80003b2:	d2bd      	bcs.n	8000330 <memcpy+0x10>
 80003b4:	3230      	adds	r2, #48	; 0x30
 80003b6:	d311      	bcc.n	80003dc <memcpy+0xbc>
 80003b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003bc:	f840 3b04 	str.w	r3, [r0], #4
 80003c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c4:	f840 3b04 	str.w	r3, [r0], #4
 80003c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003cc:	f840 3b04 	str.w	r3, [r0], #4
 80003d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003d4:	f840 3b04 	str.w	r3, [r0], #4
 80003d8:	3a10      	subs	r2, #16
 80003da:	d2ed      	bcs.n	80003b8 <memcpy+0x98>
 80003dc:	320c      	adds	r2, #12
 80003de:	d305      	bcc.n	80003ec <memcpy+0xcc>
 80003e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003e4:	f840 3b04 	str.w	r3, [r0], #4
 80003e8:	3a04      	subs	r2, #4
 80003ea:	d2f9      	bcs.n	80003e0 <memcpy+0xc0>
 80003ec:	3204      	adds	r2, #4
 80003ee:	d008      	beq.n	8000402 <memcpy+0xe2>
 80003f0:	07d2      	lsls	r2, r2, #31
 80003f2:	bf1c      	itt	ne
 80003f4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003f8:	f800 3b01 	strbne.w	r3, [r0], #1
 80003fc:	d301      	bcc.n	8000402 <memcpy+0xe2>
 80003fe:	880b      	ldrh	r3, [r1, #0]
 8000400:	8003      	strh	r3, [r0, #0]
 8000402:	4660      	mov	r0, ip
 8000404:	4770      	bx	lr
 8000406:	bf00      	nop
 8000408:	2a08      	cmp	r2, #8
 800040a:	d313      	bcc.n	8000434 <memcpy+0x114>
 800040c:	078b      	lsls	r3, r1, #30
 800040e:	d08d      	beq.n	800032c <memcpy+0xc>
 8000410:	f010 0303 	ands.w	r3, r0, #3
 8000414:	d08a      	beq.n	800032c <memcpy+0xc>
 8000416:	f1c3 0304 	rsb	r3, r3, #4
 800041a:	1ad2      	subs	r2, r2, r3
 800041c:	07db      	lsls	r3, r3, #31
 800041e:	bf1c      	itt	ne
 8000420:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000424:	f800 3b01 	strbne.w	r3, [r0], #1
 8000428:	d380      	bcc.n	800032c <memcpy+0xc>
 800042a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800042e:	f820 3b02 	strh.w	r3, [r0], #2
 8000432:	e77b      	b.n	800032c <memcpy+0xc>
 8000434:	3a04      	subs	r2, #4
 8000436:	d3d9      	bcc.n	80003ec <memcpy+0xcc>
 8000438:	3a01      	subs	r2, #1
 800043a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800043e:	f800 3b01 	strb.w	r3, [r0], #1
 8000442:	d2f9      	bcs.n	8000438 <memcpy+0x118>
 8000444:	780b      	ldrb	r3, [r1, #0]
 8000446:	7003      	strb	r3, [r0, #0]
 8000448:	784b      	ldrb	r3, [r1, #1]
 800044a:	7043      	strb	r3, [r0, #1]
 800044c:	788b      	ldrb	r3, [r1, #2]
 800044e:	7083      	strb	r3, [r0, #2]
 8000450:	4660      	mov	r0, ip
 8000452:	4770      	bx	lr
	...

08000460 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000460:	4770      	bx	lr
 8000462:	bf00      	nop
	...

08000470 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000470:	4770      	bx	lr
 8000472:	bf00      	nop
	...

08000480 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8000480:	e7fe      	b.n	8000480 <__default_exit>
 8000482:	bf00      	nop
	...

08000490 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000490:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000492:	4b16      	ldr	r3, [pc, #88]	; (80004ec <__init_ram_areas+0x5c>)
 8000494:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8000496:	9b03      	ldr	r3, [sp, #12]
 8000498:	681b      	ldr	r3, [r3, #0]
 800049a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800049c:	9b03      	ldr	r3, [sp, #12]
 800049e:	685b      	ldr	r3, [r3, #4]
 80004a0:	9301      	str	r3, [sp, #4]
 80004a2:	e009      	b.n	80004b8 <__init_ram_areas+0x28>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 80004a4:	9b02      	ldr	r3, [sp, #8]
 80004a6:	681a      	ldr	r2, [r3, #0]
 80004a8:	9b01      	ldr	r3, [sp, #4]
 80004aa:	601a      	str	r2, [r3, #0]
      p++;
 80004ac:	9b01      	ldr	r3, [sp, #4]
 80004ae:	3304      	adds	r3, #4
 80004b0:	9301      	str	r3, [sp, #4]
      tp++;
 80004b2:	9b02      	ldr	r3, [sp, #8]
 80004b4:	3304      	adds	r3, #4
 80004b6:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 80004b8:	9b03      	ldr	r3, [sp, #12]
 80004ba:	689b      	ldr	r3, [r3, #8]
 80004bc:	9a01      	ldr	r2, [sp, #4]
 80004be:	429a      	cmp	r2, r3
 80004c0:	d3f0      	bcc.n	80004a4 <__init_ram_areas+0x14>
 80004c2:	e005      	b.n	80004d0 <__init_ram_areas+0x40>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 80004c4:	9b01      	ldr	r3, [sp, #4]
 80004c6:	2200      	movs	r2, #0
 80004c8:	601a      	str	r2, [r3, #0]
      p++;
 80004ca:	9b01      	ldr	r3, [sp, #4]
 80004cc:	3304      	adds	r3, #4
 80004ce:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 80004d0:	9b03      	ldr	r3, [sp, #12]
 80004d2:	68db      	ldr	r3, [r3, #12]
 80004d4:	9a01      	ldr	r2, [sp, #4]
 80004d6:	429a      	cmp	r2, r3
 80004d8:	d3f4      	bcc.n	80004c4 <__init_ram_areas+0x34>
    }
    rap++;
 80004da:	9b03      	ldr	r3, [sp, #12]
 80004dc:	3310      	adds	r3, #16
 80004de:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80004e0:	9b03      	ldr	r3, [sp, #12]
 80004e2:	4a03      	ldr	r2, [pc, #12]	; (80004f0 <__init_ram_areas+0x60>)
 80004e4:	4293      	cmp	r3, r2
 80004e6:	d3d6      	bcc.n	8000496 <__init_ram_areas+0x6>
#endif
}
 80004e8:	b004      	add	sp, #16
 80004ea:	4770      	bx	lr
 80004ec:	0800a370 	.word	0x0800a370
 80004f0:	0800a3f0 	.word	0x0800a3f0
	...

08000500 <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
 8000500:	e7fe      	b.n	8000500 <BusFault_Handler>
 8000502:	bf00      	nop
	...

08000510 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000510:	b084      	sub	sp, #16
 8000512:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8000514:	9b01      	ldr	r3, [sp, #4]
 8000516:	f003 0307 	and.w	r3, r3, #7
 800051a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800051c:	4b0a      	ldr	r3, [pc, #40]	; (8000548 <NVIC_SetPriorityGrouping+0x38>)
 800051e:	68db      	ldr	r3, [r3, #12]
 8000520:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8000522:	9a02      	ldr	r2, [sp, #8]
 8000524:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8000528:	4013      	ands	r3, r2
 800052a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 800052c:	9b03      	ldr	r3, [sp, #12]
 800052e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000530:	9b02      	ldr	r3, [sp, #8]
 8000532:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8000534:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000538:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800053c:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
 800053e:	4a02      	ldr	r2, [pc, #8]	; (8000548 <NVIC_SetPriorityGrouping+0x38>)
 8000540:	9b02      	ldr	r3, [sp, #8]
 8000542:	60d3      	str	r3, [r2, #12]
}
 8000544:	b004      	add	sp, #16
 8000546:	4770      	bx	lr
 8000548:	e000ed00 	.word	0xe000ed00
 800054c:	00000000 	.word	0x00000000

08000550 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8000550:	b082      	sub	sp, #8
 8000552:	4603      	mov	r3, r0
 8000554:	9100      	str	r1, [sp, #0]
 8000556:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
 800055a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800055e:	2b00      	cmp	r3, #0
 8000560:	da0c      	bge.n	800057c <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000562:	9b00      	ldr	r3, [sp, #0]
 8000564:	b2da      	uxtb	r2, r3
 8000566:	490b      	ldr	r1, [pc, #44]	; (8000594 <NVIC_SetPriority+0x44>)
 8000568:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800056c:	f003 030f 	and.w	r3, r3, #15
 8000570:	3b04      	subs	r3, #4
 8000572:	0112      	lsls	r2, r2, #4
 8000574:	b2d2      	uxtb	r2, r2
 8000576:	440b      	add	r3, r1
 8000578:	761a      	strb	r2, [r3, #24]
 800057a:	e009      	b.n	8000590 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800057c:	9b00      	ldr	r3, [sp, #0]
 800057e:	b2da      	uxtb	r2, r3
 8000580:	4905      	ldr	r1, [pc, #20]	; (8000598 <NVIC_SetPriority+0x48>)
 8000582:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8000586:	0112      	lsls	r2, r2, #4
 8000588:	b2d2      	uxtb	r2, r2
 800058a:	440b      	add	r3, r1
 800058c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 8000590:	b002      	add	sp, #8
 8000592:	4770      	bx	lr
 8000594:	e000ed00 	.word	0xe000ed00
 8000598:	e000e100 	.word	0xe000e100
 800059c:	00000000 	.word	0x00000000

080005a0 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 80005a0:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80005a2:	4b0e      	ldr	r3, [pc, #56]	; (80005dc <port_init+0x3c>)
 80005a4:	2200      	movs	r2, #0
 80005a6:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 80005a8:	2003      	movs	r0, #3
 80005aa:	f7ff ffb1 	bl	8000510 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80005ae:	4b0c      	ldr	r3, [pc, #48]	; (80005e0 <port_init+0x40>)
 80005b0:	68db      	ldr	r3, [r3, #12]
 80005b2:	4a0b      	ldr	r2, [pc, #44]	; (80005e0 <port_init+0x40>)
 80005b4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80005b8:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80005ba:	4b0a      	ldr	r3, [pc, #40]	; (80005e4 <port_init+0x44>)
 80005bc:	681b      	ldr	r3, [r3, #0]
 80005be:	4a09      	ldr	r2, [pc, #36]	; (80005e4 <port_init+0x44>)
 80005c0:	f043 0301 	orr.w	r3, r3, #1
 80005c4:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 80005c6:	2101      	movs	r1, #1
 80005c8:	f06f 0004 	mvn.w	r0, #4
 80005cc:	f7ff ffc0 	bl	8000550 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 80005d0:	2102      	movs	r1, #2
 80005d2:	f06f 0001 	mvn.w	r0, #1
 80005d6:	f7ff ffbb 	bl	8000550 <NVIC_SetPriority>
}
 80005da:	bd08      	pop	{r3, pc}
 80005dc:	e000ed00 	.word	0xe000ed00
 80005e0:	e000edf0 	.word	0xe000edf0
 80005e4:	e0001000 	.word	0xe0001000
	...

080005f0 <port_lock.lto_priv.102>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80005f0:	b082      	sub	sp, #8
 80005f2:	2320      	movs	r3, #32
 80005f4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80005f6:	9b01      	ldr	r3, [sp, #4]
 80005f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80005fc:	b002      	add	sp, #8
 80005fe:	4770      	bx	lr

08000600 <port_unlock.lto_priv.72>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000600:	b082      	sub	sp, #8
 8000602:	2300      	movs	r3, #0
 8000604:	9301      	str	r3, [sp, #4]
 8000606:	9b01      	ldr	r3, [sp, #4]
 8000608:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800060c:	b002      	add	sp, #8
 800060e:	4770      	bx	lr

08000610 <port_lock_from_isr.lto_priv.181>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000610:	b508      	push	{r3, lr}

  port_lock();
 8000612:	f7ff ffed 	bl	80005f0 <port_lock.lto_priv.102>
}
 8000616:	bd08      	pop	{r3, pc}
	...

08000620 <port_unlock_from_isr.lto_priv.168>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000620:	b508      	push	{r3, lr}

  port_unlock();
 8000622:	f7ff ffed 	bl	8000600 <port_unlock.lto_priv.72>
}
 8000626:	bd08      	pop	{r3, pc}
	...

08000630 <port_disable>:
  __ASM volatile ("cpsid i" : : : "memory");
 8000630:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8000632:	4770      	bx	lr
	...

08000640 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8000640:	b082      	sub	sp, #8
 8000642:	2300      	movs	r3, #0
 8000644:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000646:	9b01      	ldr	r3, [sp, #4]
 8000648:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 800064c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800064e:	b002      	add	sp, #8
 8000650:	4770      	bx	lr
 8000652:	bf00      	nop
	...

08000660 <port_wait_for_interrupt>:
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8000660:	bf30      	wfi
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8000662:	4770      	bx	lr
	...

08000670 <port_rt_get_counter_value.lto_priv.335>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000670:	4b01      	ldr	r3, [pc, #4]	; (8000678 <port_rt_get_counter_value.lto_priv.335+0x8>)
 8000672:	685b      	ldr	r3, [r3, #4]
}
 8000674:	4618      	mov	r0, r3
 8000676:	4770      	bx	lr
 8000678:	e0001000 	.word	0xe0001000
 800067c:	00000000 	.word	0x00000000

08000680 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 8000680:	b508      	push	{r3, lr}

  _dbg_check_enable();
 8000682:	f000 f935 	bl	80008f0 <_dbg_check_enable>
  port_enable();
 8000686:	f7ff ffdb 	bl	8000640 <port_enable>
}
 800068a:	bd08      	pop	{r3, pc}
 800068c:	0000      	movs	r0, r0
	...

08000690 <chSysLockFromISR.lto_priv.158>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000690:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000692:	f7ff ffbd 	bl	8000610 <port_lock_from_isr.lto_priv.181>
  _stats_start_measure_crit_isr();
 8000696:	f001 f933 	bl	8001900 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800069a:	f000 f971 	bl	8000980 <_dbg_check_lock_from_isr>
}
 800069e:	bd08      	pop	{r3, pc}

080006a0 <chSysUnlockFromISR.lto_priv.148>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80006a0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 80006a2:	f000 f985 	bl	80009b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80006a6:	f001 f933 	bl	8001910 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 80006aa:	f7ff ffb9 	bl	8000620 <port_unlock_from_isr.lto_priv.168>
}
 80006ae:	bd08      	pop	{r3, pc}

080006b0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 80006b0:	b500      	push	{lr}
 80006b2:	b083      	sub	sp, #12

  chDbgCheckClassI();
 80006b4:	f000 f9d4 	bl	8000a60 <chDbgCheckClassI>

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 80006b8:	4b18      	ldr	r3, [pc, #96]	; (800071c <chVTDoTickI+0x6c>)
 80006ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80006bc:	3301      	adds	r3, #1
 80006be:	4a17      	ldr	r2, [pc, #92]	; (800071c <chVTDoTickI+0x6c>)
 80006c0:	6293      	str	r3, [r2, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80006c2:	4b16      	ldr	r3, [pc, #88]	; (800071c <chVTDoTickI+0x6c>)
 80006c4:	69db      	ldr	r3, [r3, #28]
 80006c6:	4a16      	ldr	r2, [pc, #88]	; (8000720 <chVTDoTickI+0x70>)
 80006c8:	4293      	cmp	r3, r2
 80006ca:	d024      	beq.n	8000716 <chVTDoTickI+0x66>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 80006cc:	4b13      	ldr	r3, [pc, #76]	; (800071c <chVTDoTickI+0x6c>)
 80006ce:	69db      	ldr	r3, [r3, #28]
 80006d0:	689a      	ldr	r2, [r3, #8]
 80006d2:	3a01      	subs	r2, #1
 80006d4:	609a      	str	r2, [r3, #8]
 80006d6:	e019      	b.n	800070c <chVTDoTickI+0x5c>
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
 80006d8:	4b10      	ldr	r3, [pc, #64]	; (800071c <chVTDoTickI+0x6c>)
 80006da:	69db      	ldr	r3, [r3, #28]
 80006dc:	9301      	str	r3, [sp, #4]
      fn = vtp->vt_func;
 80006de:	9b01      	ldr	r3, [sp, #4]
 80006e0:	68db      	ldr	r3, [r3, #12]
 80006e2:	9300      	str	r3, [sp, #0]
      vtp->vt_func = NULL;
 80006e4:	9b01      	ldr	r3, [sp, #4]
 80006e6:	2200      	movs	r2, #0
 80006e8:	60da      	str	r2, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80006ea:	9b01      	ldr	r3, [sp, #4]
 80006ec:	681b      	ldr	r3, [r3, #0]
 80006ee:	4a0c      	ldr	r2, [pc, #48]	; (8000720 <chVTDoTickI+0x70>)
 80006f0:	605a      	str	r2, [r3, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 80006f2:	9b01      	ldr	r3, [sp, #4]
 80006f4:	681b      	ldr	r3, [r3, #0]
 80006f6:	4a09      	ldr	r2, [pc, #36]	; (800071c <chVTDoTickI+0x6c>)
 80006f8:	61d3      	str	r3, [r2, #28]
      chSysUnlockFromISR();
 80006fa:	f7ff ffd1 	bl	80006a0 <chSysUnlockFromISR.lto_priv.148>
      fn(vtp->vt_par);
 80006fe:	9b01      	ldr	r3, [sp, #4]
 8000700:	691a      	ldr	r2, [r3, #16]
 8000702:	9b00      	ldr	r3, [sp, #0]
 8000704:	4610      	mov	r0, r2
 8000706:	4798      	blx	r3
      chSysLockFromISR();
 8000708:	f7ff ffc2 	bl	8000690 <chSysLockFromISR.lto_priv.158>
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 800070c:	4b03      	ldr	r3, [pc, #12]	; (800071c <chVTDoTickI+0x6c>)
 800070e:	69db      	ldr	r3, [r3, #28]
 8000710:	689b      	ldr	r3, [r3, #8]
 8000712:	2b00      	cmp	r3, #0
 8000714:	d0e0      	beq.n	80006d8 <chVTDoTickI+0x28>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000716:	b003      	add	sp, #12
 8000718:	f85d fb04 	ldr.w	pc, [sp], #4
 800071c:	20002128 	.word	0x20002128
 8000720:	20002144 	.word	0x20002144
	...

08000730 <chRegSetThreadName.lto_priv.0>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8000730:	b082      	sub	sp, #8
 8000732:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8000734:	4b02      	ldr	r3, [pc, #8]	; (8000740 <chRegSetThreadName.lto_priv.0+0x10>)
 8000736:	699b      	ldr	r3, [r3, #24]
 8000738:	9a01      	ldr	r2, [sp, #4]
 800073a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800073c:	b002      	add	sp, #8
 800073e:	4770      	bx	lr
 8000740:	20002128 	.word	0x20002128
	...

08000750 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8000750:	b082      	sub	sp, #8
 8000752:	9001      	str	r0, [sp, #4]
 8000754:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8000756:	9b01      	ldr	r3, [sp, #4]
 8000758:	9a00      	ldr	r2, [sp, #0]
 800075a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800075c:	b002      	add	sp, #8
 800075e:	4770      	bx	lr

08000760 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000760:	b500      	push	{lr}
 8000762:	b083      	sub	sp, #12
 8000764:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8000766:	f7ff ff7b 	bl	8000660 <port_wait_for_interrupt>
 800076a:	e7fc      	b.n	8000766 <_idle_thread+0x6>
 800076c:	0000      	movs	r0, r0
	...

08000770 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8000770:	b500      	push	{lr}
 8000772:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8000774:	f7ff ff14 	bl	80005a0 <port_init>
  _scheduler_init();
 8000778:	f000 faea 	bl	8000d50 <_scheduler_init>
  _vt_init();
 800077c:	f000 f9a0 	bl	8000ac0 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 8000780:	f000 ffc6 	bl	8001710 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8000784:	f001 ffa4 	bl	80026d0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8000788:	f001 fff2 	bl	8002770 <_heap_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  _stats_init();
 800078c:	f001 f860 	bl	8001850 <_stats_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8000790:	2140      	movs	r1, #64	; 0x40
 8000792:	4815      	ldr	r0, [pc, #84]	; (80007e8 <chSysInit+0x78>)
 8000794:	f000 fdac 	bl	80012f0 <_thread_init>
 8000798:	4602      	mov	r2, r0
 800079a:	4b14      	ldr	r3, [pc, #80]	; (80007ec <chSysInit+0x7c>)
 800079c:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800079e:	4b13      	ldr	r3, [pc, #76]	; (80007ec <chSysInit+0x7c>)
 80007a0:	699b      	ldr	r3, [r3, #24]
 80007a2:	2201      	movs	r2, #1
 80007a4:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 80007a8:	4b10      	ldr	r3, [pc, #64]	; (80007ec <chSysInit+0x7c>)
 80007aa:	699b      	ldr	r3, [r3, #24]
 80007ac:	4a10      	ldr	r2, [pc, #64]	; (80007f0 <chSysInit+0x80>)
 80007ae:	61da      	str	r2, [r3, #28]
#endif

#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->p_stats);
 80007b0:	4b0e      	ldr	r3, [pc, #56]	; (80007ec <chSysInit+0x7c>)
 80007b2:	699b      	ldr	r3, [r3, #24]
 80007b4:	3348      	adds	r3, #72	; 0x48
 80007b6:	4618      	mov	r0, r3
 80007b8:	f000 ffea 	bl	8001790 <chTMStartMeasurementX>
#endif

  chSysEnable();
 80007bc:	f7ff ff60 	bl	8000680 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 80007c0:	480c      	ldr	r0, [pc, #48]	; (80007f4 <chSysInit+0x84>)
 80007c2:	f7ff ffb5 	bl	8000730 <chRegSetThreadName.lto_priv.0>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 80007c6:	2300      	movs	r3, #0
 80007c8:	9300      	str	r3, [sp, #0]
 80007ca:	4b0b      	ldr	r3, [pc, #44]	; (80007f8 <chSysInit+0x88>)
 80007cc:	2201      	movs	r2, #1
 80007ce:	f44f 71c0 	mov.w	r1, #384	; 0x180
 80007d2:	480a      	ldr	r0, [pc, #40]	; (80007fc <chSysInit+0x8c>)
 80007d4:	f000 fe2c 	bl	8001430 <chThdCreateStatic>
 80007d8:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 80007da:	4909      	ldr	r1, [pc, #36]	; (8000800 <chSysInit+0x90>)
 80007dc:	9803      	ldr	r0, [sp, #12]
 80007de:	f7ff ffb7 	bl	8000750 <chRegSetThreadNameX>
  }
#endif
}
 80007e2:	b005      	add	sp, #20
 80007e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80007e8:	20002160 	.word	0x20002160
 80007ec:	20002128 	.word	0x20002128
 80007f0:	10000400 	.word	0x10000400
 80007f4:	0800a560 	.word	0x0800a560
 80007f8:	08000761 	.word	0x08000761
 80007fc:	20002200 	.word	0x20002200
 8000800:	0800a3f0 	.word	0x0800a3f0
	...

08000810 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8000810:	b500      	push	{lr}
 8000812:	b083      	sub	sp, #12
 8000814:	9001      	str	r0, [sp, #4]

  port_disable();
 8000816:	f7ff ff0b 	bl	8000630 <port_disable>

#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
 800081a:	4b05      	ldr	r3, [pc, #20]	; (8000830 <chSysHalt+0x20>)
 800081c:	695b      	ldr	r3, [r3, #20]
 800081e:	4a04      	ldr	r2, [pc, #16]	; (8000830 <chSysHalt+0x20>)
 8000820:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000824:	6153      	str	r3, [r2, #20]
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000826:	4a03      	ldr	r2, [pc, #12]	; (8000834 <chSysHalt+0x24>)
 8000828:	9b01      	ldr	r3, [sp, #4]
 800082a:	62d3      	str	r3, [r2, #44]	; 0x2c
 800082c:	e7fe      	b.n	800082c <chSysHalt+0x1c>
 800082e:	bf00      	nop
 8000830:	40020800 	.word	0x40020800
 8000834:	20002128 	.word	0x20002128
	...

08000840 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000840:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 8000842:	f000 f90d 	bl	8000a60 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 8000846:	f7ff ff33 	bl	80006b0 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 800084a:	bd08      	pop	{r3, pc}
 800084c:	0000      	movs	r0, r0
	...

08000850 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 8000850:	b084      	sub	sp, #16
 8000852:	9003      	str	r0, [sp, #12]
 8000854:	9102      	str	r1, [sp, #8]
 8000856:	9201      	str	r2, [sp, #4]

  return (bool)((cnt - start) < (end - start));
 8000858:	9a03      	ldr	r2, [sp, #12]
 800085a:	9b02      	ldr	r3, [sp, #8]
 800085c:	1ad2      	subs	r2, r2, r3
 800085e:	9901      	ldr	r1, [sp, #4]
 8000860:	9b02      	ldr	r3, [sp, #8]
 8000862:	1acb      	subs	r3, r1, r3
 8000864:	429a      	cmp	r2, r3
 8000866:	bf34      	ite	cc
 8000868:	2301      	movcc	r3, #1
 800086a:	2300      	movcs	r3, #0
 800086c:	b2db      	uxtb	r3, r3
}
 800086e:	4618      	mov	r0, r3
 8000870:	b004      	add	sp, #16
 8000872:	4770      	bx	lr
	...

08000880 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 8000880:	b500      	push	{lr}
 8000882:	b085      	sub	sp, #20
 8000884:	9001      	str	r0, [sp, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 8000886:	f7ff fef3 	bl	8000670 <port_rt_get_counter_value.lto_priv.335>
 800088a:	9003      	str	r0, [sp, #12]
  rtcnt_t end  = start + cycles;
 800088c:	9a03      	ldr	r2, [sp, #12]
 800088e:	9b01      	ldr	r3, [sp, #4]
 8000890:	4413      	add	r3, r2
 8000892:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8000894:	f7ff feec 	bl	8000670 <port_rt_get_counter_value.lto_priv.335>
 8000898:	4603      	mov	r3, r0
 800089a:	9a02      	ldr	r2, [sp, #8]
 800089c:	9903      	ldr	r1, [sp, #12]
 800089e:	4618      	mov	r0, r3
 80008a0:	f7ff ffd6 	bl	8000850 <chSysIsCounterWithinX>
 80008a4:	4603      	mov	r3, r0
 80008a6:	2b00      	cmp	r3, #0
 80008a8:	d1f4      	bne.n	8000894 <chSysPolledDelayX+0x14>
  }
}
 80008aa:	b005      	add	sp, #20
 80008ac:	f85d fb04 	ldr.w	pc, [sp], #4

080008b0 <port_lock.lto_priv.103>:
static inline void port_lock(void) {
 80008b0:	b082      	sub	sp, #8
 80008b2:	2320      	movs	r3, #32
 80008b4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80008b6:	9b01      	ldr	r3, [sp, #4]
 80008b8:	f383 8811 	msr	BASEPRI, r3
}
 80008bc:	b002      	add	sp, #8
 80008be:	4770      	bx	lr

080008c0 <port_unlock.lto_priv.73>:
static inline void port_unlock(void) {
 80008c0:	b082      	sub	sp, #8
 80008c2:	2300      	movs	r3, #0
 80008c4:	9301      	str	r3, [sp, #4]
 80008c6:	9b01      	ldr	r3, [sp, #4]
 80008c8:	f383 8811 	msr	BASEPRI, r3
}
 80008cc:	b002      	add	sp, #8
 80008ce:	4770      	bx	lr

080008d0 <port_lock_from_isr.lto_priv.182>:
static inline void port_lock_from_isr(void) {
 80008d0:	b508      	push	{r3, lr}
  port_lock();
 80008d2:	f7ff ffed 	bl	80008b0 <port_lock.lto_priv.103>
}
 80008d6:	bd08      	pop	{r3, pc}
	...

080008e0 <port_unlock_from_isr.lto_priv.169>:
static inline void port_unlock_from_isr(void) {
 80008e0:	b508      	push	{r3, lr}
  port_unlock();
 80008e2:	f7ff ffed 	bl	80008c0 <port_unlock.lto_priv.73>
}
 80008e6:	bd08      	pop	{r3, pc}
	...

080008f0 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
 80008f0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80008f2:	4b06      	ldr	r3, [pc, #24]	; (800090c <_dbg_check_enable+0x1c>)
 80008f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80008f6:	2b00      	cmp	r3, #0
 80008f8:	d103      	bne.n	8000902 <_dbg_check_enable+0x12>
 80008fa:	4b04      	ldr	r3, [pc, #16]	; (800090c <_dbg_check_enable+0x1c>)
 80008fc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80008fe:	2b00      	cmp	r3, #0
 8000900:	d002      	beq.n	8000908 <_dbg_check_enable+0x18>
    chSysHalt("SV#3");
 8000902:	4803      	ldr	r0, [pc, #12]	; (8000910 <_dbg_check_enable+0x20>)
 8000904:	f7ff ff84 	bl	8000810 <chSysHalt>
  }
}
 8000908:	bd08      	pop	{r3, pc}
 800090a:	bf00      	nop
 800090c:	20002128 	.word	0x20002128
 8000910:	0800a400 	.word	0x0800a400
	...

08000920 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 8000920:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000922:	4b07      	ldr	r3, [pc, #28]	; (8000940 <_dbg_check_lock+0x20>)
 8000924:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000926:	2b00      	cmp	r3, #0
 8000928:	d103      	bne.n	8000932 <_dbg_check_lock+0x12>
 800092a:	4b05      	ldr	r3, [pc, #20]	; (8000940 <_dbg_check_lock+0x20>)
 800092c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800092e:	2b00      	cmp	r3, #0
 8000930:	d002      	beq.n	8000938 <_dbg_check_lock+0x18>
    chSysHalt("SV#4");
 8000932:	4804      	ldr	r0, [pc, #16]	; (8000944 <_dbg_check_lock+0x24>)
 8000934:	f7ff ff6c 	bl	8000810 <chSysHalt>
  }
  _dbg_enter_lock();
 8000938:	4b01      	ldr	r3, [pc, #4]	; (8000940 <_dbg_check_lock+0x20>)
 800093a:	2201      	movs	r2, #1
 800093c:	635a      	str	r2, [r3, #52]	; 0x34
}
 800093e:	bd08      	pop	{r3, pc}
 8000940:	20002128 	.word	0x20002128
 8000944:	0800a410 	.word	0x0800a410
	...

08000950 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 8000950:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000952:	4b07      	ldr	r3, [pc, #28]	; (8000970 <_dbg_check_unlock+0x20>)
 8000954:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000956:	2b00      	cmp	r3, #0
 8000958:	d103      	bne.n	8000962 <_dbg_check_unlock+0x12>
 800095a:	4b05      	ldr	r3, [pc, #20]	; (8000970 <_dbg_check_unlock+0x20>)
 800095c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800095e:	2b00      	cmp	r3, #0
 8000960:	dc02      	bgt.n	8000968 <_dbg_check_unlock+0x18>
    chSysHalt("SV#5");
 8000962:	4804      	ldr	r0, [pc, #16]	; (8000974 <_dbg_check_unlock+0x24>)
 8000964:	f7ff ff54 	bl	8000810 <chSysHalt>
  }
  _dbg_leave_lock();
 8000968:	4b01      	ldr	r3, [pc, #4]	; (8000970 <_dbg_check_unlock+0x20>)
 800096a:	2200      	movs	r2, #0
 800096c:	635a      	str	r2, [r3, #52]	; 0x34
}
 800096e:	bd08      	pop	{r3, pc}
 8000970:	20002128 	.word	0x20002128
 8000974:	0800a420 	.word	0x0800a420
	...

08000980 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 8000980:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000982:	4b07      	ldr	r3, [pc, #28]	; (80009a0 <_dbg_check_lock_from_isr+0x20>)
 8000984:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000986:	2b00      	cmp	r3, #0
 8000988:	dd03      	ble.n	8000992 <_dbg_check_lock_from_isr+0x12>
 800098a:	4b05      	ldr	r3, [pc, #20]	; (80009a0 <_dbg_check_lock_from_isr+0x20>)
 800098c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800098e:	2b00      	cmp	r3, #0
 8000990:	d002      	beq.n	8000998 <_dbg_check_lock_from_isr+0x18>
    chSysHalt("SV#6");
 8000992:	4804      	ldr	r0, [pc, #16]	; (80009a4 <_dbg_check_lock_from_isr+0x24>)
 8000994:	f7ff ff3c 	bl	8000810 <chSysHalt>
  }
  _dbg_enter_lock();
 8000998:	4b01      	ldr	r3, [pc, #4]	; (80009a0 <_dbg_check_lock_from_isr+0x20>)
 800099a:	2201      	movs	r2, #1
 800099c:	635a      	str	r2, [r3, #52]	; 0x34
}
 800099e:	bd08      	pop	{r3, pc}
 80009a0:	20002128 	.word	0x20002128
 80009a4:	0800a430 	.word	0x0800a430
	...

080009b0 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 80009b0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80009b2:	4b07      	ldr	r3, [pc, #28]	; (80009d0 <_dbg_check_unlock_from_isr+0x20>)
 80009b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80009b6:	2b00      	cmp	r3, #0
 80009b8:	dd03      	ble.n	80009c2 <_dbg_check_unlock_from_isr+0x12>
 80009ba:	4b05      	ldr	r3, [pc, #20]	; (80009d0 <_dbg_check_unlock_from_isr+0x20>)
 80009bc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80009be:	2b00      	cmp	r3, #0
 80009c0:	dc02      	bgt.n	80009c8 <_dbg_check_unlock_from_isr+0x18>
    chSysHalt("SV#7");
 80009c2:	4804      	ldr	r0, [pc, #16]	; (80009d4 <_dbg_check_unlock_from_isr+0x24>)
 80009c4:	f7ff ff24 	bl	8000810 <chSysHalt>
  }
  _dbg_leave_lock();
 80009c8:	4b01      	ldr	r3, [pc, #4]	; (80009d0 <_dbg_check_unlock_from_isr+0x20>)
 80009ca:	2200      	movs	r2, #0
 80009cc:	635a      	str	r2, [r3, #52]	; 0x34
}
 80009ce:	bd08      	pop	{r3, pc}
 80009d0:	20002128 	.word	0x20002128
 80009d4:	0800a440 	.word	0x0800a440
	...

080009e0 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 80009e0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80009e2:	f7ff ff75 	bl	80008d0 <port_lock_from_isr.lto_priv.182>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80009e6:	4b09      	ldr	r3, [pc, #36]	; (8000a0c <_dbg_check_enter_isr+0x2c>)
 80009e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80009ea:	2b00      	cmp	r3, #0
 80009ec:	db03      	blt.n	80009f6 <_dbg_check_enter_isr+0x16>
 80009ee:	4b07      	ldr	r3, [pc, #28]	; (8000a0c <_dbg_check_enter_isr+0x2c>)
 80009f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80009f2:	2b00      	cmp	r3, #0
 80009f4:	d002      	beq.n	80009fc <_dbg_check_enter_isr+0x1c>
    chSysHalt("SV#8");
 80009f6:	4806      	ldr	r0, [pc, #24]	; (8000a10 <_dbg_check_enter_isr+0x30>)
 80009f8:	f7ff ff0a 	bl	8000810 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 80009fc:	4b03      	ldr	r3, [pc, #12]	; (8000a0c <_dbg_check_enter_isr+0x2c>)
 80009fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000a00:	3301      	adds	r3, #1
 8000a02:	4a02      	ldr	r2, [pc, #8]	; (8000a0c <_dbg_check_enter_isr+0x2c>)
 8000a04:	6313      	str	r3, [r2, #48]	; 0x30
  port_unlock_from_isr();
 8000a06:	f7ff ff6b 	bl	80008e0 <port_unlock_from_isr.lto_priv.169>
}
 8000a0a:	bd08      	pop	{r3, pc}
 8000a0c:	20002128 	.word	0x20002128
 8000a10:	0800a450 	.word	0x0800a450
	...

08000a20 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 8000a20:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000a22:	f7ff ff55 	bl	80008d0 <port_lock_from_isr.lto_priv.182>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000a26:	4b09      	ldr	r3, [pc, #36]	; (8000a4c <_dbg_check_leave_isr+0x2c>)
 8000a28:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000a2a:	2b00      	cmp	r3, #0
 8000a2c:	dd03      	ble.n	8000a36 <_dbg_check_leave_isr+0x16>
 8000a2e:	4b07      	ldr	r3, [pc, #28]	; (8000a4c <_dbg_check_leave_isr+0x2c>)
 8000a30:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000a32:	2b00      	cmp	r3, #0
 8000a34:	d002      	beq.n	8000a3c <_dbg_check_leave_isr+0x1c>
    chSysHalt("SV#9");
 8000a36:	4806      	ldr	r0, [pc, #24]	; (8000a50 <_dbg_check_leave_isr+0x30>)
 8000a38:	f7ff feea 	bl	8000810 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 8000a3c:	4b03      	ldr	r3, [pc, #12]	; (8000a4c <_dbg_check_leave_isr+0x2c>)
 8000a3e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000a40:	3b01      	subs	r3, #1
 8000a42:	4a02      	ldr	r2, [pc, #8]	; (8000a4c <_dbg_check_leave_isr+0x2c>)
 8000a44:	6313      	str	r3, [r2, #48]	; 0x30
  port_unlock_from_isr();
 8000a46:	f7ff ff4b 	bl	80008e0 <port_unlock_from_isr.lto_priv.169>
}
 8000a4a:	bd08      	pop	{r3, pc}
 8000a4c:	20002128 	.word	0x20002128
 8000a50:	0800a460 	.word	0x0800a460
	...

08000a60 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8000a60:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000a62:	4b06      	ldr	r3, [pc, #24]	; (8000a7c <chDbgCheckClassI+0x1c>)
 8000a64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000a66:	2b00      	cmp	r3, #0
 8000a68:	db03      	blt.n	8000a72 <chDbgCheckClassI+0x12>
 8000a6a:	4b04      	ldr	r3, [pc, #16]	; (8000a7c <chDbgCheckClassI+0x1c>)
 8000a6c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000a6e:	2b00      	cmp	r3, #0
 8000a70:	dc02      	bgt.n	8000a78 <chDbgCheckClassI+0x18>
    chSysHalt("SV#10");
 8000a72:	4803      	ldr	r0, [pc, #12]	; (8000a80 <chDbgCheckClassI+0x20>)
 8000a74:	f7ff fecc 	bl	8000810 <chSysHalt>
  }
}
 8000a78:	bd08      	pop	{r3, pc}
 8000a7a:	bf00      	nop
 8000a7c:	20002128 	.word	0x20002128
 8000a80:	0800a470 	.word	0x0800a470
	...

08000a90 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8000a90:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000a92:	4b06      	ldr	r3, [pc, #24]	; (8000aac <chDbgCheckClassS+0x1c>)
 8000a94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000a96:	2b00      	cmp	r3, #0
 8000a98:	d103      	bne.n	8000aa2 <chDbgCheckClassS+0x12>
 8000a9a:	4b04      	ldr	r3, [pc, #16]	; (8000aac <chDbgCheckClassS+0x1c>)
 8000a9c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000a9e:	2b00      	cmp	r3, #0
 8000aa0:	dc02      	bgt.n	8000aa8 <chDbgCheckClassS+0x18>
    chSysHalt("SV#11");
 8000aa2:	4803      	ldr	r0, [pc, #12]	; (8000ab0 <chDbgCheckClassS+0x20>)
 8000aa4:	f7ff feb4 	bl	8000810 <chSysHalt>
  }
}
 8000aa8:	bd08      	pop	{r3, pc}
 8000aaa:	bf00      	nop
 8000aac:	20002128 	.word	0x20002128
 8000ab0:	0800a480 	.word	0x0800a480
	...

08000ac0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8000ac0:	4b06      	ldr	r3, [pc, #24]	; (8000adc <_vt_init+0x1c>)
 8000ac2:	4a07      	ldr	r2, [pc, #28]	; (8000ae0 <_vt_init+0x20>)
 8000ac4:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000ac6:	4b05      	ldr	r3, [pc, #20]	; (8000adc <_vt_init+0x1c>)
 8000ac8:	4a05      	ldr	r2, [pc, #20]	; (8000ae0 <_vt_init+0x20>)
 8000aca:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000acc:	4b03      	ldr	r3, [pc, #12]	; (8000adc <_vt_init+0x1c>)
 8000ace:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000ad2:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 8000ad4:	4b01      	ldr	r3, [pc, #4]	; (8000adc <_vt_init+0x1c>)
 8000ad6:	2200      	movs	r2, #0
 8000ad8:	629a      	str	r2, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000ada:	4770      	bx	lr
 8000adc:	20002128 	.word	0x20002128
 8000ae0:	20002144 	.word	0x20002144
	...

08000af0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000af0:	b500      	push	{lr}
 8000af2:	b087      	sub	sp, #28
 8000af4:	9003      	str	r0, [sp, #12]
 8000af6:	9102      	str	r1, [sp, #8]
 8000af8:	9201      	str	r2, [sp, #4]
 8000afa:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 8000afc:	f7ff ffb0 	bl	8000a60 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8000b00:	9b03      	ldr	r3, [sp, #12]
 8000b02:	2b00      	cmp	r3, #0
 8000b04:	d005      	beq.n	8000b12 <chVTDoSetI+0x22>
 8000b06:	9b01      	ldr	r3, [sp, #4]
 8000b08:	2b00      	cmp	r3, #0
 8000b0a:	d002      	beq.n	8000b12 <chVTDoSetI+0x22>
 8000b0c:	9b02      	ldr	r3, [sp, #8]
 8000b0e:	2b00      	cmp	r3, #0
 8000b10:	d102      	bne.n	8000b18 <chVTDoSetI+0x28>
 8000b12:	4821      	ldr	r0, [pc, #132]	; (8000b98 <chVTDoSetI+0xa8>)
 8000b14:	f7ff fe7c 	bl	8000810 <chSysHalt>

  vtp->vt_par = par;
 8000b18:	9b03      	ldr	r3, [sp, #12]
 8000b1a:	9a00      	ldr	r2, [sp, #0]
 8000b1c:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 8000b1e:	9b03      	ldr	r3, [sp, #12]
 8000b20:	9a01      	ldr	r2, [sp, #4]
 8000b22:	60da      	str	r2, [r3, #12]
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
    }
  }
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;
 8000b24:	9b02      	ldr	r3, [sp, #8]
 8000b26:	9304      	str	r3, [sp, #16]

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.vt_next;
 8000b28:	4b1c      	ldr	r3, [pc, #112]	; (8000b9c <chVTDoSetI+0xac>)
 8000b2a:	69db      	ldr	r3, [r3, #28]
 8000b2c:	9305      	str	r3, [sp, #20]
 8000b2e:	e00e      	b.n	8000b4e <chVTDoSetI+0x5e>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 8000b30:	9a05      	ldr	r2, [sp, #20]
 8000b32:	9b03      	ldr	r3, [sp, #12]
 8000b34:	429a      	cmp	r2, r3
 8000b36:	d102      	bne.n	8000b3e <chVTDoSetI+0x4e>
 8000b38:	4817      	ldr	r0, [pc, #92]	; (8000b98 <chVTDoSetI+0xa8>)
 8000b3a:	f7ff fe69 	bl	8000810 <chSysHalt>

    delta -= p->vt_delta;
 8000b3e:	9b05      	ldr	r3, [sp, #20]
 8000b40:	689b      	ldr	r3, [r3, #8]
 8000b42:	9a04      	ldr	r2, [sp, #16]
 8000b44:	1ad3      	subs	r3, r2, r3
 8000b46:	9304      	str	r3, [sp, #16]
    p = p->vt_next;
 8000b48:	9b05      	ldr	r3, [sp, #20]
 8000b4a:	681b      	ldr	r3, [r3, #0]
 8000b4c:	9305      	str	r3, [sp, #20]
  while (p->vt_delta < delta) {
 8000b4e:	9b05      	ldr	r3, [sp, #20]
 8000b50:	689b      	ldr	r3, [r3, #8]
 8000b52:	9a04      	ldr	r2, [sp, #16]
 8000b54:	429a      	cmp	r2, r3
 8000b56:	d8eb      	bhi.n	8000b30 <chVTDoSetI+0x40>
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8000b58:	9b03      	ldr	r3, [sp, #12]
 8000b5a:	9a05      	ldr	r2, [sp, #20]
 8000b5c:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8000b5e:	9b03      	ldr	r3, [sp, #12]
 8000b60:	681b      	ldr	r3, [r3, #0]
 8000b62:	685a      	ldr	r2, [r3, #4]
 8000b64:	9b03      	ldr	r3, [sp, #12]
 8000b66:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 8000b68:	9b03      	ldr	r3, [sp, #12]
 8000b6a:	685b      	ldr	r3, [r3, #4]
 8000b6c:	9a03      	ldr	r2, [sp, #12]
 8000b6e:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 8000b70:	9b05      	ldr	r3, [sp, #20]
 8000b72:	9a03      	ldr	r2, [sp, #12]
 8000b74:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta;
 8000b76:	9b03      	ldr	r3, [sp, #12]
 8000b78:	9a04      	ldr	r2, [sp, #16]
 8000b7a:	609a      	str	r2, [r3, #8]

  /* Calculate new delta for the following entry.*/
  p->vt_delta -= delta;
 8000b7c:	9b05      	ldr	r3, [sp, #20]
 8000b7e:	689a      	ldr	r2, [r3, #8]
 8000b80:	9b04      	ldr	r3, [sp, #16]
 8000b82:	1ad2      	subs	r2, r2, r3
 8000b84:	9b05      	ldr	r3, [sp, #20]
 8000b86:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000b88:	4b04      	ldr	r3, [pc, #16]	; (8000b9c <chVTDoSetI+0xac>)
 8000b8a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000b8e:	625a      	str	r2, [r3, #36]	; 0x24
}
 8000b90:	b007      	add	sp, #28
 8000b92:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b96:	bf00      	nop
 8000b98:	0800a490 	.word	0x0800a490
 8000b9c:	20002128 	.word	0x20002128

08000ba0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000ba0:	b500      	push	{lr}
 8000ba2:	b083      	sub	sp, #12
 8000ba4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8000ba6:	f7ff ff5b 	bl	8000a60 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8000baa:	9b01      	ldr	r3, [sp, #4]
 8000bac:	2b00      	cmp	r3, #0
 8000bae:	d102      	bne.n	8000bb6 <chVTDoResetI+0x16>
 8000bb0:	4813      	ldr	r0, [pc, #76]	; (8000c00 <chVTDoResetI+0x60>)
 8000bb2:	f7ff fe2d 	bl	8000810 <chSysHalt>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
 8000bb6:	9b01      	ldr	r3, [sp, #4]
 8000bb8:	68db      	ldr	r3, [r3, #12]
 8000bba:	2b00      	cmp	r3, #0
 8000bbc:	d102      	bne.n	8000bc4 <chVTDoResetI+0x24>
 8000bbe:	4810      	ldr	r0, [pc, #64]	; (8000c00 <chVTDoResetI+0x60>)
 8000bc0:	f7ff fe26 	bl	8000810 <chSysHalt>

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000bc4:	9b01      	ldr	r3, [sp, #4]
 8000bc6:	681b      	ldr	r3, [r3, #0]
 8000bc8:	6899      	ldr	r1, [r3, #8]
 8000bca:	9b01      	ldr	r3, [sp, #4]
 8000bcc:	689a      	ldr	r2, [r3, #8]
 8000bce:	9b01      	ldr	r3, [sp, #4]
 8000bd0:	681b      	ldr	r3, [r3, #0]
 8000bd2:	440a      	add	r2, r1
 8000bd4:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000bd6:	9b01      	ldr	r3, [sp, #4]
 8000bd8:	685b      	ldr	r3, [r3, #4]
 8000bda:	9a01      	ldr	r2, [sp, #4]
 8000bdc:	6812      	ldr	r2, [r2, #0]
 8000bde:	601a      	str	r2, [r3, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000be0:	9b01      	ldr	r3, [sp, #4]
 8000be2:	681b      	ldr	r3, [r3, #0]
 8000be4:	9a01      	ldr	r2, [sp, #4]
 8000be6:	6852      	ldr	r2, [r2, #4]
 8000be8:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 8000bea:	9b01      	ldr	r3, [sp, #4]
 8000bec:	2200      	movs	r2, #0
 8000bee:	60da      	str	r2, [r3, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000bf0:	4b04      	ldr	r3, [pc, #16]	; (8000c04 <chVTDoResetI+0x64>)
 8000bf2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000bf6:	625a      	str	r2, [r3, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000bf8:	b003      	add	sp, #12
 8000bfa:	f85d fb04 	ldr.w	pc, [sp], #4
 8000bfe:	bf00      	nop
 8000c00:	0800a4a0 	.word	0x0800a4a0
 8000c04:	20002128 	.word	0x20002128
	...

08000c10 <port_lock.lto_priv.104>:
static inline void port_lock(void) {
 8000c10:	b082      	sub	sp, #8
 8000c12:	2320      	movs	r3, #32
 8000c14:	9301      	str	r3, [sp, #4]
 8000c16:	9b01      	ldr	r3, [sp, #4]
 8000c18:	f383 8811 	msr	BASEPRI, r3
}
 8000c1c:	b002      	add	sp, #8
 8000c1e:	4770      	bx	lr

08000c20 <port_unlock.lto_priv.74>:
static inline void port_unlock(void) {
 8000c20:	b082      	sub	sp, #8
 8000c22:	2300      	movs	r3, #0
 8000c24:	9301      	str	r3, [sp, #4]
 8000c26:	9b01      	ldr	r3, [sp, #4]
 8000c28:	f383 8811 	msr	BASEPRI, r3
}
 8000c2c:	b002      	add	sp, #8
 8000c2e:	4770      	bx	lr

08000c30 <port_lock_from_isr.lto_priv.183>:
static inline void port_lock_from_isr(void) {
 8000c30:	b508      	push	{r3, lr}
  port_lock();
 8000c32:	f7ff ffed 	bl	8000c10 <port_lock.lto_priv.104>
}
 8000c36:	bd08      	pop	{r3, pc}
	...

08000c40 <port_unlock_from_isr.lto_priv.170>:
static inline void port_unlock_from_isr(void) {
 8000c40:	b508      	push	{r3, lr}
  port_unlock();
 8000c42:	f7ff ffed 	bl	8000c20 <port_unlock.lto_priv.74>
}
 8000c46:	bd08      	pop	{r3, pc}
	...

08000c50 <queue_init.lto_priv.282>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000c50:	b082      	sub	sp, #8
 8000c52:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8000c54:	9b01      	ldr	r3, [sp, #4]
 8000c56:	9a01      	ldr	r2, [sp, #4]
 8000c58:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000c5a:	9b01      	ldr	r3, [sp, #4]
 8000c5c:	9a01      	ldr	r2, [sp, #4]
 8000c5e:	605a      	str	r2, [r3, #4]
}
 8000c60:	b002      	add	sp, #8
 8000c62:	4770      	bx	lr
	...

08000c70 <queue_fifo_remove.lto_priv.309>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8000c70:	b084      	sub	sp, #16
 8000c72:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8000c74:	9b01      	ldr	r3, [sp, #4]
 8000c76:	681b      	ldr	r3, [r3, #0]
 8000c78:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8000c7a:	9b03      	ldr	r3, [sp, #12]
 8000c7c:	681a      	ldr	r2, [r3, #0]
 8000c7e:	9b01      	ldr	r3, [sp, #4]
 8000c80:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000c82:	9b01      	ldr	r3, [sp, #4]
 8000c84:	681b      	ldr	r3, [r3, #0]
 8000c86:	9a01      	ldr	r2, [sp, #4]
 8000c88:	605a      	str	r2, [r3, #4]

  return tp;
 8000c8a:	9b03      	ldr	r3, [sp, #12]
}
 8000c8c:	4618      	mov	r0, r3
 8000c8e:	b004      	add	sp, #16
 8000c90:	4770      	bx	lr
 8000c92:	bf00      	nop
	...

08000ca0 <queue_dequeue.lto_priv.331>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8000ca0:	b082      	sub	sp, #8
 8000ca2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8000ca4:	9b01      	ldr	r3, [sp, #4]
 8000ca6:	685b      	ldr	r3, [r3, #4]
 8000ca8:	9a01      	ldr	r2, [sp, #4]
 8000caa:	6812      	ldr	r2, [r2, #0]
 8000cac:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000cae:	9b01      	ldr	r3, [sp, #4]
 8000cb0:	681b      	ldr	r3, [r3, #0]
 8000cb2:	9a01      	ldr	r2, [sp, #4]
 8000cb4:	6852      	ldr	r2, [r2, #4]
 8000cb6:	605a      	str	r2, [r3, #4]

  return tp;
 8000cb8:	9b01      	ldr	r3, [sp, #4]
}
 8000cba:	4618      	mov	r0, r3
 8000cbc:	b002      	add	sp, #8
 8000cbe:	4770      	bx	lr

08000cc0 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
 8000cc0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 8000cc2:	f7ff fecd 	bl	8000a60 <chDbgCheckClassI>

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8000cc6:	4b06      	ldr	r3, [pc, #24]	; (8000ce0 <chSchIsRescRequiredI+0x20>)
 8000cc8:	681b      	ldr	r3, [r3, #0]
 8000cca:	689a      	ldr	r2, [r3, #8]
 8000ccc:	4b04      	ldr	r3, [pc, #16]	; (8000ce0 <chSchIsRescRequiredI+0x20>)
 8000cce:	699b      	ldr	r3, [r3, #24]
 8000cd0:	689b      	ldr	r3, [r3, #8]
 8000cd2:	429a      	cmp	r2, r3
 8000cd4:	bf8c      	ite	hi
 8000cd6:	2301      	movhi	r3, #1
 8000cd8:	2300      	movls	r3, #0
 8000cda:	b2db      	uxtb	r3, r3
}
 8000cdc:	4618      	mov	r0, r3
 8000cde:	bd08      	pop	{r3, pc}
 8000ce0:	20002128 	.word	0x20002128
	...

08000cf0 <chSysLockFromISR.lto_priv.159>:
static inline void chSysLockFromISR(void) {
 8000cf0:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8000cf2:	f7ff ff9d 	bl	8000c30 <port_lock_from_isr.lto_priv.183>
  _stats_start_measure_crit_isr();
 8000cf6:	f000 fe03 	bl	8001900 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8000cfa:	f7ff fe41 	bl	8000980 <_dbg_check_lock_from_isr>
}
 8000cfe:	bd08      	pop	{r3, pc}

08000d00 <chSysUnlockFromISR.lto_priv.149>:
static inline void chSysUnlockFromISR(void) {
 8000d00:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 8000d02:	f7ff fe55 	bl	80009b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8000d06:	f000 fe03 	bl	8001910 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 8000d0a:	f7ff ff99 	bl	8000c40 <port_unlock_from_isr.lto_priv.170>
}
 8000d0e:	bd08      	pop	{r3, pc}

08000d10 <chVTIsArmedI>:
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8000d10:	b500      	push	{lr}
 8000d12:	b083      	sub	sp, #12
 8000d14:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8000d16:	f7ff fea3 	bl	8000a60 <chDbgCheckClassI>
  return (bool)(vtp->vt_func != NULL);
 8000d1a:	9b01      	ldr	r3, [sp, #4]
 8000d1c:	68db      	ldr	r3, [r3, #12]
 8000d1e:	2b00      	cmp	r3, #0
 8000d20:	bf14      	ite	ne
 8000d22:	2301      	movne	r3, #1
 8000d24:	2300      	moveq	r3, #0
 8000d26:	b2db      	uxtb	r3, r3
}
 8000d28:	4618      	mov	r0, r3
 8000d2a:	b003      	add	sp, #12
 8000d2c:	f85d fb04 	ldr.w	pc, [sp], #4

08000d30 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8000d30:	b500      	push	{lr}
 8000d32:	b083      	sub	sp, #12
 8000d34:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8000d36:	f7ff fe93 	bl	8000a60 <chDbgCheckClassI>

  sp->s_cnt++;
 8000d3a:	9b01      	ldr	r3, [sp, #4]
 8000d3c:	689b      	ldr	r3, [r3, #8]
 8000d3e:	1c5a      	adds	r2, r3, #1
 8000d40:	9b01      	ldr	r3, [sp, #4]
 8000d42:	609a      	str	r2, [r3, #8]
}
 8000d44:	b003      	add	sp, #12
 8000d46:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d4a:	bf00      	nop
 8000d4c:	0000      	movs	r0, r0
	...

08000d50 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8000d50:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 8000d52:	4806      	ldr	r0, [pc, #24]	; (8000d6c <_scheduler_init+0x1c>)
 8000d54:	f7ff ff7c 	bl	8000c50 <queue_init.lto_priv.282>
  ch.rlist.r_prio = NOPRIO;
 8000d58:	4b04      	ldr	r3, [pc, #16]	; (8000d6c <_scheduler_init+0x1c>)
 8000d5a:	2200      	movs	r2, #0
 8000d5c:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8000d5e:	4b03      	ldr	r3, [pc, #12]	; (8000d6c <_scheduler_init+0x1c>)
 8000d60:	4a02      	ldr	r2, [pc, #8]	; (8000d6c <_scheduler_init+0x1c>)
 8000d62:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8000d64:	4b01      	ldr	r3, [pc, #4]	; (8000d6c <_scheduler_init+0x1c>)
 8000d66:	4a01      	ldr	r2, [pc, #4]	; (8000d6c <_scheduler_init+0x1c>)
 8000d68:	615a      	str	r2, [r3, #20]
#endif
}
 8000d6a:	bd08      	pop	{r3, pc}
 8000d6c:	20002128 	.word	0x20002128

08000d70 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000d70:	b500      	push	{lr}
 8000d72:	b085      	sub	sp, #20
 8000d74:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 8000d76:	f7ff fe73 	bl	8000a60 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000d7a:	9b01      	ldr	r3, [sp, #4]
 8000d7c:	2b00      	cmp	r3, #0
 8000d7e:	d102      	bne.n	8000d86 <chSchReadyI+0x16>
 8000d80:	4818      	ldr	r0, [pc, #96]	; (8000de4 <chSchReadyI+0x74>)
 8000d82:	f7ff fd45 	bl	8000810 <chSysHalt>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
 8000d86:	9b01      	ldr	r3, [sp, #4]
 8000d88:	f893 3020 	ldrb.w	r3, [r3, #32]
 8000d8c:	2b00      	cmp	r3, #0
 8000d8e:	d004      	beq.n	8000d9a <chSchReadyI+0x2a>
 8000d90:	9b01      	ldr	r3, [sp, #4]
 8000d92:	f893 3020 	ldrb.w	r3, [r3, #32]
 8000d96:	2b0f      	cmp	r3, #15
 8000d98:	d102      	bne.n	8000da0 <chSchReadyI+0x30>
 8000d9a:	4812      	ldr	r0, [pc, #72]	; (8000de4 <chSchReadyI+0x74>)
 8000d9c:	f7ff fd38 	bl	8000810 <chSysHalt>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000da0:	9b01      	ldr	r3, [sp, #4]
 8000da2:	2200      	movs	r2, #0
 8000da4:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000da8:	4b0f      	ldr	r3, [pc, #60]	; (8000de8 <chSchReadyI+0x78>)
 8000daa:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8000dac:	9b03      	ldr	r3, [sp, #12]
 8000dae:	681b      	ldr	r3, [r3, #0]
 8000db0:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8000db2:	9b03      	ldr	r3, [sp, #12]
 8000db4:	689a      	ldr	r2, [r3, #8]
 8000db6:	9b01      	ldr	r3, [sp, #4]
 8000db8:	689b      	ldr	r3, [r3, #8]
 8000dba:	429a      	cmp	r2, r3
 8000dbc:	d2f6      	bcs.n	8000dac <chSchReadyI+0x3c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000dbe:	9b01      	ldr	r3, [sp, #4]
 8000dc0:	9a03      	ldr	r2, [sp, #12]
 8000dc2:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8000dc4:	9b03      	ldr	r3, [sp, #12]
 8000dc6:	685a      	ldr	r2, [r3, #4]
 8000dc8:	9b01      	ldr	r3, [sp, #4]
 8000dca:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8000dcc:	9b01      	ldr	r3, [sp, #4]
 8000dce:	685b      	ldr	r3, [r3, #4]
 8000dd0:	9a01      	ldr	r2, [sp, #4]
 8000dd2:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8000dd4:	9b03      	ldr	r3, [sp, #12]
 8000dd6:	9a01      	ldr	r2, [sp, #4]
 8000dd8:	605a      	str	r2, [r3, #4]

  return tp;
 8000dda:	9b01      	ldr	r3, [sp, #4]
}
 8000ddc:	4618      	mov	r0, r3
 8000dde:	b005      	add	sp, #20
 8000de0:	f85d fb04 	ldr.w	pc, [sp], #4
 8000de4:	0800a4c0 	.word	0x0800a4c0
 8000de8:	20002128 	.word	0x20002128
 8000dec:	00000000 	.word	0x00000000

08000df0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000df0:	b510      	push	{r4, lr}
 8000df2:	b084      	sub	sp, #16
 8000df4:	4603      	mov	r3, r0
 8000df6:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();
 8000dfa:	f7ff fe49 	bl	8000a90 <chDbgCheckClassS>

  otp = currp;
 8000dfe:	4b18      	ldr	r3, [pc, #96]	; (8000e60 <chSchGoSleepS+0x70>)
 8000e00:	699b      	ldr	r3, [r3, #24]
 8000e02:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 8000e04:	9b03      	ldr	r3, [sp, #12]
 8000e06:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8000e0a:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000e0e:	4814      	ldr	r0, [pc, #80]	; (8000e60 <chSchGoSleepS+0x70>)
 8000e10:	f7ff ff2e 	bl	8000c70 <queue_fifo_remove.lto_priv.309>
 8000e14:	4602      	mov	r2, r0
 8000e16:	4b12      	ldr	r3, [pc, #72]	; (8000e60 <chSchGoSleepS+0x70>)
 8000e18:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000e1a:	4b11      	ldr	r3, [pc, #68]	; (8000e60 <chSchGoSleepS+0x70>)
 8000e1c:	699b      	ldr	r3, [r3, #24]
 8000e1e:	2201      	movs	r2, #1
 8000e20:	f883 2020 	strb.w	r2, [r3, #32]
  chSysSwitch(currp, otp);
 8000e24:	4b0e      	ldr	r3, [pc, #56]	; (8000e60 <chSchGoSleepS+0x70>)
 8000e26:	699b      	ldr	r3, [r3, #24]
 8000e28:	9903      	ldr	r1, [sp, #12]
 8000e2a:	4618      	mov	r0, r3
 8000e2c:	f000 fd38 	bl	80018a0 <_stats_ctxswc>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000e30:	f3ef 8309 	mrs	r3, PSP
 8000e34:	461c      	mov	r4, r3
  return(result);
 8000e36:	4623      	mov	r3, r4
 8000e38:	9302      	str	r3, [sp, #8]
 8000e3a:	9b02      	ldr	r3, [sp, #8]
 8000e3c:	f1a3 0264 	sub.w	r2, r3, #100	; 0x64
 8000e40:	9b03      	ldr	r3, [sp, #12]
 8000e42:	69db      	ldr	r3, [r3, #28]
 8000e44:	429a      	cmp	r2, r3
 8000e46:	d202      	bcs.n	8000e4e <chSchGoSleepS+0x5e>
 8000e48:	4806      	ldr	r0, [pc, #24]	; (8000e64 <chSchGoSleepS+0x74>)
 8000e4a:	f7ff fce1 	bl	8000810 <chSysHalt>
 8000e4e:	4b04      	ldr	r3, [pc, #16]	; (8000e60 <chSchGoSleepS+0x70>)
 8000e50:	699b      	ldr	r3, [r3, #24]
 8000e52:	9903      	ldr	r1, [sp, #12]
 8000e54:	4618      	mov	r0, r3
 8000e56:	f7ff fa3b 	bl	80002d0 <_port_switch>
}
 8000e5a:	b004      	add	sp, #16
 8000e5c:	bd10      	pop	{r4, pc}
 8000e5e:	bf00      	nop
 8000e60:	20002128 	.word	0x20002128
 8000e64:	0800a4b0 	.word	0x0800a4b0
	...

08000e70 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000e70:	b500      	push	{lr}
 8000e72:	b085      	sub	sp, #20
 8000e74:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8000e76:	9b01      	ldr	r3, [sp, #4]
 8000e78:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8000e7a:	f7ff ff39 	bl	8000cf0 <chSysLockFromISR.lto_priv.159>
  switch (tp->p_state) {
 8000e7e:	9b03      	ldr	r3, [sp, #12]
 8000e80:	f893 3020 	ldrb.w	r3, [r3, #32]
 8000e84:	2b07      	cmp	r3, #7
 8000e86:	d823      	bhi.n	8000ed0 <wakeup+0x60>
 8000e88:	a201      	add	r2, pc, #4	; (adr r2, 8000e90 <wakeup+0x20>)
 8000e8a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000e8e:	bf00      	nop
 8000e90:	08000eb1 	.word	0x08000eb1
 8000e94:	08000ed1 	.word	0x08000ed1
 8000e98:	08000ed1 	.word	0x08000ed1
 8000e9c:	08000eb7 	.word	0x08000eb7
 8000ea0:	08000ecb 	.word	0x08000ecb
 8000ea4:	08000ec1 	.word	0x08000ec1
 8000ea8:	08000ed1 	.word	0x08000ed1
 8000eac:	08000ecb 	.word	0x08000ecb
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8000eb0:	f7ff ff26 	bl	8000d00 <chSysUnlockFromISR.lto_priv.149>
 8000eb4:	e015      	b.n	8000ee2 <wakeup+0x72>
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8000eb6:	9b03      	ldr	r3, [sp, #12]
 8000eb8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000eba:	2200      	movs	r2, #0
 8000ebc:	601a      	str	r2, [r3, #0]
 8000ebe:	e007      	b.n	8000ed0 <wakeup+0x60>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8000ec0:	9b03      	ldr	r3, [sp, #12]
 8000ec2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000ec4:	4618      	mov	r0, r3
 8000ec6:	f7ff ff33 	bl	8000d30 <chSemFastSignalI>
    /* Falls through.*/
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8000eca:	9803      	ldr	r0, [sp, #12]
 8000ecc:	f7ff fee8 	bl	8000ca0 <queue_dequeue.lto_priv.331>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000ed0:	9b03      	ldr	r3, [sp, #12]
 8000ed2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000ed6:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000ed8:	9803      	ldr	r0, [sp, #12]
 8000eda:	f7ff ff49 	bl	8000d70 <chSchReadyI>
  chSysUnlockFromISR();
 8000ede:	f7ff ff0f 	bl	8000d00 <chSysUnlockFromISR.lto_priv.149>
}
 8000ee2:	b005      	add	sp, #20
 8000ee4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000ef0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000ef0:	b500      	push	{lr}
 8000ef2:	b089      	sub	sp, #36	; 0x24
 8000ef4:	4603      	mov	r3, r0
 8000ef6:	9100      	str	r1, [sp, #0]
 8000ef8:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();
 8000efc:	f7ff fdc8 	bl	8000a90 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 8000f00:	9b00      	ldr	r3, [sp, #0]
 8000f02:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8000f06:	d017      	beq.n	8000f38 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000f08:	4b11      	ldr	r3, [pc, #68]	; (8000f50 <chSchGoSleepTimeoutS+0x60>)
 8000f0a:	699b      	ldr	r3, [r3, #24]
 8000f0c:	a803      	add	r0, sp, #12
 8000f0e:	4a11      	ldr	r2, [pc, #68]	; (8000f54 <chSchGoSleepTimeoutS+0x64>)
 8000f10:	9900      	ldr	r1, [sp, #0]
 8000f12:	f7ff fded 	bl	8000af0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000f16:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000f1a:	4618      	mov	r0, r3
 8000f1c:	f7ff ff68 	bl	8000df0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000f20:	ab03      	add	r3, sp, #12
 8000f22:	4618      	mov	r0, r3
 8000f24:	f7ff fef4 	bl	8000d10 <chVTIsArmedI>
 8000f28:	4603      	mov	r3, r0
 8000f2a:	2b00      	cmp	r3, #0
 8000f2c:	d009      	beq.n	8000f42 <chSchGoSleepTimeoutS+0x52>
      chVTDoResetI(&vt);
 8000f2e:	ab03      	add	r3, sp, #12
 8000f30:	4618      	mov	r0, r3
 8000f32:	f7ff fe35 	bl	8000ba0 <chVTDoResetI>
 8000f36:	e004      	b.n	8000f42 <chSchGoSleepTimeoutS+0x52>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000f38:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000f3c:	4618      	mov	r0, r3
 8000f3e:	f7ff ff57 	bl	8000df0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8000f42:	4b03      	ldr	r3, [pc, #12]	; (8000f50 <chSchGoSleepTimeoutS+0x60>)
 8000f44:	699b      	ldr	r3, [r3, #24]
 8000f46:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8000f48:	4618      	mov	r0, r3
 8000f4a:	b009      	add	sp, #36	; 0x24
 8000f4c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f50:	20002128 	.word	0x20002128
 8000f54:	08000e71 	.word	0x08000e71
	...

08000f60 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000f60:	b510      	push	{r4, lr}
 8000f62:	b084      	sub	sp, #16
 8000f64:	9001      	str	r0, [sp, #4]
 8000f66:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
 8000f68:	f7ff fd92 	bl	8000a90 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8000f6c:	4b21      	ldr	r3, [pc, #132]	; (8000ff4 <chSchWakeupS+0x94>)
 8000f6e:	681b      	ldr	r3, [r3, #0]
 8000f70:	4a20      	ldr	r2, [pc, #128]	; (8000ff4 <chSchWakeupS+0x94>)
 8000f72:	4293      	cmp	r3, r2
 8000f74:	d00a      	beq.n	8000f8c <chSchWakeupS+0x2c>
 8000f76:	4b1f      	ldr	r3, [pc, #124]	; (8000ff4 <chSchWakeupS+0x94>)
 8000f78:	699b      	ldr	r3, [r3, #24]
 8000f7a:	689a      	ldr	r2, [r3, #8]
 8000f7c:	4b1d      	ldr	r3, [pc, #116]	; (8000ff4 <chSchWakeupS+0x94>)
 8000f7e:	681b      	ldr	r3, [r3, #0]
 8000f80:	689b      	ldr	r3, [r3, #8]
 8000f82:	429a      	cmp	r2, r3
 8000f84:	d202      	bcs.n	8000f8c <chSchWakeupS+0x2c>
 8000f86:	481c      	ldr	r0, [pc, #112]	; (8000ff8 <chSchWakeupS+0x98>)
 8000f88:	f7ff fc42 	bl	8000810 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000f8c:	9b01      	ldr	r3, [sp, #4]
 8000f8e:	9a00      	ldr	r2, [sp, #0]
 8000f90:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000f92:	9b01      	ldr	r3, [sp, #4]
 8000f94:	689a      	ldr	r2, [r3, #8]
 8000f96:	4b17      	ldr	r3, [pc, #92]	; (8000ff4 <chSchWakeupS+0x94>)
 8000f98:	699b      	ldr	r3, [r3, #24]
 8000f9a:	689b      	ldr	r3, [r3, #8]
 8000f9c:	429a      	cmp	r2, r3
 8000f9e:	d803      	bhi.n	8000fa8 <chSchWakeupS+0x48>
    (void) chSchReadyI(ntp);
 8000fa0:	9801      	ldr	r0, [sp, #4]
 8000fa2:	f7ff fee5 	bl	8000d70 <chSchReadyI>
 8000fa6:	e023      	b.n	8000ff0 <chSchWakeupS+0x90>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000fa8:	4b12      	ldr	r3, [pc, #72]	; (8000ff4 <chSchWakeupS+0x94>)
 8000faa:	699b      	ldr	r3, [r3, #24]
 8000fac:	4618      	mov	r0, r3
 8000fae:	f7ff fedf 	bl	8000d70 <chSchReadyI>
 8000fb2:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
 8000fb4:	4a0f      	ldr	r2, [pc, #60]	; (8000ff4 <chSchWakeupS+0x94>)
 8000fb6:	9b01      	ldr	r3, [sp, #4]
 8000fb8:	6193      	str	r3, [r2, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000fba:	9b01      	ldr	r3, [sp, #4]
 8000fbc:	2201      	movs	r2, #1
 8000fbe:	f883 2020 	strb.w	r2, [r3, #32]
    chSysSwitch(ntp, otp);
 8000fc2:	9903      	ldr	r1, [sp, #12]
 8000fc4:	9801      	ldr	r0, [sp, #4]
 8000fc6:	f000 fc6b 	bl	80018a0 <_stats_ctxswc>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000fca:	f3ef 8309 	mrs	r3, PSP
 8000fce:	461c      	mov	r4, r3
  return(result);
 8000fd0:	4623      	mov	r3, r4
 8000fd2:	9302      	str	r3, [sp, #8]
 8000fd4:	9b02      	ldr	r3, [sp, #8]
 8000fd6:	f1a3 0264 	sub.w	r2, r3, #100	; 0x64
 8000fda:	9b03      	ldr	r3, [sp, #12]
 8000fdc:	69db      	ldr	r3, [r3, #28]
 8000fde:	429a      	cmp	r2, r3
 8000fe0:	d202      	bcs.n	8000fe8 <chSchWakeupS+0x88>
 8000fe2:	4806      	ldr	r0, [pc, #24]	; (8000ffc <chSchWakeupS+0x9c>)
 8000fe4:	f7ff fc14 	bl	8000810 <chSysHalt>
 8000fe8:	9903      	ldr	r1, [sp, #12]
 8000fea:	9801      	ldr	r0, [sp, #4]
 8000fec:	f7ff f970 	bl	80002d0 <_port_switch>
  }
}
 8000ff0:	b004      	add	sp, #16
 8000ff2:	bd10      	pop	{r4, pc}
 8000ff4:	20002128 	.word	0x20002128
 8000ff8:	0800a4d0 	.word	0x0800a4d0
 8000ffc:	0800a4b0 	.word	0x0800a4b0

08001000 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8001000:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 8001002:	f7ff fd45 	bl	8000a90 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 8001006:	f7ff fe5b 	bl	8000cc0 <chSchIsRescRequiredI>
 800100a:	4603      	mov	r3, r0
 800100c:	2b00      	cmp	r3, #0
 800100e:	d001      	beq.n	8001014 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
 8001010:	f000 f81e 	bl	8001050 <chSchDoRescheduleAhead>
  }
}
 8001014:	bd08      	pop	{r3, pc}
 8001016:	bf00      	nop
	...

08001020 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8001020:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8001022:	4b09      	ldr	r3, [pc, #36]	; (8001048 <chSchIsPreemptionRequired+0x28>)
 8001024:	681b      	ldr	r3, [r3, #0]
 8001026:	689b      	ldr	r3, [r3, #8]
 8001028:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 800102a:	4b07      	ldr	r3, [pc, #28]	; (8001048 <chSchIsPreemptionRequired+0x28>)
 800102c:	699b      	ldr	r3, [r3, #24]
 800102e:	689b      	ldr	r3, [r3, #8]
 8001030:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8001032:	9a01      	ldr	r2, [sp, #4]
 8001034:	9b00      	ldr	r3, [sp, #0]
 8001036:	429a      	cmp	r2, r3
 8001038:	bf8c      	ite	hi
 800103a:	2301      	movhi	r3, #1
 800103c:	2300      	movls	r3, #0
 800103e:	b2db      	uxtb	r3, r3
#endif
}
 8001040:	4618      	mov	r0, r3
 8001042:	b002      	add	sp, #8
 8001044:	4770      	bx	lr
 8001046:	bf00      	nop
 8001048:	20002128 	.word	0x20002128
 800104c:	00000000 	.word	0x00000000

08001050 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8001050:	b510      	push	{r4, lr}
 8001052:	b084      	sub	sp, #16
  thread_t *otp, *cp;

  otp = currp;
 8001054:	4b23      	ldr	r3, [pc, #140]	; (80010e4 <chSchDoRescheduleAhead+0x94>)
 8001056:	699b      	ldr	r3, [r3, #24]
 8001058:	9302      	str	r3, [sp, #8]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800105a:	4822      	ldr	r0, [pc, #136]	; (80010e4 <chSchDoRescheduleAhead+0x94>)
 800105c:	f7ff fe08 	bl	8000c70 <queue_fifo_remove.lto_priv.309>
 8001060:	4602      	mov	r2, r0
 8001062:	4b20      	ldr	r3, [pc, #128]	; (80010e4 <chSchDoRescheduleAhead+0x94>)
 8001064:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001066:	4b1f      	ldr	r3, [pc, #124]	; (80010e4 <chSchDoRescheduleAhead+0x94>)
 8001068:	699b      	ldr	r3, [r3, #24]
 800106a:	2201      	movs	r2, #1
 800106c:	f883 2020 	strb.w	r2, [r3, #32]

  otp->p_state = CH_STATE_READY;
 8001070:	9b02      	ldr	r3, [sp, #8]
 8001072:	2200      	movs	r2, #0
 8001074:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001078:	4b1a      	ldr	r3, [pc, #104]	; (80010e4 <chSchDoRescheduleAhead+0x94>)
 800107a:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800107c:	9b03      	ldr	r3, [sp, #12]
 800107e:	681b      	ldr	r3, [r3, #0]
 8001080:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio > otp->p_prio);
 8001082:	9b03      	ldr	r3, [sp, #12]
 8001084:	689a      	ldr	r2, [r3, #8]
 8001086:	9b02      	ldr	r3, [sp, #8]
 8001088:	689b      	ldr	r3, [r3, #8]
 800108a:	429a      	cmp	r2, r3
 800108c:	d8f6      	bhi.n	800107c <chSchDoRescheduleAhead+0x2c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 800108e:	9b02      	ldr	r3, [sp, #8]
 8001090:	9a03      	ldr	r2, [sp, #12]
 8001092:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 8001094:	9b03      	ldr	r3, [sp, #12]
 8001096:	685a      	ldr	r2, [r3, #4]
 8001098:	9b02      	ldr	r3, [sp, #8]
 800109a:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 800109c:	9b02      	ldr	r3, [sp, #8]
 800109e:	685b      	ldr	r3, [r3, #4]
 80010a0:	9a02      	ldr	r2, [sp, #8]
 80010a2:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 80010a4:	9b03      	ldr	r3, [sp, #12]
 80010a6:	9a02      	ldr	r2, [sp, #8]
 80010a8:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 80010aa:	4b0e      	ldr	r3, [pc, #56]	; (80010e4 <chSchDoRescheduleAhead+0x94>)
 80010ac:	699b      	ldr	r3, [r3, #24]
 80010ae:	9902      	ldr	r1, [sp, #8]
 80010b0:	4618      	mov	r0, r3
 80010b2:	f000 fbf5 	bl	80018a0 <_stats_ctxswc>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80010b6:	f3ef 8309 	mrs	r3, PSP
 80010ba:	461c      	mov	r4, r3
  return(result);
 80010bc:	4623      	mov	r3, r4
 80010be:	9301      	str	r3, [sp, #4]
 80010c0:	9b01      	ldr	r3, [sp, #4]
 80010c2:	f1a3 0264 	sub.w	r2, r3, #100	; 0x64
 80010c6:	9b02      	ldr	r3, [sp, #8]
 80010c8:	69db      	ldr	r3, [r3, #28]
 80010ca:	429a      	cmp	r2, r3
 80010cc:	d202      	bcs.n	80010d4 <chSchDoRescheduleAhead+0x84>
 80010ce:	4806      	ldr	r0, [pc, #24]	; (80010e8 <chSchDoRescheduleAhead+0x98>)
 80010d0:	f7ff fb9e 	bl	8000810 <chSysHalt>
 80010d4:	4b03      	ldr	r3, [pc, #12]	; (80010e4 <chSchDoRescheduleAhead+0x94>)
 80010d6:	699b      	ldr	r3, [r3, #24]
 80010d8:	9902      	ldr	r1, [sp, #8]
 80010da:	4618      	mov	r0, r3
 80010dc:	f7ff f8f8 	bl	80002d0 <_port_switch>
}
 80010e0:	b004      	add	sp, #16
 80010e2:	bd10      	pop	{r4, pc}
 80010e4:	20002128 	.word	0x20002128
 80010e8:	0800a4b0 	.word	0x0800a4b0
 80010ec:	00000000 	.word	0x00000000

080010f0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 80010f0:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 80010f2:	f7ff ffad 	bl	8001050 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 80010f6:	bd08      	pop	{r3, pc}
	...

08001100 <port_lock.lto_priv.105>:
static inline void port_lock(void) {
 8001100:	b082      	sub	sp, #8
 8001102:	2320      	movs	r3, #32
 8001104:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001106:	9b01      	ldr	r3, [sp, #4]
 8001108:	f383 8811 	msr	BASEPRI, r3
}
 800110c:	b002      	add	sp, #8
 800110e:	4770      	bx	lr

08001110 <port_unlock.lto_priv.75>:
static inline void port_unlock(void) {
 8001110:	b082      	sub	sp, #8
 8001112:	2300      	movs	r3, #0
 8001114:	9301      	str	r3, [sp, #4]
 8001116:	9b01      	ldr	r3, [sp, #4]
 8001118:	f383 8811 	msr	BASEPRI, r3
}
 800111c:	b002      	add	sp, #8
 800111e:	4770      	bx	lr

08001120 <list_init>:
static inline void list_init(threads_list_t *tlp) {
 8001120:	b082      	sub	sp, #8
 8001122:	9001      	str	r0, [sp, #4]
  tlp->p_next = (thread_t *)tlp;
 8001124:	9b01      	ldr	r3, [sp, #4]
 8001126:	9a01      	ldr	r2, [sp, #4]
 8001128:	601a      	str	r2, [r3, #0]
}
 800112a:	b002      	add	sp, #8
 800112c:	4770      	bx	lr
 800112e:	bf00      	nop

08001130 <list_notempty>:
static inline bool list_notempty(threads_list_t *tlp) {
 8001130:	b082      	sub	sp, #8
 8001132:	9001      	str	r0, [sp, #4]
  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001134:	9b01      	ldr	r3, [sp, #4]
 8001136:	681b      	ldr	r3, [r3, #0]
 8001138:	9a01      	ldr	r2, [sp, #4]
 800113a:	429a      	cmp	r2, r3
 800113c:	bf14      	ite	ne
 800113e:	2301      	movne	r3, #1
 8001140:	2300      	moveq	r3, #0
 8001142:	b2db      	uxtb	r3, r3
}
 8001144:	4618      	mov	r0, r3
 8001146:	b002      	add	sp, #8
 8001148:	4770      	bx	lr
 800114a:	bf00      	nop
 800114c:	0000      	movs	r0, r0
	...

08001150 <queue_init.lto_priv.283>:
static inline void queue_init(threads_queue_t *tqp) {
 8001150:	b082      	sub	sp, #8
 8001152:	9001      	str	r0, [sp, #4]
  tqp->p_next = (thread_t *)tqp;
 8001154:	9b01      	ldr	r3, [sp, #4]
 8001156:	9a01      	ldr	r2, [sp, #4]
 8001158:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800115a:	9b01      	ldr	r3, [sp, #4]
 800115c:	9a01      	ldr	r2, [sp, #4]
 800115e:	605a      	str	r2, [r3, #4]
}
 8001160:	b002      	add	sp, #8
 8001162:	4770      	bx	lr
	...

08001170 <queue_notempty.lto_priv.327>:
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8001170:	b082      	sub	sp, #8
 8001172:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001174:	9b01      	ldr	r3, [sp, #4]
 8001176:	681b      	ldr	r3, [r3, #0]
 8001178:	9a01      	ldr	r2, [sp, #4]
 800117a:	429a      	cmp	r2, r3
 800117c:	bf14      	ite	ne
 800117e:	2301      	movne	r3, #1
 8001180:	2300      	moveq	r3, #0
 8001182:	b2db      	uxtb	r3, r3
}
 8001184:	4618      	mov	r0, r3
 8001186:	b002      	add	sp, #8
 8001188:	4770      	bx	lr
 800118a:	bf00      	nop
 800118c:	0000      	movs	r0, r0
	...

08001190 <list_remove>:
static inline thread_t *list_remove(threads_list_t *tlp) {
 8001190:	b084      	sub	sp, #16
 8001192:	9001      	str	r0, [sp, #4]
  thread_t *tp = tlp->p_next;
 8001194:	9b01      	ldr	r3, [sp, #4]
 8001196:	681b      	ldr	r3, [r3, #0]
 8001198:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 800119a:	9b03      	ldr	r3, [sp, #12]
 800119c:	681a      	ldr	r2, [r3, #0]
 800119e:	9b01      	ldr	r3, [sp, #4]
 80011a0:	601a      	str	r2, [r3, #0]
  return tp;
 80011a2:	9b03      	ldr	r3, [sp, #12]
}
 80011a4:	4618      	mov	r0, r3
 80011a6:	b004      	add	sp, #16
 80011a8:	4770      	bx	lr
 80011aa:	bf00      	nop
 80011ac:	0000      	movs	r0, r0
	...

080011b0 <queue_insert.lto_priv.315>:
static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 80011b0:	b082      	sub	sp, #8
 80011b2:	9001      	str	r0, [sp, #4]
 80011b4:	9100      	str	r1, [sp, #0]
  tp->p_next = (thread_t *)tqp;
 80011b6:	9b01      	ldr	r3, [sp, #4]
 80011b8:	9a00      	ldr	r2, [sp, #0]
 80011ba:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 80011bc:	9b00      	ldr	r3, [sp, #0]
 80011be:	685a      	ldr	r2, [r3, #4]
 80011c0:	9b01      	ldr	r3, [sp, #4]
 80011c2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80011c4:	9b01      	ldr	r3, [sp, #4]
 80011c6:	685b      	ldr	r3, [r3, #4]
 80011c8:	9a01      	ldr	r2, [sp, #4]
 80011ca:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 80011cc:	9b00      	ldr	r3, [sp, #0]
 80011ce:	9a01      	ldr	r2, [sp, #4]
 80011d0:	605a      	str	r2, [r3, #4]
}
 80011d2:	b002      	add	sp, #8
 80011d4:	4770      	bx	lr
 80011d6:	bf00      	nop
	...

080011e0 <queue_fifo_remove.lto_priv.310>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80011e0:	b084      	sub	sp, #16
 80011e2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 80011e4:	9b01      	ldr	r3, [sp, #4]
 80011e6:	681b      	ldr	r3, [r3, #0]
 80011e8:	9303      	str	r3, [sp, #12]
  tqp->p_next = tp->p_next;
 80011ea:	9b03      	ldr	r3, [sp, #12]
 80011ec:	681a      	ldr	r2, [r3, #0]
 80011ee:	9b01      	ldr	r3, [sp, #4]
 80011f0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80011f2:	9b01      	ldr	r3, [sp, #4]
 80011f4:	681b      	ldr	r3, [r3, #0]
 80011f6:	9a01      	ldr	r2, [sp, #4]
 80011f8:	605a      	str	r2, [r3, #4]
  return tp;
 80011fa:	9b03      	ldr	r3, [sp, #12]
}
 80011fc:	4618      	mov	r0, r3
 80011fe:	b004      	add	sp, #16
 8001200:	4770      	bx	lr
 8001202:	bf00      	nop
	...

08001210 <chSysLock.lto_priv.50>:
static inline void chSysLock(void) {
 8001210:	b508      	push	{r3, lr}
  port_lock();
 8001212:	f7ff ff75 	bl	8001100 <port_lock.lto_priv.105>
  _stats_start_measure_crit_thd();
 8001216:	f000 fb63 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800121a:	f7ff fb81 	bl	8000920 <_dbg_check_lock>
}
 800121e:	bd08      	pop	{r3, pc}

08001220 <chSysUnlock.lto_priv.9>:
static inline void chSysUnlock(void) {
 8001220:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8001222:	f7ff fb95 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001226:	f000 fb63 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800122a:	4b09      	ldr	r3, [pc, #36]	; (8001250 <chSysUnlock.lto_priv.9+0x30>)
 800122c:	681b      	ldr	r3, [r3, #0]
 800122e:	4a08      	ldr	r2, [pc, #32]	; (8001250 <chSysUnlock.lto_priv.9+0x30>)
 8001230:	4293      	cmp	r3, r2
 8001232:	d00a      	beq.n	800124a <chSysUnlock.lto_priv.9+0x2a>
 8001234:	4b06      	ldr	r3, [pc, #24]	; (8001250 <chSysUnlock.lto_priv.9+0x30>)
 8001236:	699b      	ldr	r3, [r3, #24]
 8001238:	689a      	ldr	r2, [r3, #8]
 800123a:	4b05      	ldr	r3, [pc, #20]	; (8001250 <chSysUnlock.lto_priv.9+0x30>)
 800123c:	681b      	ldr	r3, [r3, #0]
 800123e:	689b      	ldr	r3, [r3, #8]
 8001240:	429a      	cmp	r2, r3
 8001242:	d202      	bcs.n	800124a <chSysUnlock.lto_priv.9+0x2a>
 8001244:	4803      	ldr	r0, [pc, #12]	; (8001254 <chSysUnlock.lto_priv.9+0x34>)
 8001246:	f7ff fae3 	bl	8000810 <chSysHalt>
  port_unlock();
 800124a:	f7ff ff61 	bl	8001110 <port_unlock.lto_priv.75>
}
 800124e:	bd08      	pop	{r3, pc}
 8001250:	20002128 	.word	0x20002128
 8001254:	0800a4f0 	.word	0x0800a4f0
	...

08001260 <chThdGetSelfX.lto_priv.323>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001260:	4b01      	ldr	r3, [pc, #4]	; (8001268 <chThdGetSelfX.lto_priv.323+0x8>)
 8001262:	699b      	ldr	r3, [r3, #24]
}
 8001264:	4618      	mov	r0, r3
 8001266:	4770      	bx	lr
 8001268:	20002128 	.word	0x20002128
 800126c:	00000000 	.word	0x00000000

08001270 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 8001270:	b500      	push	{lr}
 8001272:	b083      	sub	sp, #12
 8001274:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);
 8001276:	9b01      	ldr	r3, [sp, #4]
 8001278:	2b00      	cmp	r3, #0
 800127a:	d102      	bne.n	8001282 <chThdSleepS+0x12>
 800127c:	4804      	ldr	r0, [pc, #16]	; (8001290 <chThdSleepS+0x20>)
 800127e:	f7ff fac7 	bl	8000810 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8001282:	9901      	ldr	r1, [sp, #4]
 8001284:	2008      	movs	r0, #8
 8001286:	f7ff fe33 	bl	8000ef0 <chSchGoSleepTimeoutS>
}
 800128a:	b003      	add	sp, #12
 800128c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001290:	0800a500 	.word	0x0800a500
	...

080012a0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80012a0:	b500      	push	{lr}
 80012a2:	b085      	sub	sp, #20
 80012a4:	9001      	str	r0, [sp, #4]
 80012a6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 80012a8:	9801      	ldr	r0, [sp, #4]
 80012aa:	f7ff ff61 	bl	8001170 <queue_notempty.lto_priv.327>
 80012ae:	4603      	mov	r3, r0
 80012b0:	f083 0301 	eor.w	r3, r3, #1
 80012b4:	b2db      	uxtb	r3, r3
 80012b6:	2b00      	cmp	r3, #0
 80012b8:	d002      	beq.n	80012c0 <chThdDoDequeueNextI+0x20>
 80012ba:	480c      	ldr	r0, [pc, #48]	; (80012ec <chThdDoDequeueNextI+0x4c>)
 80012bc:	f7ff faa8 	bl	8000810 <chSysHalt>

  tp = queue_fifo_remove(tqp);
 80012c0:	9801      	ldr	r0, [sp, #4]
 80012c2:	f7ff ff8d 	bl	80011e0 <queue_fifo_remove.lto_priv.310>
 80012c6:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 80012c8:	9b03      	ldr	r3, [sp, #12]
 80012ca:	f893 3020 	ldrb.w	r3, [r3, #32]
 80012ce:	2b04      	cmp	r3, #4
 80012d0:	d002      	beq.n	80012d8 <chThdDoDequeueNextI+0x38>
 80012d2:	4806      	ldr	r0, [pc, #24]	; (80012ec <chThdDoDequeueNextI+0x4c>)
 80012d4:	f7ff fa9c 	bl	8000810 <chSysHalt>

  tp->p_u.rdymsg = msg;
 80012d8:	9b03      	ldr	r3, [sp, #12]
 80012da:	9a00      	ldr	r2, [sp, #0]
 80012dc:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 80012de:	9803      	ldr	r0, [sp, #12]
 80012e0:	f7ff fd46 	bl	8000d70 <chSchReadyI>
}
 80012e4:	b005      	add	sp, #20
 80012e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80012ea:	bf00      	nop
 80012ec:	0800a540 	.word	0x0800a540

080012f0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 80012f0:	b500      	push	{lr}
 80012f2:	b083      	sub	sp, #12
 80012f4:	9001      	str	r0, [sp, #4]
 80012f6:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 80012f8:	9b01      	ldr	r3, [sp, #4]
 80012fa:	9a00      	ldr	r2, [sp, #0]
 80012fc:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 80012fe:	9b01      	ldr	r3, [sp, #4]
 8001300:	2202      	movs	r2, #2
 8001302:	f883 2020 	strb.w	r2, [r3, #32]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001306:	9b01      	ldr	r3, [sp, #4]
 8001308:	2200      	movs	r2, #0
 800130a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800130e:	9b01      	ldr	r3, [sp, #4]
 8001310:	9a00      	ldr	r2, [sp, #0]
 8001312:	641a      	str	r2, [r3, #64]	; 0x40
  tp->p_mtxlist = NULL;
 8001314:	9b01      	ldr	r3, [sp, #4]
 8001316:	2200      	movs	r2, #0
 8001318:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800131a:	9b01      	ldr	r3, [sp, #4]
 800131c:	2200      	movs	r2, #0
 800131e:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001320:	9b01      	ldr	r3, [sp, #4]
 8001322:	2201      	movs	r2, #1
 8001324:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8001328:	9b01      	ldr	r3, [sp, #4]
 800132a:	2200      	movs	r2, #0
 800132c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800132e:	9b01      	ldr	r3, [sp, #4]
 8001330:	4a12      	ldr	r2, [pc, #72]	; (800137c <_thread_init+0x8c>)
 8001332:	611a      	str	r2, [r3, #16]
 8001334:	4b11      	ldr	r3, [pc, #68]	; (800137c <_thread_init+0x8c>)
 8001336:	695a      	ldr	r2, [r3, #20]
 8001338:	9b01      	ldr	r3, [sp, #4]
 800133a:	615a      	str	r2, [r3, #20]
 800133c:	9b01      	ldr	r3, [sp, #4]
 800133e:	695b      	ldr	r3, [r3, #20]
 8001340:	9a01      	ldr	r2, [sp, #4]
 8001342:	611a      	str	r2, [r3, #16]
 8001344:	4a0d      	ldr	r2, [pc, #52]	; (800137c <_thread_init+0x8c>)
 8001346:	9b01      	ldr	r3, [sp, #4]
 8001348:	6153      	str	r3, [r2, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800134a:	9b01      	ldr	r3, [sp, #4]
 800134c:	3328      	adds	r3, #40	; 0x28
 800134e:	4618      	mov	r0, r3
 8001350:	f7ff fee6 	bl	8001120 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8001354:	9b01      	ldr	r3, [sp, #4]
 8001356:	332c      	adds	r3, #44	; 0x2c
 8001358:	4618      	mov	r0, r3
 800135a:	f7ff fef9 	bl	8001150 <queue_init.lto_priv.283>
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 800135e:	9b01      	ldr	r3, [sp, #4]
 8001360:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8001364:	9b01      	ldr	r3, [sp, #4]
 8001366:	61da      	str	r2, [r3, #28]
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->p_stats);
 8001368:	9b01      	ldr	r3, [sp, #4]
 800136a:	3348      	adds	r3, #72	; 0x48
 800136c:	4618      	mov	r0, r3
 800136e:	f000 f9ef 	bl	8001750 <chTMObjectInit>
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 8001372:	9b01      	ldr	r3, [sp, #4]
}
 8001374:	4618      	mov	r0, r3
 8001376:	b003      	add	sp, #12
 8001378:	f85d fb04 	ldr.w	pc, [sp], #4
 800137c:	20002128 	.word	0x20002128

08001380 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 8001380:	b084      	sub	sp, #16
 8001382:	9003      	str	r0, [sp, #12]
 8001384:	9102      	str	r1, [sp, #8]
 8001386:	4613      	mov	r3, r2
 8001388:	f88d 3007 	strb.w	r3, [sp, #7]
 800138c:	e005      	b.n	800139a <_thread_memfill+0x1a>

  while (startp < endp) {
    *startp++ = v;
 800138e:	9b03      	ldr	r3, [sp, #12]
 8001390:	1c5a      	adds	r2, r3, #1
 8001392:	9203      	str	r2, [sp, #12]
 8001394:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8001398:	701a      	strb	r2, [r3, #0]
  while (startp < endp) {
 800139a:	9a03      	ldr	r2, [sp, #12]
 800139c:	9b02      	ldr	r3, [sp, #8]
 800139e:	429a      	cmp	r2, r3
 80013a0:	d3f5      	bcc.n	800138e <_thread_memfill+0xe>
  }
}
 80013a2:	b004      	add	sp, #16
 80013a4:	4770      	bx	lr
 80013a6:	bf00      	nop
	...

080013b0 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 80013b0:	b500      	push	{lr}
 80013b2:	b087      	sub	sp, #28
 80013b4:	9003      	str	r0, [sp, #12]
 80013b6:	9102      	str	r1, [sp, #8]
 80013b8:	9201      	str	r2, [sp, #4]
 80013ba:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 80013bc:	9b03      	ldr	r3, [sp, #12]
 80013be:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 80013c0:	f7ff fb4e 	bl	8000a60 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
 80013c4:	9b03      	ldr	r3, [sp, #12]
 80013c6:	2b00      	cmp	r3, #0
 80013c8:	d009      	beq.n	80013de <chThdCreateI+0x2e>
 80013ca:	9b02      	ldr	r3, [sp, #8]
 80013cc:	f5b3 7fb8 	cmp.w	r3, #368	; 0x170
 80013d0:	d305      	bcc.n	80013de <chThdCreateI+0x2e>
 80013d2:	9b01      	ldr	r3, [sp, #4]
 80013d4:	2b7f      	cmp	r3, #127	; 0x7f
 80013d6:	d802      	bhi.n	80013de <chThdCreateI+0x2e>
 80013d8:	9b00      	ldr	r3, [sp, #0]
 80013da:	2b00      	cmp	r3, #0
 80013dc:	d102      	bne.n	80013e4 <chThdCreateI+0x34>
 80013de:	480f      	ldr	r0, [pc, #60]	; (800141c <chThdCreateI+0x6c>)
 80013e0:	f7ff fa16 	bl	8000810 <chSysHalt>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80013e4:	9b02      	ldr	r3, [sp, #8]
 80013e6:	3b64      	subs	r3, #100	; 0x64
 80013e8:	9a03      	ldr	r2, [sp, #12]
 80013ea:	441a      	add	r2, r3
 80013ec:	9b05      	ldr	r3, [sp, #20]
 80013ee:	60da      	str	r2, [r3, #12]
 80013f0:	9b05      	ldr	r3, [sp, #20]
 80013f2:	68db      	ldr	r3, [r3, #12]
 80013f4:	9a00      	ldr	r2, [sp, #0]
 80013f6:	641a      	str	r2, [r3, #64]	; 0x40
 80013f8:	9b05      	ldr	r3, [sp, #20]
 80013fa:	68db      	ldr	r3, [r3, #12]
 80013fc:	9a08      	ldr	r2, [sp, #32]
 80013fe:	645a      	str	r2, [r3, #68]	; 0x44
 8001400:	9b05      	ldr	r3, [sp, #20]
 8001402:	68db      	ldr	r3, [r3, #12]
 8001404:	4a06      	ldr	r2, [pc, #24]	; (8001420 <chThdCreateI+0x70>)
 8001406:	661a      	str	r2, [r3, #96]	; 0x60

  return _thread_init(tp, prio);
 8001408:	9901      	ldr	r1, [sp, #4]
 800140a:	9805      	ldr	r0, [sp, #20]
 800140c:	f7ff ff70 	bl	80012f0 <_thread_init>
 8001410:	4603      	mov	r3, r0
}
 8001412:	4618      	mov	r0, r3
 8001414:	b007      	add	sp, #28
 8001416:	f85d fb04 	ldr.w	pc, [sp], #4
 800141a:	bf00      	nop
 800141c:	0800a4e0 	.word	0x0800a4e0
 8001420:	080002e9 	.word	0x080002e9
	...

08001430 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8001430:	b500      	push	{lr}
 8001432:	b089      	sub	sp, #36	; 0x24
 8001434:	9005      	str	r0, [sp, #20]
 8001436:	9104      	str	r1, [sp, #16]
 8001438:	9203      	str	r2, [sp, #12]
 800143a:	9302      	str	r3, [sp, #8]
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 800143c:	9b05      	ldr	r3, [sp, #20]
 800143e:	3360      	adds	r3, #96	; 0x60
 8001440:	22ff      	movs	r2, #255	; 0xff
 8001442:	4619      	mov	r1, r3
 8001444:	9805      	ldr	r0, [sp, #20]
 8001446:	f7ff ff9b 	bl	8001380 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 800144a:	9b05      	ldr	r3, [sp, #20]
 800144c:	f103 0060 	add.w	r0, r3, #96	; 0x60
 8001450:	9a05      	ldr	r2, [sp, #20]
 8001452:	9b04      	ldr	r3, [sp, #16]
 8001454:	4413      	add	r3, r2
 8001456:	2255      	movs	r2, #85	; 0x55
 8001458:	4619      	mov	r1, r3
 800145a:	f7ff ff91 	bl	8001380 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800145e:	f7ff fed7 	bl	8001210 <chSysLock.lto_priv.50>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8001462:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001464:	9300      	str	r3, [sp, #0]
 8001466:	9b02      	ldr	r3, [sp, #8]
 8001468:	9a03      	ldr	r2, [sp, #12]
 800146a:	9904      	ldr	r1, [sp, #16]
 800146c:	9805      	ldr	r0, [sp, #20]
 800146e:	f7ff ff9f 	bl	80013b0 <chThdCreateI>
 8001472:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 8001474:	2100      	movs	r1, #0
 8001476:	9807      	ldr	r0, [sp, #28]
 8001478:	f7ff fd72 	bl	8000f60 <chSchWakeupS>
  chSysUnlock();
 800147c:	f7ff fed0 	bl	8001220 <chSysUnlock.lto_priv.9>

  return tp;
 8001480:	9b07      	ldr	r3, [sp, #28]
}
 8001482:	4618      	mov	r0, r3
 8001484:	b009      	add	sp, #36	; 0x24
 8001486:	f85d fb04 	ldr.w	pc, [sp], #4
 800148a:	bf00      	nop
 800148c:	0000      	movs	r0, r0
	...

08001490 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8001490:	b500      	push	{lr}
 8001492:	b083      	sub	sp, #12
 8001494:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001496:	f7ff febb 	bl	8001210 <chSysLock.lto_priv.50>
  chThdSleepS(time);
 800149a:	9801      	ldr	r0, [sp, #4]
 800149c:	f7ff fee8 	bl	8001270 <chThdSleepS>
  chSysUnlock();
 80014a0:	f7ff febe 	bl	8001220 <chSysUnlock.lto_priv.9>
}
 80014a4:	b003      	add	sp, #12
 80014a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80014aa:	bf00      	nop
 80014ac:	0000      	movs	r0, r0
	...

080014b0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80014b0:	b500      	push	{lr}
 80014b2:	b083      	sub	sp, #12
 80014b4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80014b6:	f7ff feab 	bl	8001210 <chSysLock.lto_priv.50>
  chThdExitS(msg);
 80014ba:	9801      	ldr	r0, [sp, #4]
 80014bc:	f000 f808 	bl	80014d0 <chThdExitS>
  /* The thread never returns here.*/
}
 80014c0:	b003      	add	sp, #12
 80014c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80014c6:	bf00      	nop
	...

080014d0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80014d0:	b500      	push	{lr}
 80014d2:	b085      	sub	sp, #20
 80014d4:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 80014d6:	4b19      	ldr	r3, [pc, #100]	; (800153c <chThdExitS+0x6c>)
 80014d8:	699b      	ldr	r3, [r3, #24]
 80014da:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 80014dc:	9b03      	ldr	r3, [sp, #12]
 80014de:	9a01      	ldr	r2, [sp, #4]
 80014e0:	625a      	str	r2, [r3, #36]	; 0x24
 80014e2:	e008      	b.n	80014f6 <chThdExitS+0x26>
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80014e4:	9b03      	ldr	r3, [sp, #12]
 80014e6:	3328      	adds	r3, #40	; 0x28
 80014e8:	4618      	mov	r0, r3
 80014ea:	f7ff fe51 	bl	8001190 <list_remove>
 80014ee:	4603      	mov	r3, r0
 80014f0:	4618      	mov	r0, r3
 80014f2:	f7ff fc3d 	bl	8000d70 <chSchReadyI>
  while (list_notempty(&tp->p_waiting)) {
 80014f6:	9b03      	ldr	r3, [sp, #12]
 80014f8:	3328      	adds	r3, #40	; 0x28
 80014fa:	4618      	mov	r0, r3
 80014fc:	f7ff fe18 	bl	8001130 <list_notempty>
 8001500:	4603      	mov	r3, r0
 8001502:	2b00      	cmp	r3, #0
 8001504:	d1ee      	bne.n	80014e4 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8001506:	9b03      	ldr	r3, [sp, #12]
 8001508:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800150c:	f003 0303 	and.w	r3, r3, #3
 8001510:	2b00      	cmp	r3, #0
 8001512:	d109      	bne.n	8001528 <chThdExitS+0x58>
    REG_REMOVE(tp);
 8001514:	9b03      	ldr	r3, [sp, #12]
 8001516:	695b      	ldr	r3, [r3, #20]
 8001518:	9a03      	ldr	r2, [sp, #12]
 800151a:	6912      	ldr	r2, [r2, #16]
 800151c:	611a      	str	r2, [r3, #16]
 800151e:	9b03      	ldr	r3, [sp, #12]
 8001520:	691b      	ldr	r3, [r3, #16]
 8001522:	9a03      	ldr	r2, [sp, #12]
 8001524:	6952      	ldr	r2, [r2, #20]
 8001526:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001528:	200f      	movs	r0, #15
 800152a:	f7ff fc61 	bl	8000df0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800152e:	4804      	ldr	r0, [pc, #16]	; (8001540 <chThdExitS+0x70>)
 8001530:	f7ff f96e 	bl	8000810 <chSysHalt>
}
 8001534:	b005      	add	sp, #20
 8001536:	f85d fb04 	ldr.w	pc, [sp], #4
 800153a:	bf00      	nop
 800153c:	20002128 	.word	0x20002128
 8001540:	0800a510 	.word	0x0800a510
	...

08001550 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 8001550:	b500      	push	{lr}
 8001552:	b085      	sub	sp, #20
 8001554:	9001      	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
 8001556:	f7ff fe83 	bl	8001260 <chThdGetSelfX.lto_priv.323>
 800155a:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 800155c:	9b01      	ldr	r3, [sp, #4]
 800155e:	681b      	ldr	r3, [r3, #0]
 8001560:	2b00      	cmp	r3, #0
 8001562:	d002      	beq.n	800156a <chThdSuspendS+0x1a>
 8001564:	4809      	ldr	r0, [pc, #36]	; (800158c <chThdSuspendS+0x3c>)
 8001566:	f7ff f953 	bl	8000810 <chSysHalt>

  *trp = tp;
 800156a:	9b01      	ldr	r3, [sp, #4]
 800156c:	9a03      	ldr	r2, [sp, #12]
 800156e:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 8001570:	9b03      	ldr	r3, [sp, #12]
 8001572:	9a01      	ldr	r2, [sp, #4]
 8001574:	625a      	str	r2, [r3, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8001576:	2003      	movs	r0, #3
 8001578:	f7ff fc3a 	bl	8000df0 <chSchGoSleepS>

  return chThdGetSelfX()->p_u.rdymsg;
 800157c:	f7ff fe70 	bl	8001260 <chThdGetSelfX.lto_priv.323>
 8001580:	4603      	mov	r3, r0
 8001582:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8001584:	4618      	mov	r0, r3
 8001586:	b005      	add	sp, #20
 8001588:	f85d fb04 	ldr.w	pc, [sp], #4
 800158c:	0800a520 	.word	0x0800a520

08001590 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8001590:	b500      	push	{lr}
 8001592:	b085      	sub	sp, #20
 8001594:	9001      	str	r0, [sp, #4]
 8001596:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 8001598:	9b01      	ldr	r3, [sp, #4]
 800159a:	681b      	ldr	r3, [r3, #0]
 800159c:	2b00      	cmp	r3, #0
 800159e:	d013      	beq.n	80015c8 <chThdResumeI+0x38>
    thread_t *tp = *trp;
 80015a0:	9b01      	ldr	r3, [sp, #4]
 80015a2:	681b      	ldr	r3, [r3, #0]
 80015a4:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
 80015a6:	9b03      	ldr	r3, [sp, #12]
 80015a8:	f893 3020 	ldrb.w	r3, [r3, #32]
 80015ac:	2b03      	cmp	r3, #3
 80015ae:	d002      	beq.n	80015b6 <chThdResumeI+0x26>
 80015b0:	4807      	ldr	r0, [pc, #28]	; (80015d0 <chThdResumeI+0x40>)
 80015b2:	f7ff f92d 	bl	8000810 <chSysHalt>
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 80015b6:	9b01      	ldr	r3, [sp, #4]
 80015b8:	2200      	movs	r2, #0
 80015ba:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
 80015bc:	9b03      	ldr	r3, [sp, #12]
 80015be:	9a00      	ldr	r2, [sp, #0]
 80015c0:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 80015c2:	9803      	ldr	r0, [sp, #12]
 80015c4:	f7ff fbd4 	bl	8000d70 <chSchReadyI>
  }
}
 80015c8:	b005      	add	sp, #20
 80015ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80015ce:	bf00      	nop
 80015d0:	0800a530 	.word	0x0800a530
	...

080015e0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80015e0:	b500      	push	{lr}
 80015e2:	b083      	sub	sp, #12
 80015e4:	9001      	str	r0, [sp, #4]
 80015e6:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 80015e8:	9b00      	ldr	r3, [sp, #0]
 80015ea:	2b00      	cmp	r3, #0
 80015ec:	d102      	bne.n	80015f4 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 80015ee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80015f2:	e00a      	b.n	800160a <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
 80015f4:	4b07      	ldr	r3, [pc, #28]	; (8001614 <chThdEnqueueTimeoutS+0x34>)
 80015f6:	699b      	ldr	r3, [r3, #24]
 80015f8:	9901      	ldr	r1, [sp, #4]
 80015fa:	4618      	mov	r0, r3
 80015fc:	f7ff fdd8 	bl	80011b0 <queue_insert.lto_priv.315>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001600:	9900      	ldr	r1, [sp, #0]
 8001602:	2004      	movs	r0, #4
 8001604:	f7ff fc74 	bl	8000ef0 <chSchGoSleepTimeoutS>
 8001608:	4603      	mov	r3, r0
}
 800160a:	4618      	mov	r0, r3
 800160c:	b003      	add	sp, #12
 800160e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001612:	bf00      	nop
 8001614:	20002128 	.word	0x20002128
	...

08001620 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001620:	b500      	push	{lr}
 8001622:	b083      	sub	sp, #12
 8001624:	9001      	str	r0, [sp, #4]
 8001626:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8001628:	9801      	ldr	r0, [sp, #4]
 800162a:	f7ff fda1 	bl	8001170 <queue_notempty.lto_priv.327>
 800162e:	4603      	mov	r3, r0
 8001630:	2b00      	cmp	r3, #0
 8001632:	d003      	beq.n	800163c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 8001634:	9900      	ldr	r1, [sp, #0]
 8001636:	9801      	ldr	r0, [sp, #4]
 8001638:	f7ff fe32 	bl	80012a0 <chThdDoDequeueNextI>
  }
}
 800163c:	b003      	add	sp, #12
 800163e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001642:	bf00      	nop
	...

08001650 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001650:	b500      	push	{lr}
 8001652:	b083      	sub	sp, #12
 8001654:	9001      	str	r0, [sp, #4]
 8001656:	9100      	str	r1, [sp, #0]
 8001658:	e003      	b.n	8001662 <chThdDequeueAllI+0x12>

  while (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
 800165a:	9900      	ldr	r1, [sp, #0]
 800165c:	9801      	ldr	r0, [sp, #4]
 800165e:	f7ff fe1f 	bl	80012a0 <chThdDoDequeueNextI>
  while (queue_notempty(tqp)) {
 8001662:	9801      	ldr	r0, [sp, #4]
 8001664:	f7ff fd84 	bl	8001170 <queue_notempty.lto_priv.327>
 8001668:	4603      	mov	r3, r0
 800166a:	2b00      	cmp	r3, #0
 800166c:	d1f5      	bne.n	800165a <chThdDequeueAllI+0xa>
  }
}
 800166e:	b003      	add	sp, #12
 8001670:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001680 <port_rt_get_counter_value.lto_priv.336>:
  return DWT->CYCCNT;
 8001680:	4b01      	ldr	r3, [pc, #4]	; (8001688 <port_rt_get_counter_value.lto_priv.336+0x8>)
 8001682:	685b      	ldr	r3, [r3, #4]
}
 8001684:	4618      	mov	r0, r3
 8001686:	4770      	bx	lr
 8001688:	e0001000 	.word	0xe0001000
 800168c:	00000000 	.word	0x00000000

08001690 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8001690:	e92d 0810 	stmdb	sp!, {r4, fp}
 8001694:	b084      	sub	sp, #16
 8001696:	9003      	str	r0, [sp, #12]
 8001698:	9102      	str	r1, [sp, #8]
 800169a:	9201      	str	r2, [sp, #4]

  tmp->n++;
 800169c:	9b03      	ldr	r3, [sp, #12]
 800169e:	68db      	ldr	r3, [r3, #12]
 80016a0:	1c5a      	adds	r2, r3, #1
 80016a2:	9b03      	ldr	r3, [sp, #12]
 80016a4:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 80016a6:	9b03      	ldr	r3, [sp, #12]
 80016a8:	689b      	ldr	r3, [r3, #8]
 80016aa:	9a02      	ldr	r2, [sp, #8]
 80016ac:	1ad2      	subs	r2, r2, r3
 80016ae:	9b01      	ldr	r3, [sp, #4]
 80016b0:	1ad2      	subs	r2, r2, r3
 80016b2:	9b03      	ldr	r3, [sp, #12]
 80016b4:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80016b6:	9b03      	ldr	r3, [sp, #12]
 80016b8:	e9d3 1204 	ldrd	r1, r2, [r3, #16]
 80016bc:	9b03      	ldr	r3, [sp, #12]
 80016be:	689b      	ldr	r3, [r3, #8]
 80016c0:	469b      	mov	fp, r3
 80016c2:	f04f 0c00 	mov.w	ip, #0
 80016c6:	eb1b 0301 	adds.w	r3, fp, r1
 80016ca:	eb4c 0402 	adc.w	r4, ip, r2
 80016ce:	9a03      	ldr	r2, [sp, #12]
 80016d0:	e9c2 3404 	strd	r3, r4, [r2, #16]
  if (tmp->last > tmp->worst) {
 80016d4:	9b03      	ldr	r3, [sp, #12]
 80016d6:	689a      	ldr	r2, [r3, #8]
 80016d8:	9b03      	ldr	r3, [sp, #12]
 80016da:	685b      	ldr	r3, [r3, #4]
 80016dc:	429a      	cmp	r2, r3
 80016de:	d903      	bls.n	80016e8 <tm_stop+0x58>
    tmp->worst = tmp->last;
 80016e0:	9b03      	ldr	r3, [sp, #12]
 80016e2:	689a      	ldr	r2, [r3, #8]
 80016e4:	9b03      	ldr	r3, [sp, #12]
 80016e6:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 80016e8:	9b03      	ldr	r3, [sp, #12]
 80016ea:	689a      	ldr	r2, [r3, #8]
 80016ec:	9b03      	ldr	r3, [sp, #12]
 80016ee:	681b      	ldr	r3, [r3, #0]
 80016f0:	429a      	cmp	r2, r3
 80016f2:	d203      	bcs.n	80016fc <tm_stop+0x6c>
    tmp->best = tmp->last;
 80016f4:	9b03      	ldr	r3, [sp, #12]
 80016f6:	689a      	ldr	r2, [r3, #8]
 80016f8:	9b03      	ldr	r3, [sp, #12]
 80016fa:	601a      	str	r2, [r3, #0]
  }
}
 80016fc:	b004      	add	sp, #16
 80016fe:	e8bd 0810 	ldmia.w	sp!, {r4, fp}
 8001702:	4770      	bx	lr
	...

08001710 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001710:	b500      	push	{lr}
 8001712:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001714:	4b0b      	ldr	r3, [pc, #44]	; (8001744 <_tm_init+0x34>)
 8001716:	2200      	movs	r2, #0
 8001718:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  chTMObjectInit(&tm);
 800171c:	466b      	mov	r3, sp
 800171e:	4618      	mov	r0, r3
 8001720:	f000 f816 	bl	8001750 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8001724:	466b      	mov	r3, sp
 8001726:	4618      	mov	r0, r3
 8001728:	f000 f832 	bl	8001790 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800172c:	466b      	mov	r3, sp
 800172e:	4618      	mov	r0, r3
 8001730:	f000 f83e 	bl	80017b0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8001734:	9b02      	ldr	r3, [sp, #8]
 8001736:	4a03      	ldr	r2, [pc, #12]	; (8001744 <_tm_init+0x34>)
 8001738:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
}
 800173c:	b007      	add	sp, #28
 800173e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001742:	bf00      	nop
 8001744:	20002128 	.word	0x20002128
	...

08001750 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8001750:	b410      	push	{r4}
 8001752:	b083      	sub	sp, #12
 8001754:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 8001756:	9b01      	ldr	r3, [sp, #4]
 8001758:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800175c:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 800175e:	9b01      	ldr	r3, [sp, #4]
 8001760:	2200      	movs	r2, #0
 8001762:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8001764:	9b01      	ldr	r3, [sp, #4]
 8001766:	2200      	movs	r2, #0
 8001768:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 800176a:	9b01      	ldr	r3, [sp, #4]
 800176c:	2200      	movs	r2, #0
 800176e:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 8001770:	9a01      	ldr	r2, [sp, #4]
 8001772:	f04f 0300 	mov.w	r3, #0
 8001776:	f04f 0400 	mov.w	r4, #0
 800177a:	e9c2 3404 	strd	r3, r4, [r2, #16]
}
 800177e:	b003      	add	sp, #12
 8001780:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001784:	4770      	bx	lr
 8001786:	bf00      	nop
	...

08001790 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8001790:	b500      	push	{lr}
 8001792:	b083      	sub	sp, #12
 8001794:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8001796:	f7ff ff73 	bl	8001680 <port_rt_get_counter_value.lto_priv.336>
 800179a:	4602      	mov	r2, r0
 800179c:	9b01      	ldr	r3, [sp, #4]
 800179e:	609a      	str	r2, [r3, #8]
}
 80017a0:	b003      	add	sp, #12
 80017a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80017a6:	bf00      	nop
	...

080017b0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80017b0:	b500      	push	{lr}
 80017b2:	b083      	sub	sp, #12
 80017b4:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80017b6:	f7ff ff63 	bl	8001680 <port_rt_get_counter_value.lto_priv.336>
 80017ba:	4601      	mov	r1, r0
 80017bc:	4b04      	ldr	r3, [pc, #16]	; (80017d0 <chTMStopMeasurementX+0x20>)
 80017be:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 80017c2:	461a      	mov	r2, r3
 80017c4:	9801      	ldr	r0, [sp, #4]
 80017c6:	f7ff ff63 	bl	8001690 <tm_stop>
}
 80017ca:	b003      	add	sp, #12
 80017cc:	f85d fb04 	ldr.w	pc, [sp], #4
 80017d0:	20002128 	.word	0x20002128
	...

080017e0 <chTMChainMeasurementToX>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
 80017e0:	b500      	push	{lr}
 80017e2:	b083      	sub	sp, #12
 80017e4:	9001      	str	r0, [sp, #4]
 80017e6:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
 80017e8:	f7ff ff4a 	bl	8001680 <port_rt_get_counter_value.lto_priv.336>
 80017ec:	4602      	mov	r2, r0
 80017ee:	9b00      	ldr	r3, [sp, #0]
 80017f0:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
 80017f2:	9b00      	ldr	r3, [sp, #0]
 80017f4:	689b      	ldr	r3, [r3, #8]
 80017f6:	2200      	movs	r2, #0
 80017f8:	4619      	mov	r1, r3
 80017fa:	9801      	ldr	r0, [sp, #4]
 80017fc:	f7ff ff48 	bl	8001690 <tm_stop>
}
 8001800:	b003      	add	sp, #12
 8001802:	f85d fb04 	ldr.w	pc, [sp], #4
 8001806:	bf00      	nop
	...

08001810 <port_lock.lto_priv.106>:
static inline void port_lock(void) {
 8001810:	b082      	sub	sp, #8
 8001812:	2320      	movs	r3, #32
 8001814:	9301      	str	r3, [sp, #4]
 8001816:	9b01      	ldr	r3, [sp, #4]
 8001818:	f383 8811 	msr	BASEPRI, r3
}
 800181c:	b002      	add	sp, #8
 800181e:	4770      	bx	lr

08001820 <port_unlock.lto_priv.76>:
static inline void port_unlock(void) {
 8001820:	b082      	sub	sp, #8
 8001822:	2300      	movs	r3, #0
 8001824:	9301      	str	r3, [sp, #4]
 8001826:	9b01      	ldr	r3, [sp, #4]
 8001828:	f383 8811 	msr	BASEPRI, r3
}
 800182c:	b002      	add	sp, #8
 800182e:	4770      	bx	lr

08001830 <port_lock_from_isr.lto_priv.184>:
static inline void port_lock_from_isr(void) {
 8001830:	b508      	push	{r3, lr}
  port_lock();
 8001832:	f7ff ffed 	bl	8001810 <port_lock.lto_priv.106>
}
 8001836:	bd08      	pop	{r3, pc}
	...

08001840 <port_unlock_from_isr.lto_priv.171>:
static inline void port_unlock_from_isr(void) {
 8001840:	b508      	push	{r3, lr}
  port_unlock();
 8001842:	f7ff ffed 	bl	8001820 <port_unlock.lto_priv.76>
}
 8001846:	bd08      	pop	{r3, pc}
	...

08001850 <_stats_init>:
/**
 * @brief   Initializes the statistics module.
 *
 * @init
 */
void _stats_init(void) {
 8001850:	b508      	push	{r3, lr}

  ch.kernel_stats.n_irq = (ucnt_t)0;
 8001852:	4b07      	ldr	r3, [pc, #28]	; (8001870 <_stats_init+0x20>)
 8001854:	2200      	movs	r2, #0
 8001856:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
 800185a:	4b05      	ldr	r3, [pc, #20]	; (8001870 <_stats_init+0x20>)
 800185c:	2200      	movs	r2, #0
 800185e:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
 8001862:	4804      	ldr	r0, [pc, #16]	; (8001874 <_stats_init+0x24>)
 8001864:	f7ff ff74 	bl	8001750 <chTMObjectInit>
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
 8001868:	4803      	ldr	r0, [pc, #12]	; (8001878 <_stats_init+0x28>)
 800186a:	f7ff ff71 	bl	8001750 <chTMObjectInit>
}
 800186e:	bd08      	pop	{r3, pc}
 8001870:	20002128 	.word	0x20002128
 8001874:	200021d0 	.word	0x200021d0
 8001878:	200021e8 	.word	0x200021e8
 800187c:	00000000 	.word	0x00000000

08001880 <_stats_increase_irq>:

/**
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {
 8001880:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8001882:	f7ff ffd5 	bl	8001830 <port_lock_from_isr.lto_priv.184>
  ch.kernel_stats.n_irq++;
 8001886:	4b05      	ldr	r3, [pc, #20]	; (800189c <_stats_increase_irq+0x1c>)
 8001888:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800188c:	3301      	adds	r3, #1
 800188e:	4a03      	ldr	r2, [pc, #12]	; (800189c <_stats_increase_irq+0x1c>)
 8001890:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
  port_unlock_from_isr();
 8001894:	f7ff ffd4 	bl	8001840 <port_unlock_from_isr.lto_priv.171>
}
 8001898:	bd08      	pop	{r3, pc}
 800189a:	bf00      	nop
 800189c:	20002128 	.word	0x20002128

080018a0 <_stats_ctxswc>:
 * @brief   Updates context switch related statistics.
 *
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {
 80018a0:	b500      	push	{lr}
 80018a2:	b083      	sub	sp, #12
 80018a4:	9001      	str	r0, [sp, #4]
 80018a6:	9100      	str	r1, [sp, #0]

  ch.kernel_stats.n_ctxswc++;
 80018a8:	4b09      	ldr	r3, [pc, #36]	; (80018d0 <_stats_ctxswc+0x30>)
 80018aa:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 80018ae:	3301      	adds	r3, #1
 80018b0:	4a07      	ldr	r2, [pc, #28]	; (80018d0 <_stats_ctxswc+0x30>)
 80018b2:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 80018b6:	9b00      	ldr	r3, [sp, #0]
 80018b8:	f103 0248 	add.w	r2, r3, #72	; 0x48
 80018bc:	9b01      	ldr	r3, [sp, #4]
 80018be:	3348      	adds	r3, #72	; 0x48
 80018c0:	4619      	mov	r1, r3
 80018c2:	4610      	mov	r0, r2
 80018c4:	f7ff ff8c 	bl	80017e0 <chTMChainMeasurementToX>
}
 80018c8:	b003      	add	sp, #12
 80018ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80018ce:	bf00      	nop
 80018d0:	20002128 	.word	0x20002128
	...

080018e0 <_stats_start_measure_crit_thd>:

/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {
 80018e0:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
 80018e2:	4802      	ldr	r0, [pc, #8]	; (80018ec <_stats_start_measure_crit_thd+0xc>)
 80018e4:	f7ff ff54 	bl	8001790 <chTMStartMeasurementX>
}
 80018e8:	bd08      	pop	{r3, pc}
 80018ea:	bf00      	nop
 80018ec:	200021d0 	.word	0x200021d0

080018f0 <_stats_stop_measure_crit_thd>:

/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {
 80018f0:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
 80018f2:	4802      	ldr	r0, [pc, #8]	; (80018fc <_stats_stop_measure_crit_thd+0xc>)
 80018f4:	f7ff ff5c 	bl	80017b0 <chTMStopMeasurementX>
}
 80018f8:	bd08      	pop	{r3, pc}
 80018fa:	bf00      	nop
 80018fc:	200021d0 	.word	0x200021d0

08001900 <_stats_start_measure_crit_isr>:

/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {
 8001900:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
 8001902:	4802      	ldr	r0, [pc, #8]	; (800190c <_stats_start_measure_crit_isr+0xc>)
 8001904:	f7ff ff44 	bl	8001790 <chTMStartMeasurementX>
}
 8001908:	bd08      	pop	{r3, pc}
 800190a:	bf00      	nop
 800190c:	200021e8 	.word	0x200021e8

08001910 <_stats_stop_measure_crit_isr>:

/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {
 8001910:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
 8001912:	4802      	ldr	r0, [pc, #8]	; (800191c <_stats_stop_measure_crit_isr+0xc>)
 8001914:	f7ff ff4c 	bl	80017b0 <chTMStopMeasurementX>
}
 8001918:	bd08      	pop	{r3, pc}
 800191a:	bf00      	nop
 800191c:	200021e8 	.word	0x200021e8

08001920 <port_lock.lto_priv.110>:
static inline void port_lock(void) {
 8001920:	b082      	sub	sp, #8
 8001922:	2320      	movs	r3, #32
 8001924:	9301      	str	r3, [sp, #4]
 8001926:	9b01      	ldr	r3, [sp, #4]
 8001928:	f383 8811 	msr	BASEPRI, r3
}
 800192c:	b002      	add	sp, #8
 800192e:	4770      	bx	lr

08001930 <port_unlock.lto_priv.80>:
static inline void port_unlock(void) {
 8001930:	b082      	sub	sp, #8
 8001932:	2300      	movs	r3, #0
 8001934:	9301      	str	r3, [sp, #4]
 8001936:	9b01      	ldr	r3, [sp, #4]
 8001938:	f383 8811 	msr	BASEPRI, r3
}
 800193c:	b002      	add	sp, #8
 800193e:	4770      	bx	lr

08001940 <queue_init.lto_priv.285>:
static inline void queue_init(threads_queue_t *tqp) {
 8001940:	b082      	sub	sp, #8
 8001942:	9001      	str	r0, [sp, #4]
  tqp->p_next = (thread_t *)tqp;
 8001944:	9b01      	ldr	r3, [sp, #4]
 8001946:	9a01      	ldr	r2, [sp, #4]
 8001948:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800194a:	9b01      	ldr	r3, [sp, #4]
 800194c:	9a01      	ldr	r2, [sp, #4]
 800194e:	605a      	str	r2, [r3, #4]
}
 8001950:	b002      	add	sp, #8
 8001952:	4770      	bx	lr
	...

08001960 <queue_notempty.lto_priv.329>:
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8001960:	b082      	sub	sp, #8
 8001962:	9001      	str	r0, [sp, #4]
  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001964:	9b01      	ldr	r3, [sp, #4]
 8001966:	681b      	ldr	r3, [r3, #0]
 8001968:	9a01      	ldr	r2, [sp, #4]
 800196a:	429a      	cmp	r2, r3
 800196c:	bf14      	ite	ne
 800196e:	2301      	movne	r3, #1
 8001970:	2300      	moveq	r3, #0
 8001972:	b2db      	uxtb	r3, r3
}
 8001974:	4618      	mov	r0, r3
 8001976:	b002      	add	sp, #8
 8001978:	4770      	bx	lr
 800197a:	bf00      	nop
 800197c:	0000      	movs	r0, r0
	...

08001980 <queue_prio_insert.lto_priv.325>:
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8001980:	b084      	sub	sp, #16
 8001982:	9001      	str	r0, [sp, #4]
 8001984:	9100      	str	r1, [sp, #0]
  thread_t *cp = (thread_t *)tqp;
 8001986:	9b00      	ldr	r3, [sp, #0]
 8001988:	9303      	str	r3, [sp, #12]
    cp = cp->p_next;
 800198a:	9b03      	ldr	r3, [sp, #12]
 800198c:	681b      	ldr	r3, [r3, #0]
 800198e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001990:	9a03      	ldr	r2, [sp, #12]
 8001992:	9b00      	ldr	r3, [sp, #0]
 8001994:	429a      	cmp	r2, r3
 8001996:	d005      	beq.n	80019a4 <queue_prio_insert.lto_priv.325+0x24>
 8001998:	9b03      	ldr	r3, [sp, #12]
 800199a:	689a      	ldr	r2, [r3, #8]
 800199c:	9b01      	ldr	r3, [sp, #4]
 800199e:	689b      	ldr	r3, [r3, #8]
 80019a0:	429a      	cmp	r2, r3
 80019a2:	d2f2      	bcs.n	800198a <queue_prio_insert.lto_priv.325+0xa>
  tp->p_next = cp;
 80019a4:	9b01      	ldr	r3, [sp, #4]
 80019a6:	9a03      	ldr	r2, [sp, #12]
 80019a8:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 80019aa:	9b03      	ldr	r3, [sp, #12]
 80019ac:	685a      	ldr	r2, [r3, #4]
 80019ae:	9b01      	ldr	r3, [sp, #4]
 80019b0:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80019b2:	9b01      	ldr	r3, [sp, #4]
 80019b4:	685b      	ldr	r3, [r3, #4]
 80019b6:	9a01      	ldr	r2, [sp, #4]
 80019b8:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 80019ba:	9b03      	ldr	r3, [sp, #12]
 80019bc:	9a01      	ldr	r2, [sp, #4]
 80019be:	605a      	str	r2, [r3, #4]
}
 80019c0:	b004      	add	sp, #16
 80019c2:	4770      	bx	lr
	...

080019d0 <queue_fifo_remove.lto_priv.312>:
static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80019d0:	b084      	sub	sp, #16
 80019d2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 80019d4:	9b01      	ldr	r3, [sp, #4]
 80019d6:	681b      	ldr	r3, [r3, #0]
 80019d8:	9303      	str	r3, [sp, #12]
  tqp->p_next = tp->p_next;
 80019da:	9b03      	ldr	r3, [sp, #12]
 80019dc:	681a      	ldr	r2, [r3, #0]
 80019de:	9b01      	ldr	r3, [sp, #4]
 80019e0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80019e2:	9b01      	ldr	r3, [sp, #4]
 80019e4:	681b      	ldr	r3, [r3, #0]
 80019e6:	9a01      	ldr	r2, [sp, #4]
 80019e8:	605a      	str	r2, [r3, #4]
  return tp;
 80019ea:	9b03      	ldr	r3, [sp, #12]
}
 80019ec:	4618      	mov	r0, r3
 80019ee:	b004      	add	sp, #16
 80019f0:	4770      	bx	lr
 80019f2:	bf00      	nop
	...

08001a00 <queue_dequeue.lto_priv.332>:
static inline thread_t *queue_dequeue(thread_t *tp) {
 8001a00:	b082      	sub	sp, #8
 8001a02:	9001      	str	r0, [sp, #4]
  tp->p_prev->p_next = tp->p_next;
 8001a04:	9b01      	ldr	r3, [sp, #4]
 8001a06:	685b      	ldr	r3, [r3, #4]
 8001a08:	9a01      	ldr	r2, [sp, #4]
 8001a0a:	6812      	ldr	r2, [r2, #0]
 8001a0c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001a0e:	9b01      	ldr	r3, [sp, #4]
 8001a10:	681b      	ldr	r3, [r3, #0]
 8001a12:	9a01      	ldr	r2, [sp, #4]
 8001a14:	6852      	ldr	r2, [r2, #4]
 8001a16:	605a      	str	r2, [r3, #4]
  return tp;
 8001a18:	9b01      	ldr	r3, [sp, #4]
}
 8001a1a:	4618      	mov	r0, r3
 8001a1c:	b002      	add	sp, #8
 8001a1e:	4770      	bx	lr

08001a20 <chSysLock.lto_priv.54>:
static inline void chSysLock(void) {
 8001a20:	b508      	push	{r3, lr}
  port_lock();
 8001a22:	f7ff ff7d 	bl	8001920 <port_lock.lto_priv.110>
  _stats_start_measure_crit_thd();
 8001a26:	f7ff ff5b 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8001a2a:	f7fe ff79 	bl	8000920 <_dbg_check_lock>
}
 8001a2e:	bd08      	pop	{r3, pc}

08001a30 <chSysUnlock.lto_priv.13>:
static inline void chSysUnlock(void) {
 8001a30:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8001a32:	f7fe ff8d 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001a36:	f7ff ff5b 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001a3a:	4b09      	ldr	r3, [pc, #36]	; (8001a60 <chSysUnlock.lto_priv.13+0x30>)
 8001a3c:	681b      	ldr	r3, [r3, #0]
 8001a3e:	4a08      	ldr	r2, [pc, #32]	; (8001a60 <chSysUnlock.lto_priv.13+0x30>)
 8001a40:	4293      	cmp	r3, r2
 8001a42:	d00a      	beq.n	8001a5a <chSysUnlock.lto_priv.13+0x2a>
 8001a44:	4b06      	ldr	r3, [pc, #24]	; (8001a60 <chSysUnlock.lto_priv.13+0x30>)
 8001a46:	699b      	ldr	r3, [r3, #24]
 8001a48:	689a      	ldr	r2, [r3, #8]
 8001a4a:	4b05      	ldr	r3, [pc, #20]	; (8001a60 <chSysUnlock.lto_priv.13+0x30>)
 8001a4c:	681b      	ldr	r3, [r3, #0]
 8001a4e:	689b      	ldr	r3, [r3, #8]
 8001a50:	429a      	cmp	r2, r3
 8001a52:	d202      	bcs.n	8001a5a <chSysUnlock.lto_priv.13+0x2a>
 8001a54:	4803      	ldr	r0, [pc, #12]	; (8001a64 <chSysUnlock.lto_priv.13+0x34>)
 8001a56:	f7fe fedb 	bl	8000810 <chSysHalt>
  port_unlock();
 8001a5a:	f7ff ff69 	bl	8001930 <port_unlock.lto_priv.80>
}
 8001a5e:	bd08      	pop	{r3, pc}
 8001a60:	20002128 	.word	0x20002128
 8001a64:	0800a590 	.word	0x0800a590
	...

08001a70 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8001a70:	b500      	push	{lr}
 8001a72:	b083      	sub	sp, #12
 8001a74:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 8001a76:	f7ff f80b 	bl	8000a90 <chDbgCheckClassS>

  return queue_notempty(&mp->m_queue);
 8001a7a:	9b01      	ldr	r3, [sp, #4]
 8001a7c:	4618      	mov	r0, r3
 8001a7e:	f7ff ff6f 	bl	8001960 <queue_notempty.lto_priv.329>
 8001a82:	4603      	mov	r3, r0
}
 8001a84:	4618      	mov	r0, r3
 8001a86:	b003      	add	sp, #12
 8001a88:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a8c:	0000      	movs	r0, r0
	...

08001a90 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8001a90:	b500      	push	{lr}
 8001a92:	b083      	sub	sp, #12
 8001a94:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8001a96:	9b01      	ldr	r3, [sp, #4]
 8001a98:	2b00      	cmp	r3, #0
 8001a9a:	d102      	bne.n	8001aa2 <chMtxObjectInit+0x12>
 8001a9c:	4806      	ldr	r0, [pc, #24]	; (8001ab8 <chMtxObjectInit+0x28>)
 8001a9e:	f7fe feb7 	bl	8000810 <chSysHalt>

  queue_init(&mp->m_queue);
 8001aa2:	9b01      	ldr	r3, [sp, #4]
 8001aa4:	4618      	mov	r0, r3
 8001aa6:	f7ff ff4b 	bl	8001940 <queue_init.lto_priv.285>
  mp->m_owner = NULL;
 8001aaa:	9b01      	ldr	r3, [sp, #4]
 8001aac:	2200      	movs	r2, #0
 8001aae:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 8001ab0:	b003      	add	sp, #12
 8001ab2:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ab6:	bf00      	nop
 8001ab8:	0800a580 	.word	0x0800a580
 8001abc:	00000000 	.word	0x00000000

08001ac0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8001ac0:	b500      	push	{lr}
 8001ac2:	b083      	sub	sp, #12
 8001ac4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001ac6:	f7ff ffab 	bl	8001a20 <chSysLock.lto_priv.54>
  chMtxLockS(mp);
 8001aca:	9801      	ldr	r0, [sp, #4]
 8001acc:	f000 f808 	bl	8001ae0 <chMtxLockS>
  chSysUnlock();
 8001ad0:	f7ff ffae 	bl	8001a30 <chSysUnlock.lto_priv.13>
}
 8001ad4:	b003      	add	sp, #12
 8001ad6:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ada:	bf00      	nop
 8001adc:	0000      	movs	r0, r0
	...

08001ae0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001ae0:	b500      	push	{lr}
 8001ae2:	b085      	sub	sp, #20
 8001ae4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8001ae6:	4b3b      	ldr	r3, [pc, #236]	; (8001bd4 <chMtxLockS+0xf4>)
 8001ae8:	699b      	ldr	r3, [r3, #24]
 8001aea:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 8001aec:	f7fe ffd0 	bl	8000a90 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8001af0:	9b01      	ldr	r3, [sp, #4]
 8001af2:	2b00      	cmp	r3, #0
 8001af4:	d102      	bne.n	8001afc <chMtxLockS+0x1c>
 8001af6:	4838      	ldr	r0, [pc, #224]	; (8001bd8 <chMtxLockS+0xf8>)
 8001af8:	f7fe fe8a 	bl	8000810 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8001afc:	9b01      	ldr	r3, [sp, #4]
 8001afe:	689b      	ldr	r3, [r3, #8]
 8001b00:	2b00      	cmp	r3, #0
 8001b02:	d059      	beq.n	8001bb8 <chMtxLockS+0xd8>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;
 8001b04:	9b01      	ldr	r3, [sp, #4]
 8001b06:	689b      	ldr	r3, [r3, #8]
 8001b08:	9303      	str	r3, [sp, #12]
 8001b0a:	e033      	b.n	8001b74 <chMtxLockS+0x94>

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8001b0c:	9b02      	ldr	r3, [sp, #8]
 8001b0e:	689a      	ldr	r2, [r3, #8]
 8001b10:	9b03      	ldr	r3, [sp, #12]
 8001b12:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8001b14:	9b03      	ldr	r3, [sp, #12]
 8001b16:	f893 3020 	ldrb.w	r3, [r3, #32]
 8001b1a:	2b06      	cmp	r3, #6
 8001b1c:	d004      	beq.n	8001b28 <chMtxLockS+0x48>
 8001b1e:	2b07      	cmp	r3, #7
 8001b20:	d011      	beq.n	8001b46 <chMtxLockS+0x66>
 8001b22:	2b00      	cmp	r3, #0
 8001b24:	d01a      	beq.n	8001b5c <chMtxLockS+0x7c>
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
          break;
        default:
 8001b26:	e02b      	b.n	8001b80 <chMtxLockS+0xa0>
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001b28:	9803      	ldr	r0, [sp, #12]
 8001b2a:	f7ff ff69 	bl	8001a00 <queue_dequeue.lto_priv.332>
 8001b2e:	4602      	mov	r2, r0
 8001b30:	9b03      	ldr	r3, [sp, #12]
 8001b32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001b34:	4619      	mov	r1, r3
 8001b36:	4610      	mov	r0, r2
 8001b38:	f7ff ff22 	bl	8001980 <queue_prio_insert.lto_priv.325>
          tp = tp->p_u.wtmtxp->m_owner;
 8001b3c:	9b03      	ldr	r3, [sp, #12]
 8001b3e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001b40:	689b      	ldr	r3, [r3, #8]
 8001b42:	9303      	str	r3, [sp, #12]
 8001b44:	e016      	b.n	8001b74 <chMtxLockS+0x94>
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001b46:	9803      	ldr	r0, [sp, #12]
 8001b48:	f7ff ff5a 	bl	8001a00 <queue_dequeue.lto_priv.332>
 8001b4c:	4602      	mov	r2, r0
 8001b4e:	9b03      	ldr	r3, [sp, #12]
 8001b50:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001b52:	4619      	mov	r1, r3
 8001b54:	4610      	mov	r0, r2
 8001b56:	f7ff ff13 	bl	8001980 <queue_prio_insert.lto_priv.325>
        default:
 8001b5a:	e011      	b.n	8001b80 <chMtxLockS+0xa0>
          tp->p_state = CH_STATE_CURRENT;
 8001b5c:	9b03      	ldr	r3, [sp, #12]
 8001b5e:	2201      	movs	r2, #1
 8001b60:	f883 2020 	strb.w	r2, [r3, #32]
          (void) chSchReadyI(queue_dequeue(tp));
 8001b64:	9803      	ldr	r0, [sp, #12]
 8001b66:	f7ff ff4b 	bl	8001a00 <queue_dequeue.lto_priv.332>
 8001b6a:	4603      	mov	r3, r0
 8001b6c:	4618      	mov	r0, r3
 8001b6e:	f7ff f8ff 	bl	8000d70 <chSchReadyI>
        default:
 8001b72:	e005      	b.n	8001b80 <chMtxLockS+0xa0>
      while (tp->p_prio < ctp->p_prio) {
 8001b74:	9b03      	ldr	r3, [sp, #12]
 8001b76:	689a      	ldr	r2, [r3, #8]
 8001b78:	9b02      	ldr	r3, [sp, #8]
 8001b7a:	689b      	ldr	r3, [r3, #8]
 8001b7c:	429a      	cmp	r2, r3
 8001b7e:	d3c5      	bcc.n	8001b0c <chMtxLockS+0x2c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
 8001b80:	9b01      	ldr	r3, [sp, #4]
 8001b82:	4619      	mov	r1, r3
 8001b84:	9802      	ldr	r0, [sp, #8]
 8001b86:	f7ff fefb 	bl	8001980 <queue_prio_insert.lto_priv.325>
      ctp->p_u.wtmtxp = mp;
 8001b8a:	9b02      	ldr	r3, [sp, #8]
 8001b8c:	9a01      	ldr	r2, [sp, #4]
 8001b8e:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8001b90:	2006      	movs	r0, #6
 8001b92:	f7ff f92d 	bl	8000df0 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->m_owner == ctp, "not owner");
 8001b96:	9b01      	ldr	r3, [sp, #4]
 8001b98:	689b      	ldr	r3, [r3, #8]
 8001b9a:	9a02      	ldr	r2, [sp, #8]
 8001b9c:	429a      	cmp	r2, r3
 8001b9e:	d002      	beq.n	8001ba6 <chMtxLockS+0xc6>
 8001ba0:	480d      	ldr	r0, [pc, #52]	; (8001bd8 <chMtxLockS+0xf8>)
 8001ba2:	f7fe fe35 	bl	8000810 <chSysHalt>
      chDbgAssert(ctp->p_mtxlist == mp, "not owned");
 8001ba6:	9b02      	ldr	r3, [sp, #8]
 8001ba8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001baa:	9a01      	ldr	r2, [sp, #4]
 8001bac:	429a      	cmp	r2, r3
 8001bae:	d00d      	beq.n	8001bcc <chMtxLockS+0xec>
 8001bb0:	4809      	ldr	r0, [pc, #36]	; (8001bd8 <chMtxLockS+0xf8>)
 8001bb2:	f7fe fe2d 	bl	8000810 <chSysHalt>
 8001bb6:	e009      	b.n	8001bcc <chMtxLockS+0xec>
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8001bb8:	9b01      	ldr	r3, [sp, #4]
 8001bba:	9a02      	ldr	r2, [sp, #8]
 8001bbc:	609a      	str	r2, [r3, #8]
    mp->m_next = ctp->p_mtxlist;
 8001bbe:	9b02      	ldr	r3, [sp, #8]
 8001bc0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001bc2:	9b01      	ldr	r3, [sp, #4]
 8001bc4:	60da      	str	r2, [r3, #12]
    ctp->p_mtxlist = mp;
 8001bc6:	9b02      	ldr	r3, [sp, #8]
 8001bc8:	9a01      	ldr	r2, [sp, #4]
 8001bca:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
 8001bcc:	b005      	add	sp, #20
 8001bce:	f85d fb04 	ldr.w	pc, [sp], #4
 8001bd2:	bf00      	nop
 8001bd4:	20002128 	.word	0x20002128
 8001bd8:	0800a5a0 	.word	0x0800a5a0
 8001bdc:	00000000 	.word	0x00000000

08001be0 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8001be0:	b500      	push	{lr}
 8001be2:	b087      	sub	sp, #28
 8001be4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8001be6:	4b35      	ldr	r3, [pc, #212]	; (8001cbc <chMtxUnlock+0xdc>)
 8001be8:	699b      	ldr	r3, [r3, #24]
 8001bea:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 8001bec:	9b01      	ldr	r3, [sp, #4]
 8001bee:	2b00      	cmp	r3, #0
 8001bf0:	d102      	bne.n	8001bf8 <chMtxUnlock+0x18>
 8001bf2:	4833      	ldr	r0, [pc, #204]	; (8001cc0 <chMtxUnlock+0xe0>)
 8001bf4:	f7fe fe0c 	bl	8000810 <chSysHalt>

  chSysLock();
 8001bf8:	f7ff ff12 	bl	8001a20 <chSysLock.lto_priv.54>

  chDbgAssert(ctp->p_mtxlist != NULL, "owned mutexes list empty");
 8001bfc:	9b03      	ldr	r3, [sp, #12]
 8001bfe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001c00:	2b00      	cmp	r3, #0
 8001c02:	d102      	bne.n	8001c0a <chMtxUnlock+0x2a>
 8001c04:	482e      	ldr	r0, [pc, #184]	; (8001cc0 <chMtxUnlock+0xe0>)
 8001c06:	f7fe fe03 	bl	8000810 <chSysHalt>
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp, "ownership failure");
 8001c0a:	9b03      	ldr	r3, [sp, #12]
 8001c0c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001c0e:	689b      	ldr	r3, [r3, #8]
 8001c10:	9a03      	ldr	r2, [sp, #12]
 8001c12:	429a      	cmp	r2, r3
 8001c14:	d002      	beq.n	8001c1c <chMtxUnlock+0x3c>
 8001c16:	482a      	ldr	r0, [pc, #168]	; (8001cc0 <chMtxUnlock+0xe0>)
 8001c18:	f7fe fdfa 	bl	8000810 <chSysHalt>
  chDbgAssert(mp->m_cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->m_cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");
 8001c1c:	9b03      	ldr	r3, [sp, #12]
 8001c1e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001c20:	9a01      	ldr	r2, [sp, #4]
 8001c22:	429a      	cmp	r2, r3
 8001c24:	d002      	beq.n	8001c2c <chMtxUnlock+0x4c>
 8001c26:	4826      	ldr	r0, [pc, #152]	; (8001cc0 <chMtxUnlock+0xe0>)
 8001c28:	f7fe fdf2 	bl	8000810 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8001c2c:	9b01      	ldr	r3, [sp, #4]
 8001c2e:	68da      	ldr	r2, [r3, #12]
 8001c30:	9b03      	ldr	r3, [sp, #12]
 8001c32:	63da      	str	r2, [r3, #60]	; 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8001c34:	9801      	ldr	r0, [sp, #4]
 8001c36:	f7ff ff1b 	bl	8001a70 <chMtxQueueNotEmptyS>
 8001c3a:	4603      	mov	r3, r0
 8001c3c:	2b00      	cmp	r3, #0
 8001c3e:	d034      	beq.n	8001caa <chMtxUnlock+0xca>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8001c40:	9b03      	ldr	r3, [sp, #12]
 8001c42:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001c44:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 8001c46:	9b03      	ldr	r3, [sp, #12]
 8001c48:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001c4a:	9305      	str	r3, [sp, #20]
 8001c4c:	e012      	b.n	8001c74 <chMtxUnlock+0x94>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8001c4e:	9805      	ldr	r0, [sp, #20]
 8001c50:	f7ff ff0e 	bl	8001a70 <chMtxQueueNotEmptyS>
 8001c54:	4603      	mov	r3, r0
 8001c56:	2b00      	cmp	r3, #0
 8001c58:	d009      	beq.n	8001c6e <chMtxUnlock+0x8e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8001c5a:	9b05      	ldr	r3, [sp, #20]
 8001c5c:	681b      	ldr	r3, [r3, #0]
 8001c5e:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 8001c60:	9a04      	ldr	r2, [sp, #16]
 8001c62:	429a      	cmp	r2, r3
 8001c64:	d203      	bcs.n	8001c6e <chMtxUnlock+0x8e>
          newprio = lmp->m_queue.p_next->p_prio;
 8001c66:	9b05      	ldr	r3, [sp, #20]
 8001c68:	681b      	ldr	r3, [r3, #0]
 8001c6a:	689b      	ldr	r3, [r3, #8]
 8001c6c:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 8001c6e:	9b05      	ldr	r3, [sp, #20]
 8001c70:	68db      	ldr	r3, [r3, #12]
 8001c72:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8001c74:	9b05      	ldr	r3, [sp, #20]
 8001c76:	2b00      	cmp	r3, #0
 8001c78:	d1e9      	bne.n	8001c4e <chMtxUnlock+0x6e>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8001c7a:	9b03      	ldr	r3, [sp, #12]
 8001c7c:	9a04      	ldr	r2, [sp, #16]
 8001c7e:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 8001c80:	9b01      	ldr	r3, [sp, #4]
 8001c82:	4618      	mov	r0, r3
 8001c84:	f7ff fea4 	bl	80019d0 <queue_fifo_remove.lto_priv.312>
 8001c88:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 8001c8a:	9b01      	ldr	r3, [sp, #4]
 8001c8c:	9a02      	ldr	r2, [sp, #8]
 8001c8e:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 8001c90:	9b02      	ldr	r3, [sp, #8]
 8001c92:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001c94:	9b01      	ldr	r3, [sp, #4]
 8001c96:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 8001c98:	9b02      	ldr	r3, [sp, #8]
 8001c9a:	9a01      	ldr	r2, [sp, #4]
 8001c9c:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8001c9e:	9802      	ldr	r0, [sp, #8]
 8001ca0:	f7ff f866 	bl	8000d70 <chSchReadyI>
      chSchRescheduleS();
 8001ca4:	f7ff f9ac 	bl	8001000 <chSchRescheduleS>
 8001ca8:	e002      	b.n	8001cb0 <chMtxUnlock+0xd0>
    }
    else {
      mp->m_owner = NULL;
 8001caa:	9b01      	ldr	r3, [sp, #4]
 8001cac:	2200      	movs	r2, #0
 8001cae:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 8001cb0:	f7ff febe 	bl	8001a30 <chSysUnlock.lto_priv.13>
}
 8001cb4:	b007      	add	sp, #28
 8001cb6:	f85d fb04 	ldr.w	pc, [sp], #4
 8001cba:	bf00      	nop
 8001cbc:	20002128 	.word	0x20002128
 8001cc0:	0800a5b0 	.word	0x0800a5b0
	...

08001cd0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001cd0:	b500      	push	{lr}
 8001cd2:	b085      	sub	sp, #20
 8001cd4:	9001      	str	r0, [sp, #4]
 8001cd6:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
 8001cd8:	f7fe fec2 	bl	8000a60 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 8001cdc:	9b01      	ldr	r3, [sp, #4]
 8001cde:	2b00      	cmp	r3, #0
 8001ce0:	d102      	bne.n	8001ce8 <chEvtBroadcastFlagsI+0x18>
 8001ce2:	4814      	ldr	r0, [pc, #80]	; (8001d34 <chEvtBroadcastFlagsI+0x64>)
 8001ce4:	f7fe fd94 	bl	8000810 <chSysHalt>

  elp = esp->es_next;
 8001ce8:	9b01      	ldr	r3, [sp, #4]
 8001cea:	681b      	ldr	r3, [r3, #0]
 8001cec:	9303      	str	r3, [sp, #12]
 8001cee:	e01a      	b.n	8001d26 <chEvtBroadcastFlagsI+0x56>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
 8001cf0:	9b03      	ldr	r3, [sp, #12]
 8001cf2:	68da      	ldr	r2, [r3, #12]
 8001cf4:	9b00      	ldr	r3, [sp, #0]
 8001cf6:	431a      	orrs	r2, r3
 8001cf8:	9b03      	ldr	r3, [sp, #12]
 8001cfa:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8001cfc:	9b00      	ldr	r3, [sp, #0]
 8001cfe:	2b00      	cmp	r3, #0
 8001d00:	d006      	beq.n	8001d10 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 8001d02:	9b03      	ldr	r3, [sp, #12]
 8001d04:	68da      	ldr	r2, [r3, #12]
 8001d06:	9b03      	ldr	r3, [sp, #12]
 8001d08:	691b      	ldr	r3, [r3, #16]
 8001d0a:	4013      	ands	r3, r2
    if ((flags == (eventflags_t)0) ||
 8001d0c:	2b00      	cmp	r3, #0
 8001d0e:	d007      	beq.n	8001d20 <chEvtBroadcastFlagsI+0x50>
      chEvtSignalI(elp->el_listener, elp->el_events);
 8001d10:	9b03      	ldr	r3, [sp, #12]
 8001d12:	685a      	ldr	r2, [r3, #4]
 8001d14:	9b03      	ldr	r3, [sp, #12]
 8001d16:	689b      	ldr	r3, [r3, #8]
 8001d18:	4619      	mov	r1, r3
 8001d1a:	4610      	mov	r0, r2
 8001d1c:	f000 f810 	bl	8001d40 <chEvtSignalI>
    }
    elp = elp->el_next;
 8001d20:	9b03      	ldr	r3, [sp, #12]
 8001d22:	681b      	ldr	r3, [r3, #0]
 8001d24:	9303      	str	r3, [sp, #12]
  while (elp != (event_listener_t *)esp) {
 8001d26:	9a03      	ldr	r2, [sp, #12]
 8001d28:	9b01      	ldr	r3, [sp, #4]
 8001d2a:	429a      	cmp	r2, r3
 8001d2c:	d1e0      	bne.n	8001cf0 <chEvtBroadcastFlagsI+0x20>
  }
}
 8001d2e:	b005      	add	sp, #20
 8001d30:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d34:	0800a5c0 	.word	0x0800a5c0
	...

08001d40 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8001d40:	b500      	push	{lr}
 8001d42:	b083      	sub	sp, #12
 8001d44:	9001      	str	r0, [sp, #4]
 8001d46:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8001d48:	f7fe fe8a 	bl	8000a60 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8001d4c:	9b01      	ldr	r3, [sp, #4]
 8001d4e:	2b00      	cmp	r3, #0
 8001d50:	d102      	bne.n	8001d58 <chEvtSignalI+0x18>
 8001d52:	4816      	ldr	r0, [pc, #88]	; (8001dac <chEvtSignalI+0x6c>)
 8001d54:	f7fe fd5c 	bl	8000810 <chSysHalt>

  tp->p_epending |= events;
 8001d58:	9b01      	ldr	r3, [sp, #4]
 8001d5a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001d5c:	9b00      	ldr	r3, [sp, #0]
 8001d5e:	431a      	orrs	r2, r3
 8001d60:	9b01      	ldr	r3, [sp, #4]
 8001d62:	639a      	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001d64:	9b01      	ldr	r3, [sp, #4]
 8001d66:	f893 3020 	ldrb.w	r3, [r3, #32]
 8001d6a:	2b0a      	cmp	r3, #10
 8001d6c:	d106      	bne.n	8001d7c <chEvtSignalI+0x3c>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8001d6e:	9b01      	ldr	r3, [sp, #4]
 8001d70:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001d72:	9b01      	ldr	r3, [sp, #4]
 8001d74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001d76:	4013      	ands	r3, r2
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001d78:	2b00      	cmp	r3, #0
 8001d7a:	d10d      	bne.n	8001d98 <chEvtSignalI+0x58>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8001d7c:	9b01      	ldr	r3, [sp, #4]
 8001d7e:	f893 3020 	ldrb.w	r3, [r3, #32]
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8001d82:	2b0b      	cmp	r3, #11
 8001d84:	d10e      	bne.n	8001da4 <chEvtSignalI+0x64>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8001d86:	9b01      	ldr	r3, [sp, #4]
 8001d88:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001d8a:	9b01      	ldr	r3, [sp, #4]
 8001d8c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001d8e:	401a      	ands	r2, r3
 8001d90:	9b01      	ldr	r3, [sp, #4]
 8001d92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8001d94:	429a      	cmp	r2, r3
 8001d96:	d105      	bne.n	8001da4 <chEvtSignalI+0x64>
    tp->p_u.rdymsg = MSG_OK;
 8001d98:	9b01      	ldr	r3, [sp, #4]
 8001d9a:	2200      	movs	r2, #0
 8001d9c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8001d9e:	9801      	ldr	r0, [sp, #4]
 8001da0:	f7fe ffe6 	bl	8000d70 <chSchReadyI>
  }
}
 8001da4:	b003      	add	sp, #12
 8001da6:	f85d fb04 	ldr.w	pc, [sp], #4
 8001daa:	bf00      	nop
 8001dac:	0800a5e0 	.word	0x0800a5e0

08001db0 <port_lock.lto_priv.114>:
static inline void port_lock(void) {
 8001db0:	b082      	sub	sp, #8
 8001db2:	2320      	movs	r3, #32
 8001db4:	9301      	str	r3, [sp, #4]
 8001db6:	9b01      	ldr	r3, [sp, #4]
 8001db8:	f383 8811 	msr	BASEPRI, r3
}
 8001dbc:	b002      	add	sp, #8
 8001dbe:	4770      	bx	lr

08001dc0 <port_unlock.lto_priv.84>:
static inline void port_unlock(void) {
 8001dc0:	b082      	sub	sp, #8
 8001dc2:	2300      	movs	r3, #0
 8001dc4:	9301      	str	r3, [sp, #4]
 8001dc6:	9b01      	ldr	r3, [sp, #4]
 8001dc8:	f383 8811 	msr	BASEPRI, r3
}
 8001dcc:	b002      	add	sp, #8
 8001dce:	4770      	bx	lr

08001dd0 <queue_init.lto_priv.287>:
static inline void queue_init(threads_queue_t *tqp) {
 8001dd0:	b082      	sub	sp, #8
 8001dd2:	9001      	str	r0, [sp, #4]
  tqp->p_next = (thread_t *)tqp;
 8001dd4:	9b01      	ldr	r3, [sp, #4]
 8001dd6:	9a01      	ldr	r2, [sp, #4]
 8001dd8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001dda:	9b01      	ldr	r3, [sp, #4]
 8001ddc:	9a01      	ldr	r2, [sp, #4]
 8001dde:	605a      	str	r2, [r3, #4]
}
 8001de0:	b002      	add	sp, #8
 8001de2:	4770      	bx	lr
	...

08001df0 <chSysLock.lto_priv.58>:
static inline void chSysLock(void) {
 8001df0:	b508      	push	{r3, lr}
  port_lock();
 8001df2:	f7ff ffdd 	bl	8001db0 <port_lock.lto_priv.114>
  _stats_start_measure_crit_thd();
 8001df6:	f7ff fd73 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8001dfa:	f7fe fd91 	bl	8000920 <_dbg_check_lock>
}
 8001dfe:	bd08      	pop	{r3, pc}

08001e00 <chSysUnlock.lto_priv.17>:
static inline void chSysUnlock(void) {
 8001e00:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8001e02:	f7fe fda5 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001e06:	f7ff fd73 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001e0a:	4b09      	ldr	r3, [pc, #36]	; (8001e30 <chSysUnlock.lto_priv.17+0x30>)
 8001e0c:	681b      	ldr	r3, [r3, #0]
 8001e0e:	4a08      	ldr	r2, [pc, #32]	; (8001e30 <chSysUnlock.lto_priv.17+0x30>)
 8001e10:	4293      	cmp	r3, r2
 8001e12:	d00a      	beq.n	8001e2a <chSysUnlock.lto_priv.17+0x2a>
 8001e14:	4b06      	ldr	r3, [pc, #24]	; (8001e30 <chSysUnlock.lto_priv.17+0x30>)
 8001e16:	699b      	ldr	r3, [r3, #24]
 8001e18:	689a      	ldr	r2, [r3, #8]
 8001e1a:	4b05      	ldr	r3, [pc, #20]	; (8001e30 <chSysUnlock.lto_priv.17+0x30>)
 8001e1c:	681b      	ldr	r3, [r3, #0]
 8001e1e:	689b      	ldr	r3, [r3, #8]
 8001e20:	429a      	cmp	r2, r3
 8001e22:	d202      	bcs.n	8001e2a <chSysUnlock.lto_priv.17+0x2a>
 8001e24:	4803      	ldr	r0, [pc, #12]	; (8001e34 <chSysUnlock.lto_priv.17+0x34>)
 8001e26:	f7fe fcf3 	bl	8000810 <chSysHalt>
  port_unlock();
 8001e2a:	f7ff ffc9 	bl	8001dc0 <port_unlock.lto_priv.84>
}
 8001e2e:	bd08      	pop	{r3, pc}
 8001e30:	20002128 	.word	0x20002128
 8001e34:	0800a600 	.word	0x0800a600
	...

08001e40 <chThdQueueObjectInit.lto_priv.279>:
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8001e40:	b500      	push	{lr}
 8001e42:	b083      	sub	sp, #12
 8001e44:	9001      	str	r0, [sp, #4]
  queue_init(tqp);
 8001e46:	9801      	ldr	r0, [sp, #4]
 8001e48:	f7ff ffc2 	bl	8001dd0 <queue_init.lto_priv.287>
}
 8001e4c:	b003      	add	sp, #12
 8001e4e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e52:	bf00      	nop
	...

08001e60 <chMBGetSizeI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The size of the mailbox.
 *
 * @iclass
 */
static inline cnt_t chMBGetSizeI(mailbox_t *mbp) {
 8001e60:	b082      	sub	sp, #8
 8001e62:	9001      	str	r0, [sp, #4]

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->mb_top - mbp->mb_buffer);
 8001e64:	9b01      	ldr	r3, [sp, #4]
 8001e66:	685b      	ldr	r3, [r3, #4]
 8001e68:	461a      	mov	r2, r3
 8001e6a:	9b01      	ldr	r3, [sp, #4]
 8001e6c:	681b      	ldr	r3, [r3, #0]
 8001e6e:	1ad3      	subs	r3, r2, r3
 8001e70:	109b      	asrs	r3, r3, #2
  /*lint -restore*/
}
 8001e72:	4618      	mov	r0, r3
 8001e74:	b002      	add	sp, #8
 8001e76:	4770      	bx	lr
	...

08001e80 <chMBGetUsedCountI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of queued messages.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {
 8001e80:	b500      	push	{lr}
 8001e82:	b083      	sub	sp, #12
 8001e84:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8001e86:	f7fe fdeb 	bl	8000a60 <chDbgCheckClassI>

  return mbp->mb_cnt;
 8001e8a:	9b01      	ldr	r3, [sp, #4]
 8001e8c:	691b      	ldr	r3, [r3, #16]
}
 8001e8e:	4618      	mov	r0, r3
 8001e90:	b003      	add	sp, #12
 8001e92:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e96:	bf00      	nop
	...

08001ea0 <chMBGetFreeCountI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {
 8001ea0:	b510      	push	{r4, lr}
 8001ea2:	b082      	sub	sp, #8
 8001ea4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8001ea6:	f7fe fddb 	bl	8000a60 <chDbgCheckClassI>

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8001eaa:	9801      	ldr	r0, [sp, #4]
 8001eac:	f7ff ffd8 	bl	8001e60 <chMBGetSizeI>
 8001eb0:	4604      	mov	r4, r0
 8001eb2:	9801      	ldr	r0, [sp, #4]
 8001eb4:	f7ff ffe4 	bl	8001e80 <chMBGetUsedCountI>
 8001eb8:	4603      	mov	r3, r0
 8001eba:	1ae3      	subs	r3, r4, r3
}
 8001ebc:	4618      	mov	r0, r3
 8001ebe:	b002      	add	sp, #8
 8001ec0:	bd10      	pop	{r4, pc}
 8001ec2:	bf00      	nop
	...

08001ed0 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 8001ed0:	b500      	push	{lr}
 8001ed2:	b085      	sub	sp, #20
 8001ed4:	9003      	str	r0, [sp, #12]
 8001ed6:	9102      	str	r1, [sp, #8]
 8001ed8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));
 8001eda:	9b03      	ldr	r3, [sp, #12]
 8001edc:	2b00      	cmp	r3, #0
 8001ede:	d005      	beq.n	8001eec <chMBObjectInit+0x1c>
 8001ee0:	9b02      	ldr	r3, [sp, #8]
 8001ee2:	2b00      	cmp	r3, #0
 8001ee4:	d002      	beq.n	8001eec <chMBObjectInit+0x1c>
 8001ee6:	9b01      	ldr	r3, [sp, #4]
 8001ee8:	2b00      	cmp	r3, #0
 8001eea:	dc02      	bgt.n	8001ef2 <chMBObjectInit+0x22>
 8001eec:	4812      	ldr	r0, [pc, #72]	; (8001f38 <chMBObjectInit+0x68>)
 8001eee:	f7fe fc8f 	bl	8000810 <chSysHalt>

  mbp->mb_buffer = buf;
 8001ef2:	9b03      	ldr	r3, [sp, #12]
 8001ef4:	9a02      	ldr	r2, [sp, #8]
 8001ef6:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr  = buf;
 8001ef8:	9b03      	ldr	r3, [sp, #12]
 8001efa:	9a02      	ldr	r2, [sp, #8]
 8001efc:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr  = buf;
 8001efe:	9b03      	ldr	r3, [sp, #12]
 8001f00:	9a02      	ldr	r2, [sp, #8]
 8001f02:	609a      	str	r2, [r3, #8]
  mbp->mb_top    = &buf[n];
 8001f04:	9b01      	ldr	r3, [sp, #4]
 8001f06:	009b      	lsls	r3, r3, #2
 8001f08:	9a02      	ldr	r2, [sp, #8]
 8001f0a:	441a      	add	r2, r3
 8001f0c:	9b03      	ldr	r3, [sp, #12]
 8001f0e:	605a      	str	r2, [r3, #4]
  mbp->mb_cnt    = (cnt_t)0;
 8001f10:	9b03      	ldr	r3, [sp, #12]
 8001f12:	2200      	movs	r2, #0
 8001f14:	611a      	str	r2, [r3, #16]
  mbp->mb_reset  = false;
 8001f16:	9b03      	ldr	r3, [sp, #12]
 8001f18:	2200      	movs	r2, #0
 8001f1a:	751a      	strb	r2, [r3, #20]
  chThdQueueObjectInit(&mbp->mb_qw);
 8001f1c:	9b03      	ldr	r3, [sp, #12]
 8001f1e:	3318      	adds	r3, #24
 8001f20:	4618      	mov	r0, r3
 8001f22:	f7ff ff8d 	bl	8001e40 <chThdQueueObjectInit.lto_priv.279>
  chThdQueueObjectInit(&mbp->mb_qr);
 8001f26:	9b03      	ldr	r3, [sp, #12]
 8001f28:	3320      	adds	r3, #32
 8001f2a:	4618      	mov	r0, r3
 8001f2c:	f7ff ff88 	bl	8001e40 <chThdQueueObjectInit.lto_priv.279>
}
 8001f30:	b005      	add	sp, #20
 8001f32:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f36:	bf00      	nop
 8001f38:	0800a5f0 	.word	0x0800a5f0
 8001f3c:	00000000 	.word	0x00000000

08001f40 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8001f40:	b500      	push	{lr}
 8001f42:	b087      	sub	sp, #28
 8001f44:	9003      	str	r0, [sp, #12]
 8001f46:	9102      	str	r1, [sp, #8]
 8001f48:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8001f4a:	f7ff ff51 	bl	8001df0 <chSysLock.lto_priv.58>
  rdymsg = chMBPostS(mbp, msg, timeout);
 8001f4e:	9a01      	ldr	r2, [sp, #4]
 8001f50:	9902      	ldr	r1, [sp, #8]
 8001f52:	9803      	ldr	r0, [sp, #12]
 8001f54:	f000 f80c 	bl	8001f70 <chMBPostS>
 8001f58:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8001f5a:	f7ff ff51 	bl	8001e00 <chSysUnlock.lto_priv.17>

  return rdymsg;
 8001f5e:	9b05      	ldr	r3, [sp, #20]
}
 8001f60:	4618      	mov	r0, r3
 8001f62:	b007      	add	sp, #28
 8001f64:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001f70 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8001f70:	b500      	push	{lr}
 8001f72:	b087      	sub	sp, #28
 8001f74:	9003      	str	r0, [sp, #12]
 8001f76:	9102      	str	r1, [sp, #8]
 8001f78:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
 8001f7a:	f7fe fd89 	bl	8000a90 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);
 8001f7e:	9b03      	ldr	r3, [sp, #12]
 8001f80:	2b00      	cmp	r3, #0
 8001f82:	d102      	bne.n	8001f8a <chMBPostS+0x1a>
 8001f84:	481f      	ldr	r0, [pc, #124]	; (8002004 <chMBPostS+0x94>)
 8001f86:	f7fe fc43 	bl	8000810 <chSysHalt>

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->mb_reset) {
 8001f8a:	9b03      	ldr	r3, [sp, #12]
 8001f8c:	7d1b      	ldrb	r3, [r3, #20]
 8001f8e:	2b00      	cmp	r3, #0
 8001f90:	d002      	beq.n	8001f98 <chMBPostS+0x28>
      return MSG_RESET;
 8001f92:	f06f 0301 	mvn.w	r3, #1
 8001f96:	e030      	b.n	8001ffa <chMBPostS+0x8a>
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 8001f98:	9803      	ldr	r0, [sp, #12]
 8001f9a:	f7ff ff81 	bl	8001ea0 <chMBGetFreeCountI>
 8001f9e:	4603      	mov	r3, r0
 8001fa0:	2b00      	cmp	r3, #0
 8001fa2:	dd1f      	ble.n	8001fe4 <chMBPostS+0x74>
      *mbp->mb_wrptr++ = msg;
 8001fa4:	9b03      	ldr	r3, [sp, #12]
 8001fa6:	689b      	ldr	r3, [r3, #8]
 8001fa8:	1d19      	adds	r1, r3, #4
 8001faa:	9a03      	ldr	r2, [sp, #12]
 8001fac:	6091      	str	r1, [r2, #8]
 8001fae:	9a02      	ldr	r2, [sp, #8]
 8001fb0:	601a      	str	r2, [r3, #0]
      if (mbp->mb_wrptr >= mbp->mb_top) {
 8001fb2:	9b03      	ldr	r3, [sp, #12]
 8001fb4:	689a      	ldr	r2, [r3, #8]
 8001fb6:	9b03      	ldr	r3, [sp, #12]
 8001fb8:	685b      	ldr	r3, [r3, #4]
 8001fba:	429a      	cmp	r2, r3
 8001fbc:	d303      	bcc.n	8001fc6 <chMBPostS+0x56>
        mbp->mb_wrptr = mbp->mb_buffer;
 8001fbe:	9b03      	ldr	r3, [sp, #12]
 8001fc0:	681a      	ldr	r2, [r3, #0]
 8001fc2:	9b03      	ldr	r3, [sp, #12]
 8001fc4:	609a      	str	r2, [r3, #8]
      }
      mbp->mb_cnt++;
 8001fc6:	9b03      	ldr	r3, [sp, #12]
 8001fc8:	691b      	ldr	r3, [r3, #16]
 8001fca:	1c5a      	adds	r2, r3, #1
 8001fcc:	9b03      	ldr	r3, [sp, #12]
 8001fce:	611a      	str	r2, [r3, #16]

      /* If there is a reader waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->mb_qr, MSG_OK);
 8001fd0:	9b03      	ldr	r3, [sp, #12]
 8001fd2:	3320      	adds	r3, #32
 8001fd4:	2100      	movs	r1, #0
 8001fd6:	4618      	mov	r0, r3
 8001fd8:	f7ff fb22 	bl	8001620 <chThdDequeueNextI>
      chSchRescheduleS();
 8001fdc:	f7ff f810 	bl	8001000 <chSchRescheduleS>

      return MSG_OK;
 8001fe0:	2300      	movs	r3, #0
 8001fe2:	e00a      	b.n	8001ffa <chMBPostS+0x8a>
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->mb_qw, timeout);
 8001fe4:	9b03      	ldr	r3, [sp, #12]
 8001fe6:	3318      	adds	r3, #24
 8001fe8:	9901      	ldr	r1, [sp, #4]
 8001fea:	4618      	mov	r0, r3
 8001fec:	f7ff faf8 	bl	80015e0 <chThdEnqueueTimeoutS>
 8001ff0:	9005      	str	r0, [sp, #20]
  } while (rdymsg == MSG_OK);
 8001ff2:	9b05      	ldr	r3, [sp, #20]
 8001ff4:	2b00      	cmp	r3, #0
 8001ff6:	d0c8      	beq.n	8001f8a <chMBPostS+0x1a>

  return rdymsg;
 8001ff8:	9b05      	ldr	r3, [sp, #20]
}
 8001ffa:	4618      	mov	r0, r3
 8001ffc:	b007      	add	sp, #28
 8001ffe:	f85d fb04 	ldr.w	pc, [sp], #4
 8002002:	bf00      	nop
 8002004:	0800a610 	.word	0x0800a610
	...

08002010 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002010:	b500      	push	{lr}
 8002012:	b087      	sub	sp, #28
 8002014:	9003      	str	r0, [sp, #12]
 8002016:	9102      	str	r1, [sp, #8]
 8002018:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 800201a:	f7ff fee9 	bl	8001df0 <chSysLock.lto_priv.58>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 800201e:	9a01      	ldr	r2, [sp, #4]
 8002020:	9902      	ldr	r1, [sp, #8]
 8002022:	9803      	ldr	r0, [sp, #12]
 8002024:	f000 f80c 	bl	8002040 <chMBFetchS>
 8002028:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 800202a:	f7ff fee9 	bl	8001e00 <chSysUnlock.lto_priv.17>

  return rdymsg;
 800202e:	9b05      	ldr	r3, [sp, #20]
}
 8002030:	4618      	mov	r0, r3
 8002032:	b007      	add	sp, #28
 8002034:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002040 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002040:	b500      	push	{lr}
 8002042:	b087      	sub	sp, #28
 8002044:	9003      	str	r0, [sp, #12]
 8002046:	9102      	str	r1, [sp, #8]
 8002048:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
 800204a:	f7fe fd21 	bl	8000a90 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 800204e:	9b03      	ldr	r3, [sp, #12]
 8002050:	2b00      	cmp	r3, #0
 8002052:	d002      	beq.n	800205a <chMBFetchS+0x1a>
 8002054:	9b02      	ldr	r3, [sp, #8]
 8002056:	2b00      	cmp	r3, #0
 8002058:	d102      	bne.n	8002060 <chMBFetchS+0x20>
 800205a:	4820      	ldr	r0, [pc, #128]	; (80020dc <chMBFetchS+0x9c>)
 800205c:	f7fe fbd8 	bl	8000810 <chSysHalt>

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->mb_reset) {
 8002060:	9b03      	ldr	r3, [sp, #12]
 8002062:	7d1b      	ldrb	r3, [r3, #20]
 8002064:	2b00      	cmp	r3, #0
 8002066:	d002      	beq.n	800206e <chMBFetchS+0x2e>
      return MSG_RESET;
 8002068:	f06f 0301 	mvn.w	r3, #1
 800206c:	e031      	b.n	80020d2 <chMBFetchS+0x92>
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
 800206e:	9803      	ldr	r0, [sp, #12]
 8002070:	f7ff ff06 	bl	8001e80 <chMBGetUsedCountI>
 8002074:	4603      	mov	r3, r0
 8002076:	2b00      	cmp	r3, #0
 8002078:	dd20      	ble.n	80020bc <chMBFetchS+0x7c>
      *msgp = *mbp->mb_rdptr++;
 800207a:	9b03      	ldr	r3, [sp, #12]
 800207c:	68db      	ldr	r3, [r3, #12]
 800207e:	1d19      	adds	r1, r3, #4
 8002080:	9a03      	ldr	r2, [sp, #12]
 8002082:	60d1      	str	r1, [r2, #12]
 8002084:	681a      	ldr	r2, [r3, #0]
 8002086:	9b02      	ldr	r3, [sp, #8]
 8002088:	601a      	str	r2, [r3, #0]
      if (mbp->mb_rdptr >= mbp->mb_top) {
 800208a:	9b03      	ldr	r3, [sp, #12]
 800208c:	68da      	ldr	r2, [r3, #12]
 800208e:	9b03      	ldr	r3, [sp, #12]
 8002090:	685b      	ldr	r3, [r3, #4]
 8002092:	429a      	cmp	r2, r3
 8002094:	d303      	bcc.n	800209e <chMBFetchS+0x5e>
        mbp->mb_rdptr = mbp->mb_buffer;
 8002096:	9b03      	ldr	r3, [sp, #12]
 8002098:	681a      	ldr	r2, [r3, #0]
 800209a:	9b03      	ldr	r3, [sp, #12]
 800209c:	60da      	str	r2, [r3, #12]
      }
      mbp->mb_cnt--;
 800209e:	9b03      	ldr	r3, [sp, #12]
 80020a0:	691b      	ldr	r3, [r3, #16]
 80020a2:	1e5a      	subs	r2, r3, #1
 80020a4:	9b03      	ldr	r3, [sp, #12]
 80020a6:	611a      	str	r2, [r3, #16]

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->mb_qw, MSG_OK);
 80020a8:	9b03      	ldr	r3, [sp, #12]
 80020aa:	3318      	adds	r3, #24
 80020ac:	2100      	movs	r1, #0
 80020ae:	4618      	mov	r0, r3
 80020b0:	f7ff fab6 	bl	8001620 <chThdDequeueNextI>
      chSchRescheduleS();
 80020b4:	f7fe ffa4 	bl	8001000 <chSchRescheduleS>

      return MSG_OK;
 80020b8:	2300      	movs	r3, #0
 80020ba:	e00a      	b.n	80020d2 <chMBFetchS+0x92>
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->mb_qr, timeout);
 80020bc:	9b03      	ldr	r3, [sp, #12]
 80020be:	3320      	adds	r3, #32
 80020c0:	9901      	ldr	r1, [sp, #4]
 80020c2:	4618      	mov	r0, r3
 80020c4:	f7ff fa8c 	bl	80015e0 <chThdEnqueueTimeoutS>
 80020c8:	9005      	str	r0, [sp, #20]
  } while (rdymsg == MSG_OK);
 80020ca:	9b05      	ldr	r3, [sp, #20]
 80020cc:	2b00      	cmp	r3, #0
 80020ce:	d0c7      	beq.n	8002060 <chMBFetchS+0x20>

  return rdymsg;
 80020d0:	9b05      	ldr	r3, [sp, #20]
}
 80020d2:	4618      	mov	r0, r3
 80020d4:	b007      	add	sp, #28
 80020d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80020da:	bf00      	nop
 80020dc:	0800a620 	.word	0x0800a620

080020e0 <port_lock.lto_priv.115>:
static inline void port_lock(void) {
 80020e0:	b082      	sub	sp, #8
 80020e2:	2320      	movs	r3, #32
 80020e4:	9301      	str	r3, [sp, #4]
 80020e6:	9b01      	ldr	r3, [sp, #4]
 80020e8:	f383 8811 	msr	BASEPRI, r3
}
 80020ec:	b002      	add	sp, #8
 80020ee:	4770      	bx	lr

080020f0 <port_unlock.lto_priv.85>:
static inline void port_unlock(void) {
 80020f0:	b082      	sub	sp, #8
 80020f2:	2300      	movs	r3, #0
 80020f4:	9301      	str	r3, [sp, #4]
 80020f6:	9b01      	ldr	r3, [sp, #4]
 80020f8:	f383 8811 	msr	BASEPRI, r3
}
 80020fc:	b002      	add	sp, #8
 80020fe:	4770      	bx	lr

08002100 <queue_init.lto_priv.288>:
static inline void queue_init(threads_queue_t *tqp) {
 8002100:	b082      	sub	sp, #8
 8002102:	9001      	str	r0, [sp, #4]
  tqp->p_next = (thread_t *)tqp;
 8002104:	9b01      	ldr	r3, [sp, #4]
 8002106:	9a01      	ldr	r2, [sp, #4]
 8002108:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800210a:	9b01      	ldr	r3, [sp, #4]
 800210c:	9a01      	ldr	r2, [sp, #4]
 800210e:	605a      	str	r2, [r3, #4]
}
 8002110:	b002      	add	sp, #8
 8002112:	4770      	bx	lr
	...

08002120 <chSysLock.lto_priv.59>:
static inline void chSysLock(void) {
 8002120:	b508      	push	{r3, lr}
  port_lock();
 8002122:	f7ff ffdd 	bl	80020e0 <port_lock.lto_priv.115>
  _stats_start_measure_crit_thd();
 8002126:	f7ff fbdb 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800212a:	f7fe fbf9 	bl	8000920 <_dbg_check_lock>
}
 800212e:	bd08      	pop	{r3, pc}

08002130 <chSysUnlock.lto_priv.18>:
static inline void chSysUnlock(void) {
 8002130:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8002132:	f7fe fc0d 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8002136:	f7ff fbdb 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800213a:	4b09      	ldr	r3, [pc, #36]	; (8002160 <chSysUnlock.lto_priv.18+0x30>)
 800213c:	681b      	ldr	r3, [r3, #0]
 800213e:	4a08      	ldr	r2, [pc, #32]	; (8002160 <chSysUnlock.lto_priv.18+0x30>)
 8002140:	4293      	cmp	r3, r2
 8002142:	d00a      	beq.n	800215a <chSysUnlock.lto_priv.18+0x2a>
 8002144:	4b06      	ldr	r3, [pc, #24]	; (8002160 <chSysUnlock.lto_priv.18+0x30>)
 8002146:	699b      	ldr	r3, [r3, #24]
 8002148:	689a      	ldr	r2, [r3, #8]
 800214a:	4b05      	ldr	r3, [pc, #20]	; (8002160 <chSysUnlock.lto_priv.18+0x30>)
 800214c:	681b      	ldr	r3, [r3, #0]
 800214e:	689b      	ldr	r3, [r3, #8]
 8002150:	429a      	cmp	r2, r3
 8002152:	d202      	bcs.n	800215a <chSysUnlock.lto_priv.18+0x2a>
 8002154:	4803      	ldr	r0, [pc, #12]	; (8002164 <chSysUnlock.lto_priv.18+0x34>)
 8002156:	f7fe fb5b 	bl	8000810 <chSysHalt>
  port_unlock();
 800215a:	f7ff ffc9 	bl	80020f0 <port_unlock.lto_priv.85>
}
 800215e:	bd08      	pop	{r3, pc}
 8002160:	20002128 	.word	0x20002128
 8002164:	0800a630 	.word	0x0800a630
	...

08002170 <chThdQueueObjectInit.lto_priv.280>:
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8002170:	b500      	push	{lr}
 8002172:	b083      	sub	sp, #12
 8002174:	9001      	str	r0, [sp, #4]
  queue_init(tqp);
 8002176:	9801      	ldr	r0, [sp, #4]
 8002178:	f7ff ffc2 	bl	8002100 <queue_init.lto_priv.288>
}
 800217c:	b003      	add	sp, #12
 800217e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002182:	bf00      	nop
	...

08002190 <chIQIsEmptyI.lto_priv.273>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8002190:	b500      	push	{lr}
 8002192:	b083      	sub	sp, #12
 8002194:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002196:	f7fe fc63 	bl	8000a60 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 800219a:	9b01      	ldr	r3, [sp, #4]
 800219c:	689b      	ldr	r3, [r3, #8]
 800219e:	2b00      	cmp	r3, #0
 80021a0:	bf0c      	ite	eq
 80021a2:	2301      	moveq	r3, #1
 80021a4:	2300      	movne	r3, #0
 80021a6:	b2db      	uxtb	r3, r3
}
 80021a8:	4618      	mov	r0, r3
 80021aa:	b003      	add	sp, #12
 80021ac:	f85d fb04 	ldr.w	pc, [sp], #4

080021b0 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 80021b0:	b500      	push	{lr}
 80021b2:	b083      	sub	sp, #12
 80021b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80021b6:	f7fe fc53 	bl	8000a60 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80021ba:	9b01      	ldr	r3, [sp, #4]
 80021bc:	695a      	ldr	r2, [r3, #20]
 80021be:	9b01      	ldr	r3, [sp, #4]
 80021c0:	699b      	ldr	r3, [r3, #24]
 80021c2:	429a      	cmp	r2, r3
 80021c4:	d105      	bne.n	80021d2 <chIQIsFullI+0x22>
 80021c6:	9b01      	ldr	r3, [sp, #4]
 80021c8:	689b      	ldr	r3, [r3, #8]
 80021ca:	2b00      	cmp	r3, #0
 80021cc:	d001      	beq.n	80021d2 <chIQIsFullI+0x22>
 80021ce:	2301      	movs	r3, #1
 80021d0:	e000      	b.n	80021d4 <chIQIsFullI+0x24>
 80021d2:	2300      	movs	r3, #0
 80021d4:	f003 0301 	and.w	r3, r3, #1
 80021d8:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 80021da:	4618      	mov	r0, r3
 80021dc:	b003      	add	sp, #12
 80021de:	f85d fb04 	ldr.w	pc, [sp], #4
 80021e2:	bf00      	nop
	...

080021f0 <chOQIsEmptyI.lto_priv.206>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 80021f0:	b500      	push	{lr}
 80021f2:	b083      	sub	sp, #12
 80021f4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80021f6:	f7fe fc33 	bl	8000a60 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80021fa:	9b01      	ldr	r3, [sp, #4]
 80021fc:	695a      	ldr	r2, [r3, #20]
 80021fe:	9b01      	ldr	r3, [sp, #4]
 8002200:	699b      	ldr	r3, [r3, #24]
 8002202:	429a      	cmp	r2, r3
 8002204:	d105      	bne.n	8002212 <chOQIsEmptyI.lto_priv.206+0x22>
 8002206:	9b01      	ldr	r3, [sp, #4]
 8002208:	689b      	ldr	r3, [r3, #8]
 800220a:	2b00      	cmp	r3, #0
 800220c:	d001      	beq.n	8002212 <chOQIsEmptyI.lto_priv.206+0x22>
 800220e:	2301      	movs	r3, #1
 8002210:	e000      	b.n	8002214 <chOQIsEmptyI.lto_priv.206+0x24>
 8002212:	2300      	movs	r3, #0
 8002214:	f003 0301 	and.w	r3, r3, #1
 8002218:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800221a:	4618      	mov	r0, r3
 800221c:	b003      	add	sp, #12
 800221e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002222:	bf00      	nop
	...

08002230 <chOQIsFullI.lto_priv.271>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8002230:	b500      	push	{lr}
 8002232:	b083      	sub	sp, #12
 8002234:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002236:	f7fe fc13 	bl	8000a60 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 800223a:	9b01      	ldr	r3, [sp, #4]
 800223c:	689b      	ldr	r3, [r3, #8]
 800223e:	2b00      	cmp	r3, #0
 8002240:	bf0c      	ite	eq
 8002242:	2301      	moveq	r3, #1
 8002244:	2300      	movne	r3, #0
 8002246:	b2db      	uxtb	r3, r3
}
 8002248:	4618      	mov	r0, r3
 800224a:	b003      	add	sp, #12
 800224c:	f85d fb04 	ldr.w	pc, [sp], #4

08002250 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 8002250:	b500      	push	{lr}
 8002252:	b085      	sub	sp, #20
 8002254:	9003      	str	r0, [sp, #12]
 8002256:	9102      	str	r1, [sp, #8]
 8002258:	9201      	str	r2, [sp, #4]
 800225a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
 800225c:	9b03      	ldr	r3, [sp, #12]
 800225e:	4618      	mov	r0, r3
 8002260:	f7ff ff86 	bl	8002170 <chThdQueueObjectInit.lto_priv.280>
  iqp->q_counter = 0;
 8002264:	9b03      	ldr	r3, [sp, #12]
 8002266:	2200      	movs	r2, #0
 8002268:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 800226a:	9b03      	ldr	r3, [sp, #12]
 800226c:	9a02      	ldr	r2, [sp, #8]
 800226e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8002270:	9b03      	ldr	r3, [sp, #12]
 8002272:	9a02      	ldr	r2, [sp, #8]
 8002274:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8002276:	9b03      	ldr	r3, [sp, #12]
 8002278:	9a02      	ldr	r2, [sp, #8]
 800227a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800227c:	9a02      	ldr	r2, [sp, #8]
 800227e:	9b01      	ldr	r3, [sp, #4]
 8002280:	441a      	add	r2, r3
 8002282:	9b03      	ldr	r3, [sp, #12]
 8002284:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8002286:	9b03      	ldr	r3, [sp, #12]
 8002288:	9a00      	ldr	r2, [sp, #0]
 800228a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800228c:	9b03      	ldr	r3, [sp, #12]
 800228e:	9a06      	ldr	r2, [sp, #24]
 8002290:	621a      	str	r2, [r3, #32]
}
 8002292:	b005      	add	sp, #20
 8002294:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080022a0 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 80022a0:	b500      	push	{lr}
 80022a2:	b083      	sub	sp, #12
 80022a4:	9001      	str	r0, [sp, #4]
 80022a6:	460b      	mov	r3, r1
 80022a8:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();
 80022ac:	f7fe fbd8 	bl	8000a60 <chDbgCheckClassI>

  if (chIQIsFullI(iqp)) {
 80022b0:	9801      	ldr	r0, [sp, #4]
 80022b2:	f7ff ff7d 	bl	80021b0 <chIQIsFullI>
 80022b6:	4603      	mov	r3, r0
 80022b8:	2b00      	cmp	r3, #0
 80022ba:	d002      	beq.n	80022c2 <chIQPutI+0x22>
    return Q_FULL;
 80022bc:	f06f 0303 	mvn.w	r3, #3
 80022c0:	e01c      	b.n	80022fc <chIQPutI+0x5c>
  }

  iqp->q_counter++;
 80022c2:	9b01      	ldr	r3, [sp, #4]
 80022c4:	689b      	ldr	r3, [r3, #8]
 80022c6:	1c5a      	adds	r2, r3, #1
 80022c8:	9b01      	ldr	r3, [sp, #4]
 80022ca:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 80022cc:	9b01      	ldr	r3, [sp, #4]
 80022ce:	695b      	ldr	r3, [r3, #20]
 80022d0:	1c59      	adds	r1, r3, #1
 80022d2:	9a01      	ldr	r2, [sp, #4]
 80022d4:	6151      	str	r1, [r2, #20]
 80022d6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80022da:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 80022dc:	9b01      	ldr	r3, [sp, #4]
 80022de:	695a      	ldr	r2, [r3, #20]
 80022e0:	9b01      	ldr	r3, [sp, #4]
 80022e2:	691b      	ldr	r3, [r3, #16]
 80022e4:	429a      	cmp	r2, r3
 80022e6:	d303      	bcc.n	80022f0 <chIQPutI+0x50>
    iqp->q_wrptr = iqp->q_buffer;
 80022e8:	9b01      	ldr	r3, [sp, #4]
 80022ea:	68da      	ldr	r2, [r3, #12]
 80022ec:	9b01      	ldr	r3, [sp, #4]
 80022ee:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 80022f0:	9b01      	ldr	r3, [sp, #4]
 80022f2:	2100      	movs	r1, #0
 80022f4:	4618      	mov	r0, r3
 80022f6:	f7ff f993 	bl	8001620 <chThdDequeueNextI>

  return Q_OK;
 80022fa:	2300      	movs	r3, #0
}
 80022fc:	4618      	mov	r0, r3
 80022fe:	b003      	add	sp, #12
 8002300:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002310 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8002310:	b500      	push	{lr}
 8002312:	b085      	sub	sp, #20
 8002314:	9001      	str	r0, [sp, #4]
 8002316:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
 8002318:	f7ff ff02 	bl	8002120 <chSysLock.lto_priv.59>
  if (iqp->q_notify != NULL) {
 800231c:	9b01      	ldr	r3, [sp, #4]
 800231e:	69db      	ldr	r3, [r3, #28]
 8002320:	2b00      	cmp	r3, #0
 8002322:	d011      	beq.n	8002348 <chIQGetTimeout+0x38>
    iqp->q_notify(iqp);
 8002324:	9b01      	ldr	r3, [sp, #4]
 8002326:	69db      	ldr	r3, [r3, #28]
 8002328:	9801      	ldr	r0, [sp, #4]
 800232a:	4798      	blx	r3
 800232c:	e00c      	b.n	8002348 <chIQGetTimeout+0x38>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800232e:	9b01      	ldr	r3, [sp, #4]
 8002330:	9900      	ldr	r1, [sp, #0]
 8002332:	4618      	mov	r0, r3
 8002334:	f7ff f954 	bl	80015e0 <chThdEnqueueTimeoutS>
 8002338:	9002      	str	r0, [sp, #8]
    if (msg < Q_OK) {
 800233a:	9b02      	ldr	r3, [sp, #8]
 800233c:	2b00      	cmp	r3, #0
 800233e:	da03      	bge.n	8002348 <chIQGetTimeout+0x38>
      chSysUnlock();
 8002340:	f7ff fef6 	bl	8002130 <chSysUnlock.lto_priv.18>
      return msg;
 8002344:	9b02      	ldr	r3, [sp, #8]
 8002346:	e020      	b.n	800238a <chIQGetTimeout+0x7a>
  while (chIQIsEmptyI(iqp)) {
 8002348:	9801      	ldr	r0, [sp, #4]
 800234a:	f7ff ff21 	bl	8002190 <chIQIsEmptyI.lto_priv.273>
 800234e:	4603      	mov	r3, r0
 8002350:	2b00      	cmp	r3, #0
 8002352:	d1ec      	bne.n	800232e <chIQGetTimeout+0x1e>
    }
  }

  iqp->q_counter--;
 8002354:	9b01      	ldr	r3, [sp, #4]
 8002356:	689b      	ldr	r3, [r3, #8]
 8002358:	1e5a      	subs	r2, r3, #1
 800235a:	9b01      	ldr	r3, [sp, #4]
 800235c:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 800235e:	9b01      	ldr	r3, [sp, #4]
 8002360:	699b      	ldr	r3, [r3, #24]
 8002362:	1c59      	adds	r1, r3, #1
 8002364:	9a01      	ldr	r2, [sp, #4]
 8002366:	6191      	str	r1, [r2, #24]
 8002368:	781b      	ldrb	r3, [r3, #0]
 800236a:	f88d 300f 	strb.w	r3, [sp, #15]
  if (iqp->q_rdptr >= iqp->q_top) {
 800236e:	9b01      	ldr	r3, [sp, #4]
 8002370:	699a      	ldr	r2, [r3, #24]
 8002372:	9b01      	ldr	r3, [sp, #4]
 8002374:	691b      	ldr	r3, [r3, #16]
 8002376:	429a      	cmp	r2, r3
 8002378:	d303      	bcc.n	8002382 <chIQGetTimeout+0x72>
    iqp->q_rdptr = iqp->q_buffer;
 800237a:	9b01      	ldr	r3, [sp, #4]
 800237c:	68da      	ldr	r2, [r3, #12]
 800237e:	9b01      	ldr	r3, [sp, #4]
 8002380:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
 8002382:	f7ff fed5 	bl	8002130 <chSysUnlock.lto_priv.18>

  return (msg_t)b;
 8002386:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800238a:	4618      	mov	r0, r3
 800238c:	b005      	add	sp, #20
 800238e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002392:	bf00      	nop
	...

080023a0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 80023a0:	b500      	push	{lr}
 80023a2:	b087      	sub	sp, #28
 80023a4:	9003      	str	r0, [sp, #12]
 80023a6:	9102      	str	r1, [sp, #8]
 80023a8:	9201      	str	r2, [sp, #4]
 80023aa:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 80023ac:	9b03      	ldr	r3, [sp, #12]
 80023ae:	69db      	ldr	r3, [r3, #28]
 80023b0:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 80023b2:	2300      	movs	r3, #0
 80023b4:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
 80023b6:	9b01      	ldr	r3, [sp, #4]
 80023b8:	2b00      	cmp	r3, #0
 80023ba:	d102      	bne.n	80023c2 <chIQReadTimeout+0x22>
 80023bc:	4825      	ldr	r0, [pc, #148]	; (8002454 <chIQReadTimeout+0xb4>)
 80023be:	f7fe fa27 	bl	8000810 <chSysHalt>

  chSysLock();
 80023c2:	f7ff fead 	bl	8002120 <chSysLock.lto_priv.59>
  while (true) {
    if (nfy != NULL) {
 80023c6:	9b04      	ldr	r3, [sp, #16]
 80023c8:	2b00      	cmp	r3, #0
 80023ca:	d00f      	beq.n	80023ec <chIQReadTimeout+0x4c>
      nfy(iqp);
 80023cc:	9b04      	ldr	r3, [sp, #16]
 80023ce:	9803      	ldr	r0, [sp, #12]
 80023d0:	4798      	blx	r3
 80023d2:	e00b      	b.n	80023ec <chIQReadTimeout+0x4c>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 80023d4:	9b03      	ldr	r3, [sp, #12]
 80023d6:	9900      	ldr	r1, [sp, #0]
 80023d8:	4618      	mov	r0, r3
 80023da:	f7ff f901 	bl	80015e0 <chThdEnqueueTimeoutS>
 80023de:	4603      	mov	r3, r0
 80023e0:	2b00      	cmp	r3, #0
 80023e2:	d003      	beq.n	80023ec <chIQReadTimeout+0x4c>
        chSysUnlock();
 80023e4:	f7ff fea4 	bl	8002130 <chSysUnlock.lto_priv.18>
        return r;
 80023e8:	9b05      	ldr	r3, [sp, #20]
 80023ea:	e02e      	b.n	800244a <chIQReadTimeout+0xaa>
    while (chIQIsEmptyI(iqp)) {
 80023ec:	9803      	ldr	r0, [sp, #12]
 80023ee:	f7ff fecf 	bl	8002190 <chIQIsEmptyI.lto_priv.273>
 80023f2:	4603      	mov	r3, r0
 80023f4:	2b00      	cmp	r3, #0
 80023f6:	d1ed      	bne.n	80023d4 <chIQReadTimeout+0x34>
      }
    }

    iqp->q_counter--;
 80023f8:	9b03      	ldr	r3, [sp, #12]
 80023fa:	689b      	ldr	r3, [r3, #8]
 80023fc:	1e5a      	subs	r2, r3, #1
 80023fe:	9b03      	ldr	r3, [sp, #12]
 8002400:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 8002402:	9b03      	ldr	r3, [sp, #12]
 8002404:	699a      	ldr	r2, [r3, #24]
 8002406:	1c51      	adds	r1, r2, #1
 8002408:	9b03      	ldr	r3, [sp, #12]
 800240a:	6199      	str	r1, [r3, #24]
 800240c:	9b02      	ldr	r3, [sp, #8]
 800240e:	1c59      	adds	r1, r3, #1
 8002410:	9102      	str	r1, [sp, #8]
 8002412:	7812      	ldrb	r2, [r2, #0]
 8002414:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 8002416:	9b03      	ldr	r3, [sp, #12]
 8002418:	699a      	ldr	r2, [r3, #24]
 800241a:	9b03      	ldr	r3, [sp, #12]
 800241c:	691b      	ldr	r3, [r3, #16]
 800241e:	429a      	cmp	r2, r3
 8002420:	d303      	bcc.n	800242a <chIQReadTimeout+0x8a>
      iqp->q_rdptr = iqp->q_buffer;
 8002422:	9b03      	ldr	r3, [sp, #12]
 8002424:	68da      	ldr	r2, [r3, #12]
 8002426:	9b03      	ldr	r3, [sp, #12]
 8002428:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 800242a:	f7ff fe81 	bl	8002130 <chSysUnlock.lto_priv.18>

    r++;
 800242e:	9b05      	ldr	r3, [sp, #20]
 8002430:	3301      	adds	r3, #1
 8002432:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 8002434:	9b01      	ldr	r3, [sp, #4]
 8002436:	3b01      	subs	r3, #1
 8002438:	9301      	str	r3, [sp, #4]
 800243a:	9b01      	ldr	r3, [sp, #4]
 800243c:	2b00      	cmp	r3, #0
 800243e:	d101      	bne.n	8002444 <chIQReadTimeout+0xa4>
      return r;
 8002440:	9b05      	ldr	r3, [sp, #20]
 8002442:	e002      	b.n	800244a <chIQReadTimeout+0xaa>
    }

    chSysLock();
 8002444:	f7ff fe6c 	bl	8002120 <chSysLock.lto_priv.59>
 8002448:	e7bd      	b.n	80023c6 <chIQReadTimeout+0x26>
  }
}
 800244a:	4618      	mov	r0, r3
 800244c:	b007      	add	sp, #28
 800244e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002452:	bf00      	nop
 8002454:	0800a640 	.word	0x0800a640
	...

08002460 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 8002460:	b500      	push	{lr}
 8002462:	b085      	sub	sp, #20
 8002464:	9003      	str	r0, [sp, #12]
 8002466:	9102      	str	r1, [sp, #8]
 8002468:	9201      	str	r2, [sp, #4]
 800246a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
 800246c:	9b03      	ldr	r3, [sp, #12]
 800246e:	4618      	mov	r0, r3
 8002470:	f7ff fe7e 	bl	8002170 <chThdQueueObjectInit.lto_priv.280>
  oqp->q_counter = size;
 8002474:	9b03      	ldr	r3, [sp, #12]
 8002476:	9a01      	ldr	r2, [sp, #4]
 8002478:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800247a:	9b03      	ldr	r3, [sp, #12]
 800247c:	9a02      	ldr	r2, [sp, #8]
 800247e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8002480:	9b03      	ldr	r3, [sp, #12]
 8002482:	9a02      	ldr	r2, [sp, #8]
 8002484:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8002486:	9b03      	ldr	r3, [sp, #12]
 8002488:	9a02      	ldr	r2, [sp, #8]
 800248a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 800248c:	9a02      	ldr	r2, [sp, #8]
 800248e:	9b01      	ldr	r3, [sp, #4]
 8002490:	441a      	add	r2, r3
 8002492:	9b03      	ldr	r3, [sp, #12]
 8002494:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8002496:	9b03      	ldr	r3, [sp, #12]
 8002498:	9a00      	ldr	r2, [sp, #0]
 800249a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800249c:	9b03      	ldr	r3, [sp, #12]
 800249e:	9a06      	ldr	r2, [sp, #24]
 80024a0:	621a      	str	r2, [r3, #32]
}
 80024a2:	b005      	add	sp, #20
 80024a4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080024b0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 80024b0:	b500      	push	{lr}
 80024b2:	b087      	sub	sp, #28
 80024b4:	9003      	str	r0, [sp, #12]
 80024b6:	460b      	mov	r3, r1
 80024b8:	9201      	str	r2, [sp, #4]
 80024ba:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
 80024be:	f7ff fe2f 	bl	8002120 <chSysLock.lto_priv.59>
 80024c2:	e00c      	b.n	80024de <chOQPutTimeout+0x2e>
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 80024c4:	9b03      	ldr	r3, [sp, #12]
 80024c6:	9901      	ldr	r1, [sp, #4]
 80024c8:	4618      	mov	r0, r3
 80024ca:	f7ff f889 	bl	80015e0 <chThdEnqueueTimeoutS>
 80024ce:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
 80024d0:	9b05      	ldr	r3, [sp, #20]
 80024d2:	2b00      	cmp	r3, #0
 80024d4:	da03      	bge.n	80024de <chOQPutTimeout+0x2e>
      chSysUnlock();
 80024d6:	f7ff fe2b 	bl	8002130 <chSysUnlock.lto_priv.18>
      return msg;
 80024da:	9b05      	ldr	r3, [sp, #20]
 80024dc:	e027      	b.n	800252e <chOQPutTimeout+0x7e>
  while (chOQIsFullI(oqp)) {
 80024de:	9803      	ldr	r0, [sp, #12]
 80024e0:	f7ff fea6 	bl	8002230 <chOQIsFullI.lto_priv.271>
 80024e4:	4603      	mov	r3, r0
 80024e6:	2b00      	cmp	r3, #0
 80024e8:	d1ec      	bne.n	80024c4 <chOQPutTimeout+0x14>
    }
  }

  oqp->q_counter--;
 80024ea:	9b03      	ldr	r3, [sp, #12]
 80024ec:	689b      	ldr	r3, [r3, #8]
 80024ee:	1e5a      	subs	r2, r3, #1
 80024f0:	9b03      	ldr	r3, [sp, #12]
 80024f2:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 80024f4:	9b03      	ldr	r3, [sp, #12]
 80024f6:	695b      	ldr	r3, [r3, #20]
 80024f8:	1c59      	adds	r1, r3, #1
 80024fa:	9a03      	ldr	r2, [sp, #12]
 80024fc:	6151      	str	r1, [r2, #20]
 80024fe:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8002502:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8002504:	9b03      	ldr	r3, [sp, #12]
 8002506:	695a      	ldr	r2, [r3, #20]
 8002508:	9b03      	ldr	r3, [sp, #12]
 800250a:	691b      	ldr	r3, [r3, #16]
 800250c:	429a      	cmp	r2, r3
 800250e:	d303      	bcc.n	8002518 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
 8002510:	9b03      	ldr	r3, [sp, #12]
 8002512:	68da      	ldr	r2, [r3, #12]
 8002514:	9b03      	ldr	r3, [sp, #12]
 8002516:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 8002518:	9b03      	ldr	r3, [sp, #12]
 800251a:	69db      	ldr	r3, [r3, #28]
 800251c:	2b00      	cmp	r3, #0
 800251e:	d003      	beq.n	8002528 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
 8002520:	9b03      	ldr	r3, [sp, #12]
 8002522:	69db      	ldr	r3, [r3, #28]
 8002524:	9803      	ldr	r0, [sp, #12]
 8002526:	4798      	blx	r3
  }
  chSysUnlock();
 8002528:	f7ff fe02 	bl	8002130 <chSysUnlock.lto_priv.18>

  return Q_OK;
 800252c:	2300      	movs	r3, #0
}
 800252e:	4618      	mov	r0, r3
 8002530:	b007      	add	sp, #28
 8002532:	f85d fb04 	ldr.w	pc, [sp], #4
 8002536:	bf00      	nop
	...

08002540 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8002540:	b500      	push	{lr}
 8002542:	b085      	sub	sp, #20
 8002544:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();
 8002546:	f7fe fa8b 	bl	8000a60 <chDbgCheckClassI>

  if (chOQIsEmptyI(oqp)) {
 800254a:	9801      	ldr	r0, [sp, #4]
 800254c:	f7ff fe50 	bl	80021f0 <chOQIsEmptyI.lto_priv.206>
 8002550:	4603      	mov	r3, r0
 8002552:	2b00      	cmp	r3, #0
 8002554:	d002      	beq.n	800255c <chOQGetI+0x1c>
    return Q_EMPTY;
 8002556:	f06f 0302 	mvn.w	r3, #2
 800255a:	e01d      	b.n	8002598 <chOQGetI+0x58>
  }

  oqp->q_counter++;
 800255c:	9b01      	ldr	r3, [sp, #4]
 800255e:	689b      	ldr	r3, [r3, #8]
 8002560:	1c5a      	adds	r2, r3, #1
 8002562:	9b01      	ldr	r3, [sp, #4]
 8002564:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8002566:	9b01      	ldr	r3, [sp, #4]
 8002568:	699b      	ldr	r3, [r3, #24]
 800256a:	1c59      	adds	r1, r3, #1
 800256c:	9a01      	ldr	r2, [sp, #4]
 800256e:	6191      	str	r1, [r2, #24]
 8002570:	781b      	ldrb	r3, [r3, #0]
 8002572:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 8002576:	9b01      	ldr	r3, [sp, #4]
 8002578:	699a      	ldr	r2, [r3, #24]
 800257a:	9b01      	ldr	r3, [sp, #4]
 800257c:	691b      	ldr	r3, [r3, #16]
 800257e:	429a      	cmp	r2, r3
 8002580:	d303      	bcc.n	800258a <chOQGetI+0x4a>
    oqp->q_rdptr = oqp->q_buffer;
 8002582:	9b01      	ldr	r3, [sp, #4]
 8002584:	68da      	ldr	r2, [r3, #12]
 8002586:	9b01      	ldr	r3, [sp, #4]
 8002588:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 800258a:	9b01      	ldr	r3, [sp, #4]
 800258c:	2100      	movs	r1, #0
 800258e:	4618      	mov	r0, r3
 8002590:	f7ff f846 	bl	8001620 <chThdDequeueNextI>

  return (msg_t)b;
 8002594:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8002598:	4618      	mov	r0, r3
 800259a:	b005      	add	sp, #20
 800259c:	f85d fb04 	ldr.w	pc, [sp], #4

080025a0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 80025a0:	b500      	push	{lr}
 80025a2:	b087      	sub	sp, #28
 80025a4:	9003      	str	r0, [sp, #12]
 80025a6:	9102      	str	r1, [sp, #8]
 80025a8:	9201      	str	r2, [sp, #4]
 80025aa:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 80025ac:	9b03      	ldr	r3, [sp, #12]
 80025ae:	69db      	ldr	r3, [r3, #28]
 80025b0:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 80025b2:	2300      	movs	r3, #0
 80025b4:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
 80025b6:	9b01      	ldr	r3, [sp, #4]
 80025b8:	2b00      	cmp	r3, #0
 80025ba:	d102      	bne.n	80025c2 <chOQWriteTimeout+0x22>
 80025bc:	4825      	ldr	r0, [pc, #148]	; (8002654 <chOQWriteTimeout+0xb4>)
 80025be:	f7fe f927 	bl	8000810 <chSysHalt>

  chSysLock();
 80025c2:	f7ff fdad 	bl	8002120 <chSysLock.lto_priv.59>
 80025c6:	e00b      	b.n	80025e0 <chOQWriteTimeout+0x40>
  while (true) {
    while (chOQIsFullI(oqp)) {
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 80025c8:	9b03      	ldr	r3, [sp, #12]
 80025ca:	9900      	ldr	r1, [sp, #0]
 80025cc:	4618      	mov	r0, r3
 80025ce:	f7ff f807 	bl	80015e0 <chThdEnqueueTimeoutS>
 80025d2:	4603      	mov	r3, r0
 80025d4:	2b00      	cmp	r3, #0
 80025d6:	d003      	beq.n	80025e0 <chOQWriteTimeout+0x40>
        chSysUnlock();
 80025d8:	f7ff fdaa 	bl	8002130 <chSysUnlock.lto_priv.18>
        return w;
 80025dc:	9b05      	ldr	r3, [sp, #20]
 80025de:	e034      	b.n	800264a <chOQWriteTimeout+0xaa>
    while (chOQIsFullI(oqp)) {
 80025e0:	9803      	ldr	r0, [sp, #12]
 80025e2:	f7ff fe25 	bl	8002230 <chOQIsFullI.lto_priv.271>
 80025e6:	4603      	mov	r3, r0
 80025e8:	2b00      	cmp	r3, #0
 80025ea:	d1ed      	bne.n	80025c8 <chOQWriteTimeout+0x28>
      }
    }
    
    oqp->q_counter--;
 80025ec:	9b03      	ldr	r3, [sp, #12]
 80025ee:	689b      	ldr	r3, [r3, #8]
 80025f0:	1e5a      	subs	r2, r3, #1
 80025f2:	9b03      	ldr	r3, [sp, #12]
 80025f4:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 80025f6:	9a02      	ldr	r2, [sp, #8]
 80025f8:	1c53      	adds	r3, r2, #1
 80025fa:	9302      	str	r3, [sp, #8]
 80025fc:	9b03      	ldr	r3, [sp, #12]
 80025fe:	695b      	ldr	r3, [r3, #20]
 8002600:	1c58      	adds	r0, r3, #1
 8002602:	9903      	ldr	r1, [sp, #12]
 8002604:	6148      	str	r0, [r1, #20]
 8002606:	7812      	ldrb	r2, [r2, #0]
 8002608:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800260a:	9b03      	ldr	r3, [sp, #12]
 800260c:	695a      	ldr	r2, [r3, #20]
 800260e:	9b03      	ldr	r3, [sp, #12]
 8002610:	691b      	ldr	r3, [r3, #16]
 8002612:	429a      	cmp	r2, r3
 8002614:	d303      	bcc.n	800261e <chOQWriteTimeout+0x7e>
      oqp->q_wrptr = oqp->q_buffer;
 8002616:	9b03      	ldr	r3, [sp, #12]
 8002618:	68da      	ldr	r2, [r3, #12]
 800261a:	9b03      	ldr	r3, [sp, #12]
 800261c:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 800261e:	9b04      	ldr	r3, [sp, #16]
 8002620:	2b00      	cmp	r3, #0
 8002622:	d002      	beq.n	800262a <chOQWriteTimeout+0x8a>
      nfy(oqp);
 8002624:	9b04      	ldr	r3, [sp, #16]
 8002626:	9803      	ldr	r0, [sp, #12]
 8002628:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 800262a:	f7ff fd81 	bl	8002130 <chSysUnlock.lto_priv.18>

    w++;
 800262e:	9b05      	ldr	r3, [sp, #20]
 8002630:	3301      	adds	r3, #1
 8002632:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 8002634:	9b01      	ldr	r3, [sp, #4]
 8002636:	3b01      	subs	r3, #1
 8002638:	9301      	str	r3, [sp, #4]
 800263a:	9b01      	ldr	r3, [sp, #4]
 800263c:	2b00      	cmp	r3, #0
 800263e:	d101      	bne.n	8002644 <chOQWriteTimeout+0xa4>
      return w;
 8002640:	9b05      	ldr	r3, [sp, #20]
 8002642:	e002      	b.n	800264a <chOQWriteTimeout+0xaa>
    }
    chSysLock();
 8002644:	f7ff fd6c 	bl	8002120 <chSysLock.lto_priv.59>
 8002648:	e7ca      	b.n	80025e0 <chOQWriteTimeout+0x40>
  }
}
 800264a:	4618      	mov	r0, r3
 800264c:	b007      	add	sp, #28
 800264e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002652:	bf00      	nop
 8002654:	0800a650 	.word	0x0800a650
	...

08002660 <port_lock.lto_priv.116>:
static inline void port_lock(void) {
 8002660:	b082      	sub	sp, #8
 8002662:	2320      	movs	r3, #32
 8002664:	9301      	str	r3, [sp, #4]
 8002666:	9b01      	ldr	r3, [sp, #4]
 8002668:	f383 8811 	msr	BASEPRI, r3
}
 800266c:	b002      	add	sp, #8
 800266e:	4770      	bx	lr

08002670 <port_unlock.lto_priv.86>:
static inline void port_unlock(void) {
 8002670:	b082      	sub	sp, #8
 8002672:	2300      	movs	r3, #0
 8002674:	9301      	str	r3, [sp, #4]
 8002676:	9b01      	ldr	r3, [sp, #4]
 8002678:	f383 8811 	msr	BASEPRI, r3
}
 800267c:	b002      	add	sp, #8
 800267e:	4770      	bx	lr

08002680 <chSysLock.lto_priv.60>:
static inline void chSysLock(void) {
 8002680:	b508      	push	{r3, lr}
  port_lock();
 8002682:	f7ff ffed 	bl	8002660 <port_lock.lto_priv.116>
  _stats_start_measure_crit_thd();
 8002686:	f7ff f92b 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800268a:	f7fe f949 	bl	8000920 <_dbg_check_lock>
}
 800268e:	bd08      	pop	{r3, pc}

08002690 <chSysUnlock.lto_priv.19>:
static inline void chSysUnlock(void) {
 8002690:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8002692:	f7fe f95d 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8002696:	f7ff f92b 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800269a:	4b09      	ldr	r3, [pc, #36]	; (80026c0 <chSysUnlock.lto_priv.19+0x30>)
 800269c:	681b      	ldr	r3, [r3, #0]
 800269e:	4a08      	ldr	r2, [pc, #32]	; (80026c0 <chSysUnlock.lto_priv.19+0x30>)
 80026a0:	4293      	cmp	r3, r2
 80026a2:	d00a      	beq.n	80026ba <chSysUnlock.lto_priv.19+0x2a>
 80026a4:	4b06      	ldr	r3, [pc, #24]	; (80026c0 <chSysUnlock.lto_priv.19+0x30>)
 80026a6:	699b      	ldr	r3, [r3, #24]
 80026a8:	689a      	ldr	r2, [r3, #8]
 80026aa:	4b05      	ldr	r3, [pc, #20]	; (80026c0 <chSysUnlock.lto_priv.19+0x30>)
 80026ac:	681b      	ldr	r3, [r3, #0]
 80026ae:	689b      	ldr	r3, [r3, #8]
 80026b0:	429a      	cmp	r2, r3
 80026b2:	d202      	bcs.n	80026ba <chSysUnlock.lto_priv.19+0x2a>
 80026b4:	4803      	ldr	r0, [pc, #12]	; (80026c4 <chSysUnlock.lto_priv.19+0x34>)
 80026b6:	f7fe f8ab 	bl	8000810 <chSysHalt>
  port_unlock();
 80026ba:	f7ff ffd9 	bl	8002670 <port_unlock.lto_priv.86>
}
 80026be:	bd08      	pop	{r3, pc}
 80026c0:	20002128 	.word	0x20002128
 80026c4:	0800a670 	.word	0x0800a670
	...

080026d0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 80026d0:	4b06      	ldr	r3, [pc, #24]	; (80026ec <_core_init+0x1c>)
 80026d2:	3307      	adds	r3, #7
 80026d4:	f023 0307 	bic.w	r3, r3, #7
 80026d8:	461a      	mov	r2, r3
 80026da:	4b05      	ldr	r3, [pc, #20]	; (80026f0 <_core_init+0x20>)
 80026dc:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80026de:	4b05      	ldr	r3, [pc, #20]	; (80026f4 <_core_init+0x24>)
 80026e0:	f023 0307 	bic.w	r3, r3, #7
 80026e4:	461a      	mov	r2, r3
 80026e6:	4b04      	ldr	r3, [pc, #16]	; (80026f8 <_core_init+0x28>)
 80026e8:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 80026ea:	4770      	bx	lr
 80026ec:	20003e20 	.word	0x20003e20
 80026f0:	20002380 	.word	0x20002380
 80026f4:	20020000 	.word	0x20020000
 80026f8:	20002384 	.word	0x20002384
 80026fc:	00000000 	.word	0x00000000

08002700 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8002700:	b500      	push	{lr}
 8002702:	b085      	sub	sp, #20
 8002704:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8002706:	f7ff ffbb 	bl	8002680 <chSysLock.lto_priv.60>
  p = chCoreAllocI(size);
 800270a:	9801      	ldr	r0, [sp, #4]
 800270c:	f000 f808 	bl	8002720 <chCoreAllocI>
 8002710:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8002712:	f7ff ffbd 	bl	8002690 <chSysUnlock.lto_priv.19>

  return p;
 8002716:	9b03      	ldr	r3, [sp, #12]
}
 8002718:	4618      	mov	r0, r3
 800271a:	b005      	add	sp, #20
 800271c:	f85d fb04 	ldr.w	pc, [sp], #4

08002720 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8002720:	b500      	push	{lr}
 8002722:	b085      	sub	sp, #20
 8002724:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();
 8002726:	f7fe f99b 	bl	8000a60 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
 800272a:	9b01      	ldr	r3, [sp, #4]
 800272c:	3307      	adds	r3, #7
 800272e:	f023 0307 	bic.w	r3, r3, #7
 8002732:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8002734:	4b0c      	ldr	r3, [pc, #48]	; (8002768 <chCoreAllocI+0x48>)
 8002736:	681b      	ldr	r3, [r3, #0]
 8002738:	461a      	mov	r2, r3
 800273a:	4b0c      	ldr	r3, [pc, #48]	; (800276c <chCoreAllocI+0x4c>)
 800273c:	681b      	ldr	r3, [r3, #0]
 800273e:	1ad3      	subs	r3, r2, r3
 8002740:	461a      	mov	r2, r3
 8002742:	9b01      	ldr	r3, [sp, #4]
 8002744:	4293      	cmp	r3, r2
 8002746:	d901      	bls.n	800274c <chCoreAllocI+0x2c>
  /*lint -restore*/
    return NULL;
 8002748:	2300      	movs	r3, #0
 800274a:	e009      	b.n	8002760 <chCoreAllocI+0x40>
  }
  p = nextmem;
 800274c:	4b07      	ldr	r3, [pc, #28]	; (800276c <chCoreAllocI+0x4c>)
 800274e:	681b      	ldr	r3, [r3, #0]
 8002750:	9303      	str	r3, [sp, #12]
  nextmem += size;
 8002752:	4b06      	ldr	r3, [pc, #24]	; (800276c <chCoreAllocI+0x4c>)
 8002754:	681a      	ldr	r2, [r3, #0]
 8002756:	9b01      	ldr	r3, [sp, #4]
 8002758:	4413      	add	r3, r2
 800275a:	4a04      	ldr	r2, [pc, #16]	; (800276c <chCoreAllocI+0x4c>)
 800275c:	6013      	str	r3, [r2, #0]

  return p;
 800275e:	9b03      	ldr	r3, [sp, #12]
}
 8002760:	4618      	mov	r0, r3
 8002762:	b005      	add	sp, #20
 8002764:	f85d fb04 	ldr.w	pc, [sp], #4
 8002768:	20002384 	.word	0x20002384
 800276c:	20002380 	.word	0x20002380

08002770 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8002770:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 8002772:	4b06      	ldr	r3, [pc, #24]	; (800278c <_heap_init+0x1c>)
 8002774:	4a06      	ldr	r2, [pc, #24]	; (8002790 <_heap_init+0x20>)
 8002776:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 8002778:	4b04      	ldr	r3, [pc, #16]	; (800278c <_heap_init+0x1c>)
 800277a:	2200      	movs	r2, #0
 800277c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 800277e:	4b03      	ldr	r3, [pc, #12]	; (800278c <_heap_init+0x1c>)
 8002780:	2200      	movs	r2, #0
 8002782:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8002784:	4803      	ldr	r0, [pc, #12]	; (8002794 <_heap_init+0x24>)
 8002786:	f7ff f983 	bl	8001a90 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 800278a:	bd08      	pop	{r3, pc}
 800278c:	20002388 	.word	0x20002388
 8002790:	08002701 	.word	0x08002701
 8002794:	20002398 	.word	0x20002398
	...

080027a0 <port_lock.lto_priv.117>:
static inline void port_lock(void) {
 80027a0:	b082      	sub	sp, #8
 80027a2:	2320      	movs	r3, #32
 80027a4:	9301      	str	r3, [sp, #4]
 80027a6:	9b01      	ldr	r3, [sp, #4]
 80027a8:	f383 8811 	msr	BASEPRI, r3
}
 80027ac:	b002      	add	sp, #8
 80027ae:	4770      	bx	lr

080027b0 <port_unlock.lto_priv.87>:
static inline void port_unlock(void) {
 80027b0:	b082      	sub	sp, #8
 80027b2:	2300      	movs	r3, #0
 80027b4:	9301      	str	r3, [sp, #4]
 80027b6:	9b01      	ldr	r3, [sp, #4]
 80027b8:	f383 8811 	msr	BASEPRI, r3
}
 80027bc:	b002      	add	sp, #8
 80027be:	4770      	bx	lr

080027c0 <chSysLock.lto_priv.61>:
static inline void chSysLock(void) {
 80027c0:	b508      	push	{r3, lr}
  port_lock();
 80027c2:	f7ff ffed 	bl	80027a0 <port_lock.lto_priv.117>
  _stats_start_measure_crit_thd();
 80027c6:	f7ff f88b 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80027ca:	f7fe f8a9 	bl	8000920 <_dbg_check_lock>
}
 80027ce:	bd08      	pop	{r3, pc}

080027d0 <chSysUnlock.lto_priv.20>:
static inline void chSysUnlock(void) {
 80027d0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80027d2:	f7fe f8bd 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80027d6:	f7ff f88b 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80027da:	4b09      	ldr	r3, [pc, #36]	; (8002800 <chSysUnlock.lto_priv.20+0x30>)
 80027dc:	681b      	ldr	r3, [r3, #0]
 80027de:	4a08      	ldr	r2, [pc, #32]	; (8002800 <chSysUnlock.lto_priv.20+0x30>)
 80027e0:	4293      	cmp	r3, r2
 80027e2:	d00a      	beq.n	80027fa <chSysUnlock.lto_priv.20+0x2a>
 80027e4:	4b06      	ldr	r3, [pc, #24]	; (8002800 <chSysUnlock.lto_priv.20+0x30>)
 80027e6:	699b      	ldr	r3, [r3, #24]
 80027e8:	689a      	ldr	r2, [r3, #8]
 80027ea:	4b05      	ldr	r3, [pc, #20]	; (8002800 <chSysUnlock.lto_priv.20+0x30>)
 80027ec:	681b      	ldr	r3, [r3, #0]
 80027ee:	689b      	ldr	r3, [r3, #8]
 80027f0:	429a      	cmp	r2, r3
 80027f2:	d202      	bcs.n	80027fa <chSysUnlock.lto_priv.20+0x2a>
 80027f4:	4803      	ldr	r0, [pc, #12]	; (8002804 <chSysUnlock.lto_priv.20+0x34>)
 80027f6:	f7fe f80b 	bl	8000810 <chSysHalt>
  port_unlock();
 80027fa:	f7ff ffd9 	bl	80027b0 <port_unlock.lto_priv.87>
}
 80027fe:	bd08      	pop	{r3, pc}
 8002800:	20002128 	.word	0x20002128
 8002804:	0800a6c0 	.word	0x0800a6c0
	...

08002810 <chPoolAdd>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
 8002810:	b500      	push	{lr}
 8002812:	b083      	sub	sp, #12
 8002814:	9001      	str	r0, [sp, #4]
 8002816:	9100      	str	r1, [sp, #0]

  chPoolFree(mp, objp);
 8002818:	9900      	ldr	r1, [sp, #0]
 800281a:	9801      	ldr	r0, [sp, #4]
 800281c:	f000 f8b0 	bl	8002980 <chPoolFree>
}
 8002820:	b003      	add	sp, #12
 8002822:	f85d fb04 	ldr.w	pc, [sp], #4
 8002826:	bf00      	nop
	...

08002830 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
 8002830:	b500      	push	{lr}
 8002832:	b085      	sub	sp, #20
 8002834:	9003      	str	r0, [sp, #12]
 8002836:	9102      	str	r1, [sp, #8]
 8002838:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
 800283a:	9b03      	ldr	r3, [sp, #12]
 800283c:	2b00      	cmp	r3, #0
 800283e:	d002      	beq.n	8002846 <chPoolObjectInit+0x16>
 8002840:	9b02      	ldr	r3, [sp, #8]
 8002842:	2b03      	cmp	r3, #3
 8002844:	d802      	bhi.n	800284c <chPoolObjectInit+0x1c>
 8002846:	4807      	ldr	r0, [pc, #28]	; (8002864 <chPoolObjectInit+0x34>)
 8002848:	f7fd ffe2 	bl	8000810 <chSysHalt>

  mp->mp_next = NULL;
 800284c:	9b03      	ldr	r3, [sp, #12]
 800284e:	2200      	movs	r2, #0
 8002850:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 8002852:	9b03      	ldr	r3, [sp, #12]
 8002854:	9a02      	ldr	r2, [sp, #8]
 8002856:	605a      	str	r2, [r3, #4]
  mp->mp_provider = provider;
 8002858:	9b03      	ldr	r3, [sp, #12]
 800285a:	9a01      	ldr	r2, [sp, #4]
 800285c:	609a      	str	r2, [r3, #8]
}
 800285e:	b005      	add	sp, #20
 8002860:	f85d fb04 	ldr.w	pc, [sp], #4
 8002864:	0800a680 	.word	0x0800a680
	...

08002870 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8002870:	b500      	push	{lr}
 8002872:	b085      	sub	sp, #20
 8002874:	9003      	str	r0, [sp, #12]
 8002876:	9102      	str	r1, [sp, #8]
 8002878:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (n != 0U));
 800287a:	9b03      	ldr	r3, [sp, #12]
 800287c:	2b00      	cmp	r3, #0
 800287e:	d002      	beq.n	8002886 <chPoolLoadArray+0x16>
 8002880:	9b01      	ldr	r3, [sp, #4]
 8002882:	2b00      	cmp	r3, #0
 8002884:	d10f      	bne.n	80028a6 <chPoolLoadArray+0x36>
 8002886:	480b      	ldr	r0, [pc, #44]	; (80028b4 <chPoolLoadArray+0x44>)
 8002888:	f7fd ffc2 	bl	8000810 <chSysHalt>
 800288c:	e00b      	b.n	80028a6 <chPoolLoadArray+0x36>

  while (n != 0U) {
    chPoolAdd(mp, p);
 800288e:	9902      	ldr	r1, [sp, #8]
 8002890:	9803      	ldr	r0, [sp, #12]
 8002892:	f7ff ffbd 	bl	8002810 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8002896:	9b03      	ldr	r3, [sp, #12]
 8002898:	685b      	ldr	r3, [r3, #4]
 800289a:	9a02      	ldr	r2, [sp, #8]
 800289c:	4413      	add	r3, r2
 800289e:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
 80028a0:	9b01      	ldr	r3, [sp, #4]
 80028a2:	3b01      	subs	r3, #1
 80028a4:	9301      	str	r3, [sp, #4]
  while (n != 0U) {
 80028a6:	9b01      	ldr	r3, [sp, #4]
 80028a8:	2b00      	cmp	r3, #0
 80028aa:	d1f0      	bne.n	800288e <chPoolLoadArray+0x1e>
  }
}
 80028ac:	b005      	add	sp, #20
 80028ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80028b2:	bf00      	nop
 80028b4:	0800a6a0 	.word	0x0800a6a0
	...

080028c0 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
 80028c0:	b500      	push	{lr}
 80028c2:	b085      	sub	sp, #20
 80028c4:	9001      	str	r0, [sp, #4]
  void *objp;

  chDbgCheckClassI();
 80028c6:	f7fe f8cb 	bl	8000a60 <chDbgCheckClassI>
  chDbgCheck(mp != NULL);
 80028ca:	9b01      	ldr	r3, [sp, #4]
 80028cc:	2b00      	cmp	r3, #0
 80028ce:	d102      	bne.n	80028d6 <chPoolAllocI+0x16>
 80028d0:	480f      	ldr	r0, [pc, #60]	; (8002910 <chPoolAllocI+0x50>)
 80028d2:	f7fd ff9d 	bl	8000810 <chSysHalt>

  objp = mp->mp_next;
 80028d6:	9b01      	ldr	r3, [sp, #4]
 80028d8:	681b      	ldr	r3, [r3, #0]
 80028da:	9303      	str	r3, [sp, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 80028dc:	9b03      	ldr	r3, [sp, #12]
 80028de:	2b00      	cmp	r3, #0
 80028e0:	d005      	beq.n	80028ee <chPoolAllocI+0x2e>
    mp->mp_next = mp->mp_next->ph_next;
 80028e2:	9b01      	ldr	r3, [sp, #4]
 80028e4:	681b      	ldr	r3, [r3, #0]
 80028e6:	681a      	ldr	r2, [r3, #0]
 80028e8:	9b01      	ldr	r3, [sp, #4]
 80028ea:	601a      	str	r2, [r3, #0]
 80028ec:	e00a      	b.n	8002904 <chPoolAllocI+0x44>
  }
  else if (mp->mp_provider != NULL) {
 80028ee:	9b01      	ldr	r3, [sp, #4]
 80028f0:	689b      	ldr	r3, [r3, #8]
 80028f2:	2b00      	cmp	r3, #0
 80028f4:	d006      	beq.n	8002904 <chPoolAllocI+0x44>
    objp = mp->mp_provider(mp->mp_object_size);
 80028f6:	9b01      	ldr	r3, [sp, #4]
 80028f8:	689b      	ldr	r3, [r3, #8]
 80028fa:	9a01      	ldr	r2, [sp, #4]
 80028fc:	6852      	ldr	r2, [r2, #4]
 80028fe:	4610      	mov	r0, r2
 8002900:	4798      	blx	r3
 8002902:	9003      	str	r0, [sp, #12]
  }
  /*lint -restore*/

  return objp;
 8002904:	9b03      	ldr	r3, [sp, #12]
}
 8002906:	4618      	mov	r0, r3
 8002908:	b005      	add	sp, #20
 800290a:	f85d fb04 	ldr.w	pc, [sp], #4
 800290e:	bf00      	nop
 8002910:	0800a6b0 	.word	0x0800a6b0
	...

08002920 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8002920:	b500      	push	{lr}
 8002922:	b085      	sub	sp, #20
 8002924:	9001      	str	r0, [sp, #4]
  void *objp;

  chSysLock();
 8002926:	f7ff ff4b 	bl	80027c0 <chSysLock.lto_priv.61>
  objp = chPoolAllocI(mp);
 800292a:	9801      	ldr	r0, [sp, #4]
 800292c:	f7ff ffc8 	bl	80028c0 <chPoolAllocI>
 8002930:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8002932:	f7ff ff4d 	bl	80027d0 <chSysUnlock.lto_priv.20>

  return objp;
 8002936:	9b03      	ldr	r3, [sp, #12]
}
 8002938:	4618      	mov	r0, r3
 800293a:	b005      	add	sp, #20
 800293c:	f85d fb04 	ldr.w	pc, [sp], #4

08002940 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8002940:	b500      	push	{lr}
 8002942:	b085      	sub	sp, #20
 8002944:	9001      	str	r0, [sp, #4]
 8002946:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8002948:	9b00      	ldr	r3, [sp, #0]
 800294a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 800294c:	f7fe f888 	bl	8000a60 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8002950:	9b01      	ldr	r3, [sp, #4]
 8002952:	2b00      	cmp	r3, #0
 8002954:	d002      	beq.n	800295c <chPoolFreeI+0x1c>
 8002956:	9b00      	ldr	r3, [sp, #0]
 8002958:	2b00      	cmp	r3, #0
 800295a:	d102      	bne.n	8002962 <chPoolFreeI+0x22>
 800295c:	4806      	ldr	r0, [pc, #24]	; (8002978 <chPoolFreeI+0x38>)
 800295e:	f7fd ff57 	bl	8000810 <chSysHalt>

  php->ph_next = mp->mp_next;
 8002962:	9b01      	ldr	r3, [sp, #4]
 8002964:	681a      	ldr	r2, [r3, #0]
 8002966:	9b03      	ldr	r3, [sp, #12]
 8002968:	601a      	str	r2, [r3, #0]
  mp->mp_next = php;
 800296a:	9b01      	ldr	r3, [sp, #4]
 800296c:	9a03      	ldr	r2, [sp, #12]
 800296e:	601a      	str	r2, [r3, #0]
}
 8002970:	b005      	add	sp, #20
 8002972:	f85d fb04 	ldr.w	pc, [sp], #4
 8002976:	bf00      	nop
 8002978:	0800a6d0 	.word	0x0800a6d0
 800297c:	00000000 	.word	0x00000000

08002980 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8002980:	b500      	push	{lr}
 8002982:	b083      	sub	sp, #12
 8002984:	9001      	str	r0, [sp, #4]
 8002986:	9100      	str	r1, [sp, #0]

  chSysLock();
 8002988:	f7ff ff1a 	bl	80027c0 <chSysLock.lto_priv.61>
  chPoolFreeI(mp, objp);
 800298c:	9900      	ldr	r1, [sp, #0]
 800298e:	9801      	ldr	r0, [sp, #4]
 8002990:	f7ff ffd6 	bl	8002940 <chPoolFreeI>
  chSysUnlock();
 8002994:	f7ff ff1c 	bl	80027d0 <chSysUnlock.lto_priv.20>
}
 8002998:	b003      	add	sp, #12
 800299a:	f85d fb04 	ldr.w	pc, [sp], #4
 800299e:	bf00      	nop

080029a0 <port_lock.lto_priv.118>:
static inline void port_lock(void) {
 80029a0:	b082      	sub	sp, #8
 80029a2:	2320      	movs	r3, #32
 80029a4:	9301      	str	r3, [sp, #4]
 80029a6:	9b01      	ldr	r3, [sp, #4]
 80029a8:	f383 8811 	msr	BASEPRI, r3
}
 80029ac:	b002      	add	sp, #8
 80029ae:	4770      	bx	lr

080029b0 <port_unlock.lto_priv.88>:
static inline void port_unlock(void) {
 80029b0:	b082      	sub	sp, #8
 80029b2:	2300      	movs	r3, #0
 80029b4:	9301      	str	r3, [sp, #4]
 80029b6:	9b01      	ldr	r3, [sp, #4]
 80029b8:	f383 8811 	msr	BASEPRI, r3
}
 80029bc:	b002      	add	sp, #8
 80029be:	4770      	bx	lr

080029c0 <port_lock_from_isr.lto_priv.185>:
static inline void port_lock_from_isr(void) {
 80029c0:	b508      	push	{r3, lr}
  port_lock();
 80029c2:	f7ff ffed 	bl	80029a0 <port_lock.lto_priv.118>
}
 80029c6:	bd08      	pop	{r3, pc}
	...

080029d0 <port_unlock_from_isr.lto_priv.172>:
static inline void port_unlock_from_isr(void) {
 80029d0:	b508      	push	{r3, lr}
  port_unlock();
 80029d2:	f7ff ffed 	bl	80029b0 <port_unlock.lto_priv.88>
}
 80029d6:	bd08      	pop	{r3, pc}
	...

080029e0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 80029e0:	b590      	push	{r4, r7, lr}
 80029e2:	b083      	sub	sp, #12
 80029e4:	af00      	add	r7, sp, #0
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 80029e6:	4b0c      	ldr	r3, [pc, #48]	; (8002a18 <SVC_Handler+0x38>)
 80029e8:	685b      	ldr	r3, [r3, #4]
 80029ea:	4a0b      	ldr	r2, [pc, #44]	; (8002a18 <SVC_Handler+0x38>)
 80029ec:	f023 0301 	bic.w	r3, r3, #1
 80029f0:	6053      	str	r3, [r2, #4]
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80029f2:	f3ef 8309 	mrs	r3, PSP
 80029f6:	461c      	mov	r4, r3
  return(result);
 80029f8:	4623      	mov	r3, r4
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 80029fa:	607b      	str	r3, [r7, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80029fc:	687b      	ldr	r3, [r7, #4]
 80029fe:	3368      	adds	r3, #104	; 0x68
 8002a00:	607b      	str	r3, [r7, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8002a02:	687b      	ldr	r3, [r7, #4]
 8002a04:	603b      	str	r3, [r7, #0]
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8002a06:	683b      	ldr	r3, [r7, #0]
 8002a08:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8002a0c:	f7ff ffe0 	bl	80029d0 <port_unlock_from_isr.lto_priv.172>
}
 8002a10:	370c      	adds	r7, #12
 8002a12:	46bd      	mov	sp, r7
 8002a14:	bd90      	pop	{r4, r7, pc}
 8002a16:	bf00      	nop
 8002a18:	e000ef30 	.word	0xe000ef30
 8002a1c:	00000000 	.word	0x00000000

08002a20 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8002a20:	b590      	push	{r4, r7, lr}
 8002a22:	b085      	sub	sp, #20
 8002a24:	af00      	add	r7, sp, #0

  port_lock_from_isr();
 8002a26:	f7ff ffcb 	bl	80029c0 <port_lock_from_isr.lto_priv.185>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8002a2a:	4b18      	ldr	r3, [pc, #96]	; (8002a8c <_port_irq_epilogue+0x6c>)
 8002a2c:	685b      	ldr	r3, [r3, #4]
 8002a2e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8002a32:	2b00      	cmp	r3, #0
 8002a34:	d025      	beq.n	8002a82 <_port_irq_epilogue+0x62>
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8002a36:	eef1 3a10 	vmrs	r3, fpscr
 8002a3a:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8002a3c:	f3ef 8309 	mrs	r3, PSP
 8002a40:	461c      	mov	r4, r3
  return(result);
 8002a42:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8002a44:	60fb      	str	r3, [r7, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8002a46:	68fb      	ldr	r3, [r7, #12]
 8002a48:	3b68      	subs	r3, #104	; 0x68
 8002a4a:	60fb      	str	r3, [r7, #12]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8002a4c:	68fb      	ldr	r3, [r7, #12]
 8002a4e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8002a52:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8002a54:	4b0e      	ldr	r3, [pc, #56]	; (8002a90 <_port_irq_epilogue+0x70>)
 8002a56:	68db      	ldr	r3, [r3, #12]
 8002a58:	461a      	mov	r2, r3
 8002a5a:	68fb      	ldr	r3, [r7, #12]
 8002a5c:	661a      	str	r2, [r3, #96]	; 0x60
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8002a5e:	68fb      	ldr	r3, [r7, #12]
 8002a60:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8002a62:	68bb      	ldr	r3, [r7, #8]
 8002a64:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8002a68:	f7fe fada 	bl	8001020 <chSchIsPreemptionRequired>
 8002a6c:	4603      	mov	r3, r0
 8002a6e:	2b00      	cmp	r3, #0
 8002a70:	d003      	beq.n	8002a7a <_port_irq_epilogue+0x5a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8002a72:	68fb      	ldr	r3, [r7, #12]
 8002a74:	4a07      	ldr	r2, [pc, #28]	; (8002a94 <_port_irq_epilogue+0x74>)
 8002a76:	619a      	str	r2, [r3, #24]
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8002a78:	e005      	b.n	8002a86 <_port_irq_epilogue+0x66>
 8002a7a:	68fb      	ldr	r3, [r7, #12]
 8002a7c:	4a06      	ldr	r2, [pc, #24]	; (8002a98 <_port_irq_epilogue+0x78>)
 8002a7e:	619a      	str	r2, [r3, #24]
 8002a80:	e001      	b.n	8002a86 <_port_irq_epilogue+0x66>

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 8002a82:	f7ff ffa5 	bl	80029d0 <port_unlock_from_isr.lto_priv.172>
}
 8002a86:	3714      	adds	r7, #20
 8002a88:	46bd      	mov	sp, r7
 8002a8a:	bd90      	pop	{r4, r7, pc}
 8002a8c:	e000ed00 	.word	0xe000ed00
 8002a90:	e000ef30 	.word	0xe000ef30
 8002a94:	08000301 	.word	0x08000301
 8002a98:	08000314 	.word	0x08000314
 8002a9c:	00000000 	.word	0x00000000

08002aa0 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8002aa0:	4770      	bx	lr
 8002aa2:	bf00      	nop
	...

08002ab0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8002ab0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8002ab2:	f7ff fff5 	bl	8002aa0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8002ab6:	f003 f973 	bl	8005da0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8002aba:	4809      	ldr	r0, [pc, #36]	; (8002ae0 <halInit+0x30>)
 8002abc:	f003 fd70 	bl	80065a0 <_pal_lld_init>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
 8002ac0:	f000 fe0e 	bl	80036e0 <i2cInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8002ac4:	f001 fcec 	bl	80044a0 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
 8002ac8:	f001 f99a 	bl	8003e00 <sdcInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8002acc:	f002 fc60 	bl	8005390 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 8002ad0:	f001 ffae 	bl	8004a30 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8002ad4:	f006 fbc4 	bl	8009260 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8002ad8:	f000 f80a 	bl	8002af0 <stInit>
#endif
}
 8002adc:	bd08      	pop	{r3, pc}
 8002ade:	bf00      	nop
 8002ae0:	0800acb0 	.word	0x0800acb0
	...

08002af0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8002af0:	b508      	push	{r3, lr}

  st_lld_init();
 8002af2:	f003 fd15 	bl	8006520 <st_lld_init>
}
 8002af6:	bd08      	pop	{r3, pc}
	...

08002b00 <port_lock.lto_priv.119>:
static inline void port_lock(void) {
 8002b00:	b082      	sub	sp, #8
 8002b02:	2320      	movs	r3, #32
 8002b04:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002b06:	9b01      	ldr	r3, [sp, #4]
 8002b08:	f383 8811 	msr	BASEPRI, r3
}
 8002b0c:	b002      	add	sp, #8
 8002b0e:	4770      	bx	lr

08002b10 <port_unlock.lto_priv.89>:
static inline void port_unlock(void) {
 8002b10:	b082      	sub	sp, #8
 8002b12:	2300      	movs	r3, #0
 8002b14:	9301      	str	r3, [sp, #4]
 8002b16:	9b01      	ldr	r3, [sp, #4]
 8002b18:	f383 8811 	msr	BASEPRI, r3
}
 8002b1c:	b002      	add	sp, #8
 8002b1e:	4770      	bx	lr

08002b20 <queue_init.lto_priv.289>:
static inline void queue_init(threads_queue_t *tqp) {
 8002b20:	b082      	sub	sp, #8
 8002b22:	9001      	str	r0, [sp, #4]
  tqp->p_next = (thread_t *)tqp;
 8002b24:	9b01      	ldr	r3, [sp, #4]
 8002b26:	9a01      	ldr	r2, [sp, #4]
 8002b28:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002b2a:	9b01      	ldr	r3, [sp, #4]
 8002b2c:	9a01      	ldr	r2, [sp, #4]
 8002b2e:	605a      	str	r2, [r3, #4]
}
 8002b30:	b002      	add	sp, #8
 8002b32:	4770      	bx	lr
	...

08002b40 <chSysLock.lto_priv.62>:
static inline void chSysLock(void) {
 8002b40:	b508      	push	{r3, lr}
  port_lock();
 8002b42:	f7ff ffdd 	bl	8002b00 <port_lock.lto_priv.119>
  _stats_start_measure_crit_thd();
 8002b46:	f7fe fecb 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8002b4a:	f7fd fee9 	bl	8000920 <_dbg_check_lock>
}
 8002b4e:	bd08      	pop	{r3, pc}

08002b50 <chSysUnlock.lto_priv.21>:
static inline void chSysUnlock(void) {
 8002b50:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8002b52:	f7fd fefd 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8002b56:	f7fe fecb 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002b5a:	4b09      	ldr	r3, [pc, #36]	; (8002b80 <chSysUnlock.lto_priv.21+0x30>)
 8002b5c:	681b      	ldr	r3, [r3, #0]
 8002b5e:	4a08      	ldr	r2, [pc, #32]	; (8002b80 <chSysUnlock.lto_priv.21+0x30>)
 8002b60:	4293      	cmp	r3, r2
 8002b62:	d00a      	beq.n	8002b7a <chSysUnlock.lto_priv.21+0x2a>
 8002b64:	4b06      	ldr	r3, [pc, #24]	; (8002b80 <chSysUnlock.lto_priv.21+0x30>)
 8002b66:	699b      	ldr	r3, [r3, #24]
 8002b68:	689a      	ldr	r2, [r3, #8]
 8002b6a:	4b05      	ldr	r3, [pc, #20]	; (8002b80 <chSysUnlock.lto_priv.21+0x30>)
 8002b6c:	681b      	ldr	r3, [r3, #0]
 8002b6e:	689b      	ldr	r3, [r3, #8]
 8002b70:	429a      	cmp	r2, r3
 8002b72:	d202      	bcs.n	8002b7a <chSysUnlock.lto_priv.21+0x2a>
 8002b74:	4803      	ldr	r0, [pc, #12]	; (8002b84 <chSysUnlock.lto_priv.21+0x34>)
 8002b76:	f7fd fe4b 	bl	8000810 <chSysHalt>
  port_unlock();
 8002b7a:	f7ff ffc9 	bl	8002b10 <port_unlock.lto_priv.89>
}
 8002b7e:	bd08      	pop	{r3, pc}
 8002b80:	20002128 	.word	0x20002128
 8002b84:	0800a710 	.word	0x0800a710
	...

08002b90 <chVTGetSystemTimeX.lto_priv.5>:
  return ch.vtlist.vt_systime;
 8002b90:	4b01      	ldr	r3, [pc, #4]	; (8002b98 <chVTGetSystemTimeX.lto_priv.5+0x8>)
 8002b92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
 8002b94:	4618      	mov	r0, r3
 8002b96:	4770      	bx	lr
 8002b98:	20002128 	.word	0x20002128
 8002b9c:	00000000 	.word	0x00000000

08002ba0 <chThdQueueObjectInit.lto_priv.281>:
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8002ba0:	b500      	push	{lr}
 8002ba2:	b083      	sub	sp, #12
 8002ba4:	9001      	str	r0, [sp, #4]
  queue_init(tqp);
 8002ba6:	9801      	ldr	r0, [sp, #4]
 8002ba8:	f7ff ffba 	bl	8002b20 <queue_init.lto_priv.289>
}
 8002bac:	b003      	add	sp, #12
 8002bae:	f85d fb04 	ldr.w	pc, [sp], #4
 8002bb2:	bf00      	nop
	...

08002bc0 <osalSysLock.lto_priv.228>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8002bc0:	b508      	push	{r3, lr}

  chSysLock();
 8002bc2:	f7ff ffbd 	bl	8002b40 <chSysLock.lto_priv.62>
}
 8002bc6:	bd08      	pop	{r3, pc}
	...

08002bd0 <osalSysUnlock.lto_priv.219>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8002bd0:	b508      	push	{r3, lr}

  chSysUnlock();
 8002bd2:	f7ff ffbd 	bl	8002b50 <chSysUnlock.lto_priv.21>
}
 8002bd6:	bd08      	pop	{r3, pc}
	...

08002be0 <osalOsGetSystemTimeX.lto_priv.246>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 8002be0:	b508      	push	{r3, lr}

  return chVTGetSystemTimeX();
 8002be2:	f7ff ffd5 	bl	8002b90 <chVTGetSystemTimeX.lto_priv.5>
 8002be6:	4603      	mov	r3, r0
}
 8002be8:	4618      	mov	r0, r3
 8002bea:	bd08      	pop	{r3, pc}
 8002bec:	0000      	movs	r0, r0
	...

08002bf0 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8002bf0:	b500      	push	{lr}
 8002bf2:	b083      	sub	sp, #12
 8002bf4:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8002bf6:	9801      	ldr	r0, [sp, #4]
 8002bf8:	f7ff ffd2 	bl	8002ba0 <chThdQueueObjectInit.lto_priv.281>
}
 8002bfc:	b003      	add	sp, #12
 8002bfe:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c02:	bf00      	nop
	...

08002c10 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 8002c10:	b500      	push	{lr}
 8002c12:	b083      	sub	sp, #12
 8002c14:	9001      	str	r0, [sp, #4]
 8002c16:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 8002c18:	9900      	ldr	r1, [sp, #0]
 8002c1a:	9801      	ldr	r0, [sp, #4]
 8002c1c:	f7fe fce0 	bl	80015e0 <chThdEnqueueTimeoutS>
 8002c20:	4603      	mov	r3, r0
}
 8002c22:	4618      	mov	r0, r3
 8002c24:	b003      	add	sp, #12
 8002c26:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c2a:	bf00      	nop
 8002c2c:	0000      	movs	r0, r0
	...

08002c30 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8002c30:	b500      	push	{lr}
 8002c32:	b083      	sub	sp, #12
 8002c34:	9001      	str	r0, [sp, #4]
 8002c36:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8002c38:	9900      	ldr	r1, [sp, #0]
 8002c3a:	9801      	ldr	r0, [sp, #4]
 8002c3c:	f7fe fcf0 	bl	8001620 <chThdDequeueNextI>
}
 8002c40:	b003      	add	sp, #12
 8002c42:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c46:	bf00      	nop
	...

08002c50 <osalThreadDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8002c50:	b500      	push	{lr}
 8002c52:	b083      	sub	sp, #12
 8002c54:	9001      	str	r0, [sp, #4]
 8002c56:	9100      	str	r1, [sp, #0]

  chThdDequeueAllI(tqp, msg);
 8002c58:	9900      	ldr	r1, [sp, #0]
 8002c5a:	9801      	ldr	r0, [sp, #4]
 8002c5c:	f7fe fcf8 	bl	8001650 <chThdDequeueAllI>
}
 8002c60:	b003      	add	sp, #12
 8002c62:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c66:	bf00      	nop
	...

08002c70 <ibqObjectInit>:
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t infy, void *link) {
 8002c70:	b500      	push	{lr}
 8002c72:	b085      	sub	sp, #20
 8002c74:	9003      	str	r0, [sp, #12]
 8002c76:	9102      	str	r1, [sp, #8]
 8002c78:	9201      	str	r2, [sp, #4]
 8002c7a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));
 8002c7c:	9b03      	ldr	r3, [sp, #12]
 8002c7e:	2b00      	cmp	r3, #0
 8002c80:	d005      	beq.n	8002c8e <ibqObjectInit+0x1e>
 8002c82:	9b02      	ldr	r3, [sp, #8]
 8002c84:	2b00      	cmp	r3, #0
 8002c86:	d002      	beq.n	8002c8e <ibqObjectInit+0x1e>
 8002c88:	9b01      	ldr	r3, [sp, #4]
 8002c8a:	2b01      	cmp	r3, #1
 8002c8c:	d802      	bhi.n	8002c94 <ibqObjectInit+0x24>
 8002c8e:	4819      	ldr	r0, [pc, #100]	; (8002cf4 <ibqObjectInit+0x84>)
 8002c90:	f7fd fdbe 	bl	8000810 <chSysHalt>

  osalThreadQueueObjectInit(&ibqp->waiting);
 8002c94:	9b03      	ldr	r3, [sp, #12]
 8002c96:	4618      	mov	r0, r3
 8002c98:	f7ff ffaa 	bl	8002bf0 <osalThreadQueueObjectInit>
  ibqp->bcounter = 0;
 8002c9c:	9b03      	ldr	r3, [sp, #12]
 8002c9e:	2200      	movs	r2, #0
 8002ca0:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = bp;
 8002ca2:	9b03      	ldr	r3, [sp, #12]
 8002ca4:	9a02      	ldr	r2, [sp, #8]
 8002ca6:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = bp;
 8002ca8:	9b03      	ldr	r3, [sp, #12]
 8002caa:	9a02      	ldr	r2, [sp, #8]
 8002cac:	60da      	str	r2, [r3, #12]
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 8002cae:	9b01      	ldr	r3, [sp, #4]
 8002cb0:	3304      	adds	r3, #4
 8002cb2:	9a00      	ldr	r2, [sp, #0]
 8002cb4:	fb02 f303 	mul.w	r3, r2, r3
 8002cb8:	9a02      	ldr	r2, [sp, #8]
 8002cba:	441a      	add	r2, r3
 8002cbc:	9b03      	ldr	r3, [sp, #12]
 8002cbe:	615a      	str	r2, [r3, #20]
  ibqp->bsize    = size + sizeof (size_t);
 8002cc0:	9b01      	ldr	r3, [sp, #4]
 8002cc2:	1d1a      	adds	r2, r3, #4
 8002cc4:	9b03      	ldr	r3, [sp, #12]
 8002cc6:	619a      	str	r2, [r3, #24]
  ibqp->bn       = n;
 8002cc8:	9b03      	ldr	r3, [sp, #12]
 8002cca:	9a00      	ldr	r2, [sp, #0]
 8002ccc:	61da      	str	r2, [r3, #28]
  ibqp->buffers  = bp;
 8002cce:	9b03      	ldr	r3, [sp, #12]
 8002cd0:	9a02      	ldr	r2, [sp, #8]
 8002cd2:	621a      	str	r2, [r3, #32]
  ibqp->ptr      = NULL;
 8002cd4:	9b03      	ldr	r3, [sp, #12]
 8002cd6:	2200      	movs	r2, #0
 8002cd8:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 8002cda:	9b03      	ldr	r3, [sp, #12]
 8002cdc:	2200      	movs	r2, #0
 8002cde:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->notify   = infy;
 8002ce0:	9b03      	ldr	r3, [sp, #12]
 8002ce2:	9a06      	ldr	r2, [sp, #24]
 8002ce4:	62da      	str	r2, [r3, #44]	; 0x2c
  ibqp->link     = link;
 8002ce6:	9b03      	ldr	r3, [sp, #12]
 8002ce8:	9a07      	ldr	r2, [sp, #28]
 8002cea:	631a      	str	r2, [r3, #48]	; 0x30
}
 8002cec:	b005      	add	sp, #20
 8002cee:	f85d fb04 	ldr.w	pc, [sp], #4
 8002cf2:	bf00      	nop
 8002cf4:	0800a6e0 	.word	0x0800a6e0
	...

08002d00 <ibqResetI>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @iclass
 */
void ibqResetI(input_buffers_queue_t *ibqp) {
 8002d00:	b500      	push	{lr}
 8002d02:	b083      	sub	sp, #12
 8002d04:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8002d06:	f7fd feab 	bl	8000a60 <chDbgCheckClassI>

  ibqp->bcounter = 0;
 8002d0a:	9b01      	ldr	r3, [sp, #4]
 8002d0c:	2200      	movs	r2, #0
 8002d0e:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = ibqp->buffers;
 8002d10:	9b01      	ldr	r3, [sp, #4]
 8002d12:	6a1a      	ldr	r2, [r3, #32]
 8002d14:	9b01      	ldr	r3, [sp, #4]
 8002d16:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = ibqp->buffers;
 8002d18:	9b01      	ldr	r3, [sp, #4]
 8002d1a:	6a1a      	ldr	r2, [r3, #32]
 8002d1c:	9b01      	ldr	r3, [sp, #4]
 8002d1e:	60da      	str	r2, [r3, #12]
  ibqp->ptr      = NULL;
 8002d20:	9b01      	ldr	r3, [sp, #4]
 8002d22:	2200      	movs	r2, #0
 8002d24:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 8002d26:	9b01      	ldr	r3, [sp, #4]
 8002d28:	2200      	movs	r2, #0
 8002d2a:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
 8002d2c:	9b01      	ldr	r3, [sp, #4]
 8002d2e:	f06f 0101 	mvn.w	r1, #1
 8002d32:	4618      	mov	r0, r3
 8002d34:	f7ff ff8c 	bl	8002c50 <osalThreadDequeueAllI>
}
 8002d38:	b003      	add	sp, #12
 8002d3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d3e:	bf00      	nop

08002d40 <ibqGetEmptyBufferI>:
 * @return              A pointer to the next buffer to be filled.
 * @retval NULL         if the queue is full.
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {
 8002d40:	b500      	push	{lr}
 8002d42:	b083      	sub	sp, #12
 8002d44:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8002d46:	f7fd fe8b 	bl	8000a60 <chDbgCheckClassI>

  if (ibqIsFullI(ibqp)) {
 8002d4a:	9b01      	ldr	r3, [sp, #4]
 8002d4c:	68da      	ldr	r2, [r3, #12]
 8002d4e:	9b01      	ldr	r3, [sp, #4]
 8002d50:	691b      	ldr	r3, [r3, #16]
 8002d52:	429a      	cmp	r2, r3
 8002d54:	d105      	bne.n	8002d62 <ibqGetEmptyBufferI+0x22>
 8002d56:	9b01      	ldr	r3, [sp, #4]
 8002d58:	689b      	ldr	r3, [r3, #8]
 8002d5a:	2b00      	cmp	r3, #0
 8002d5c:	d001      	beq.n	8002d62 <ibqGetEmptyBufferI+0x22>
 8002d5e:	2301      	movs	r3, #1
 8002d60:	e000      	b.n	8002d64 <ibqGetEmptyBufferI+0x24>
 8002d62:	2300      	movs	r3, #0
 8002d64:	f003 0301 	and.w	r3, r3, #1
 8002d68:	b2db      	uxtb	r3, r3
 8002d6a:	2b00      	cmp	r3, #0
 8002d6c:	d001      	beq.n	8002d72 <ibqGetEmptyBufferI+0x32>
    return NULL;
 8002d6e:	2300      	movs	r3, #0
 8002d70:	e002      	b.n	8002d78 <ibqGetEmptyBufferI+0x38>
  }

  return ibqp->bwrptr + sizeof (size_t);
 8002d72:	9b01      	ldr	r3, [sp, #4]
 8002d74:	68db      	ldr	r3, [r3, #12]
 8002d76:	3304      	adds	r3, #4
}
 8002d78:	4618      	mov	r0, r3
 8002d7a:	b003      	add	sp, #12
 8002d7c:	f85d fb04 	ldr.w	pc, [sp], #4

08002d80 <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 8002d80:	b500      	push	{lr}
 8002d82:	b083      	sub	sp, #12
 8002d84:	9001      	str	r0, [sp, #4]
 8002d86:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 8002d88:	f7fd fe6a 	bl	8000a60 <chDbgCheckClassI>

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 8002d8c:	9b00      	ldr	r3, [sp, #0]
 8002d8e:	2b00      	cmp	r3, #0
 8002d90:	d005      	beq.n	8002d9e <ibqPostFullBufferI+0x1e>
 8002d92:	9b01      	ldr	r3, [sp, #4]
 8002d94:	699b      	ldr	r3, [r3, #24]
 8002d96:	3b04      	subs	r3, #4
 8002d98:	9a00      	ldr	r2, [sp, #0]
 8002d9a:	429a      	cmp	r2, r3
 8002d9c:	d902      	bls.n	8002da4 <ibqPostFullBufferI+0x24>
 8002d9e:	481d      	ldr	r0, [pc, #116]	; (8002e14 <ibqPostFullBufferI+0x94>)
 8002da0:	f7fd fd36 	bl	8000810 <chSysHalt>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 8002da4:	9b01      	ldr	r3, [sp, #4]
 8002da6:	68da      	ldr	r2, [r3, #12]
 8002da8:	9b01      	ldr	r3, [sp, #4]
 8002daa:	691b      	ldr	r3, [r3, #16]
 8002dac:	429a      	cmp	r2, r3
 8002dae:	d105      	bne.n	8002dbc <ibqPostFullBufferI+0x3c>
 8002db0:	9b01      	ldr	r3, [sp, #4]
 8002db2:	689b      	ldr	r3, [r3, #8]
 8002db4:	2b00      	cmp	r3, #0
 8002db6:	d001      	beq.n	8002dbc <ibqPostFullBufferI+0x3c>
 8002db8:	2301      	movs	r3, #1
 8002dba:	e000      	b.n	8002dbe <ibqPostFullBufferI+0x3e>
 8002dbc:	2300      	movs	r3, #0
 8002dbe:	f003 0301 	and.w	r3, r3, #1
 8002dc2:	b2db      	uxtb	r3, r3
 8002dc4:	2b00      	cmp	r3, #0
 8002dc6:	d002      	beq.n	8002dce <ibqPostFullBufferI+0x4e>
 8002dc8:	4812      	ldr	r0, [pc, #72]	; (8002e14 <ibqPostFullBufferI+0x94>)
 8002dca:	f7fd fd21 	bl	8000810 <chSysHalt>

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 8002dce:	9b01      	ldr	r3, [sp, #4]
 8002dd0:	68db      	ldr	r3, [r3, #12]
 8002dd2:	9a00      	ldr	r2, [sp, #0]
 8002dd4:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 8002dd6:	9b01      	ldr	r3, [sp, #4]
 8002dd8:	689b      	ldr	r3, [r3, #8]
 8002dda:	1c5a      	adds	r2, r3, #1
 8002ddc:	9b01      	ldr	r3, [sp, #4]
 8002dde:	609a      	str	r2, [r3, #8]
  ibqp->bwrptr += ibqp->bsize;
 8002de0:	9b01      	ldr	r3, [sp, #4]
 8002de2:	68da      	ldr	r2, [r3, #12]
 8002de4:	9b01      	ldr	r3, [sp, #4]
 8002de6:	699b      	ldr	r3, [r3, #24]
 8002de8:	441a      	add	r2, r3
 8002dea:	9b01      	ldr	r3, [sp, #4]
 8002dec:	60da      	str	r2, [r3, #12]
  if (ibqp->bwrptr >= ibqp->btop) {
 8002dee:	9b01      	ldr	r3, [sp, #4]
 8002df0:	68da      	ldr	r2, [r3, #12]
 8002df2:	9b01      	ldr	r3, [sp, #4]
 8002df4:	695b      	ldr	r3, [r3, #20]
 8002df6:	429a      	cmp	r2, r3
 8002df8:	d303      	bcc.n	8002e02 <ibqPostFullBufferI+0x82>
    ibqp->bwrptr = ibqp->buffers;
 8002dfa:	9b01      	ldr	r3, [sp, #4]
 8002dfc:	6a1a      	ldr	r2, [r3, #32]
 8002dfe:	9b01      	ldr	r3, [sp, #4]
 8002e00:	60da      	str	r2, [r3, #12]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 8002e02:	9b01      	ldr	r3, [sp, #4]
 8002e04:	2100      	movs	r1, #0
 8002e06:	4618      	mov	r0, r3
 8002e08:	f7ff ff12 	bl	8002c30 <osalThreadDequeueNextI>
}
 8002e0c:	b003      	add	sp, #12
 8002e0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e12:	bf00      	nop
 8002e14:	0800a6f0 	.word	0x0800a6f0
	...

08002e20 <ibqGetFullBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {
 8002e20:	b500      	push	{lr}
 8002e22:	b085      	sub	sp, #20
 8002e24:	9001      	str	r0, [sp, #4]
 8002e26:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 8002e28:	f7fd fe32 	bl	8000a90 <chDbgCheckClassS>
 8002e2c:	e00a      	b.n	8002e44 <ibqGetFullBufferTimeoutS+0x24>

  while (ibqIsEmptyI(ibqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
 8002e2e:	9b01      	ldr	r3, [sp, #4]
 8002e30:	9900      	ldr	r1, [sp, #0]
 8002e32:	4618      	mov	r0, r3
 8002e34:	f7ff feec 	bl	8002c10 <osalThreadEnqueueTimeoutS>
 8002e38:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8002e3a:	9b03      	ldr	r3, [sp, #12]
 8002e3c:	2b00      	cmp	r3, #0
 8002e3e:	da01      	bge.n	8002e44 <ibqGetFullBufferTimeoutS+0x24>
       return msg;
 8002e40:	9b03      	ldr	r3, [sp, #12]
 8002e42:	e018      	b.n	8002e76 <ibqGetFullBufferTimeoutS+0x56>
  while (ibqIsEmptyI(ibqp)) {
 8002e44:	9b01      	ldr	r3, [sp, #4]
 8002e46:	689b      	ldr	r3, [r3, #8]
 8002e48:	2b00      	cmp	r3, #0
 8002e4a:	d0f0      	beq.n	8002e2e <ibqGetFullBufferTimeoutS+0xe>
    }
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 8002e4c:	9b01      	ldr	r3, [sp, #4]
 8002e4e:	689b      	ldr	r3, [r3, #8]
 8002e50:	2b00      	cmp	r3, #0
 8002e52:	d102      	bne.n	8002e5a <ibqGetFullBufferTimeoutS+0x3a>
 8002e54:	480a      	ldr	r0, [pc, #40]	; (8002e80 <ibqGetFullBufferTimeoutS+0x60>)
 8002e56:	f7fd fcdb 	bl	8000810 <chSysHalt>

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8002e5a:	9b01      	ldr	r3, [sp, #4]
 8002e5c:	691b      	ldr	r3, [r3, #16]
 8002e5e:	1d1a      	adds	r2, r3, #4
 8002e60:	9b01      	ldr	r3, [sp, #4]
 8002e62:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8002e64:	9b01      	ldr	r3, [sp, #4]
 8002e66:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002e68:	9b01      	ldr	r3, [sp, #4]
 8002e6a:	691b      	ldr	r3, [r3, #16]
 8002e6c:	681b      	ldr	r3, [r3, #0]
 8002e6e:	441a      	add	r2, r3
 8002e70:	9b01      	ldr	r3, [sp, #4]
 8002e72:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 8002e74:	2300      	movs	r3, #0
}
 8002e76:	4618      	mov	r0, r3
 8002e78:	b005      	add	sp, #20
 8002e7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e7e:	bf00      	nop
 8002e80:	0800a720 	.word	0x0800a720
	...

08002e90 <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8002e90:	b500      	push	{lr}
 8002e92:	b083      	sub	sp, #12
 8002e94:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassS();
 8002e96:	f7fd fdfb 	bl	8000a90 <chDbgCheckClassS>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 8002e9a:	9b01      	ldr	r3, [sp, #4]
 8002e9c:	689b      	ldr	r3, [r3, #8]
 8002e9e:	2b00      	cmp	r3, #0
 8002ea0:	d102      	bne.n	8002ea8 <ibqReleaseEmptyBufferS+0x18>
 8002ea2:	4813      	ldr	r0, [pc, #76]	; (8002ef0 <ibqReleaseEmptyBufferS+0x60>)
 8002ea4:	f7fd fcb4 	bl	8000810 <chSysHalt>

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8002ea8:	9b01      	ldr	r3, [sp, #4]
 8002eaa:	689b      	ldr	r3, [r3, #8]
 8002eac:	1e5a      	subs	r2, r3, #1
 8002eae:	9b01      	ldr	r3, [sp, #4]
 8002eb0:	609a      	str	r2, [r3, #8]
  ibqp->brdptr += ibqp->bsize;
 8002eb2:	9b01      	ldr	r3, [sp, #4]
 8002eb4:	691a      	ldr	r2, [r3, #16]
 8002eb6:	9b01      	ldr	r3, [sp, #4]
 8002eb8:	699b      	ldr	r3, [r3, #24]
 8002eba:	441a      	add	r2, r3
 8002ebc:	9b01      	ldr	r3, [sp, #4]
 8002ebe:	611a      	str	r2, [r3, #16]
  if (ibqp->brdptr >= ibqp->btop) {
 8002ec0:	9b01      	ldr	r3, [sp, #4]
 8002ec2:	691a      	ldr	r2, [r3, #16]
 8002ec4:	9b01      	ldr	r3, [sp, #4]
 8002ec6:	695b      	ldr	r3, [r3, #20]
 8002ec8:	429a      	cmp	r2, r3
 8002eca:	d303      	bcc.n	8002ed4 <ibqReleaseEmptyBufferS+0x44>
    ibqp->brdptr = ibqp->buffers;
 8002ecc:	9b01      	ldr	r3, [sp, #4]
 8002ece:	6a1a      	ldr	r2, [r3, #32]
 8002ed0:	9b01      	ldr	r3, [sp, #4]
 8002ed2:	611a      	str	r2, [r3, #16]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8002ed4:	9b01      	ldr	r3, [sp, #4]
 8002ed6:	2200      	movs	r2, #0
 8002ed8:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8002eda:	9b01      	ldr	r3, [sp, #4]
 8002edc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002ede:	2b00      	cmp	r3, #0
 8002ee0:	d003      	beq.n	8002eea <ibqReleaseEmptyBufferS+0x5a>
    ibqp->notify(ibqp);
 8002ee2:	9b01      	ldr	r3, [sp, #4]
 8002ee4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002ee6:	9801      	ldr	r0, [sp, #4]
 8002ee8:	4798      	blx	r3
  }
}
 8002eea:	b003      	add	sp, #12
 8002eec:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ef0:	0800a740 	.word	0x0800a740
	...

08002f00 <ibqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 8002f00:	b500      	push	{lr}
 8002f02:	b085      	sub	sp, #20
 8002f04:	9001      	str	r0, [sp, #4]
 8002f06:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8002f08:	f7ff fe5a 	bl	8002bc0 <osalSysLock.lto_priv.228>

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 8002f0c:	9b01      	ldr	r3, [sp, #4]
 8002f0e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002f10:	2b00      	cmp	r3, #0
 8002f12:	d10b      	bne.n	8002f2c <ibqGetTimeout+0x2c>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8002f14:	9900      	ldr	r1, [sp, #0]
 8002f16:	9801      	ldr	r0, [sp, #4]
 8002f18:	f7ff ff82 	bl	8002e20 <ibqGetFullBufferTimeoutS>
 8002f1c:	9003      	str	r0, [sp, #12]
    if (msg != MSG_OK) {
 8002f1e:	9b03      	ldr	r3, [sp, #12]
 8002f20:	2b00      	cmp	r3, #0
 8002f22:	d003      	beq.n	8002f2c <ibqGetTimeout+0x2c>
      osalSysUnlock();
 8002f24:	f7ff fe54 	bl	8002bd0 <osalSysUnlock.lto_priv.219>
      return msg;
 8002f28:	9b03      	ldr	r3, [sp, #12]
 8002f2a:	e014      	b.n	8002f56 <ibqGetTimeout+0x56>
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 8002f2c:	9b01      	ldr	r3, [sp, #4]
 8002f2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002f30:	781b      	ldrb	r3, [r3, #0]
 8002f32:	9303      	str	r3, [sp, #12]
  ibqp->ptr++;
 8002f34:	9b01      	ldr	r3, [sp, #4]
 8002f36:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002f38:	1c5a      	adds	r2, r3, #1
 8002f3a:	9b01      	ldr	r3, [sp, #4]
 8002f3c:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 8002f3e:	9b01      	ldr	r3, [sp, #4]
 8002f40:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002f42:	9b01      	ldr	r3, [sp, #4]
 8002f44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002f46:	429a      	cmp	r2, r3
 8002f48:	d302      	bcc.n	8002f50 <ibqGetTimeout+0x50>
    ibqReleaseEmptyBufferS(ibqp);
 8002f4a:	9801      	ldr	r0, [sp, #4]
 8002f4c:	f7ff ffa0 	bl	8002e90 <ibqReleaseEmptyBufferS>
  }

  osalSysUnlock();
 8002f50:	f7ff fe3e 	bl	8002bd0 <osalSysUnlock.lto_priv.219>
  return msg;
 8002f54:	9b03      	ldr	r3, [sp, #12]
}
 8002f56:	4618      	mov	r0, r3
 8002f58:	b005      	add	sp, #20
 8002f5a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f5e:	bf00      	nop

08002f60 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 8002f60:	b500      	push	{lr}
 8002f62:	b08b      	sub	sp, #44	; 0x2c
 8002f64:	9003      	str	r0, [sp, #12]
 8002f66:	9102      	str	r1, [sp, #8]
 8002f68:	9201      	str	r2, [sp, #4]
 8002f6a:	9300      	str	r3, [sp, #0]
  size_t r = 0;
 8002f6c:	2300      	movs	r3, #0
 8002f6e:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 8002f70:	f7ff fe26 	bl	8002bc0 <osalSysLock.lto_priv.228>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8002f74:	f7ff fe34 	bl	8002be0 <osalOsGetSystemTimeX.lto_priv.246>
 8002f78:	4602      	mov	r2, r0
 8002f7a:	9b00      	ldr	r3, [sp, #0]
 8002f7c:	4413      	add	r3, r2
 8002f7e:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 8002f80:	9b03      	ldr	r3, [sp, #12]
 8002f82:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002f84:	2b00      	cmp	r3, #0
 8002f86:	d126      	bne.n	8002fd6 <ibqReadTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8002f88:	9b00      	ldr	r3, [sp, #0]
 8002f8a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8002f8e:	d002      	beq.n	8002f96 <ibqReadTimeout+0x36>
 8002f90:	9b00      	ldr	r3, [sp, #0]
 8002f92:	2b00      	cmp	r3, #0
 8002f94:	d105      	bne.n	8002fa2 <ibqReadTimeout+0x42>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8002f96:	9900      	ldr	r1, [sp, #0]
 8002f98:	9803      	ldr	r0, [sp, #12]
 8002f9a:	f7ff ff41 	bl	8002e20 <ibqGetFullBufferTimeoutS>
 8002f9e:	9007      	str	r0, [sp, #28]
 8002fa0:	e012      	b.n	8002fc8 <ibqReadTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8002fa2:	f7ff fe1d 	bl	8002be0 <osalOsGetSystemTimeX.lto_priv.246>
 8002fa6:	4602      	mov	r2, r0
 8002fa8:	9b06      	ldr	r3, [sp, #24]
 8002faa:	1a9b      	subs	r3, r3, r2
 8002fac:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8002fae:	9a05      	ldr	r2, [sp, #20]
 8002fb0:	9b00      	ldr	r3, [sp, #0]
 8002fb2:	429a      	cmp	r2, r3
 8002fb4:	d903      	bls.n	8002fbe <ibqReadTimeout+0x5e>
          osalSysUnlock();
 8002fb6:	f7ff fe0b 	bl	8002bd0 <osalSysUnlock.lto_priv.219>
          return r;
 8002fba:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002fbc:	e05c      	b.n	8003078 <ibqReadTimeout+0x118>
        }
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 8002fbe:	9905      	ldr	r1, [sp, #20]
 8002fc0:	9803      	ldr	r0, [sp, #12]
 8002fc2:	f7ff ff2d 	bl	8002e20 <ibqGetFullBufferTimeoutS>
 8002fc6:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8002fc8:	9b07      	ldr	r3, [sp, #28]
 8002fca:	2b00      	cmp	r3, #0
 8002fcc:	d003      	beq.n	8002fd6 <ibqReadTimeout+0x76>
        osalSysUnlock();
 8002fce:	f7ff fdff 	bl	8002bd0 <osalSysUnlock.lto_priv.219>
        return r;
 8002fd2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002fd4:	e050      	b.n	8003078 <ibqReadTimeout+0x118>
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8002fd6:	9b03      	ldr	r3, [sp, #12]
 8002fd8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002fda:	461a      	mov	r2, r3
 8002fdc:	9b03      	ldr	r3, [sp, #12]
 8002fde:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002fe0:	1ad3      	subs	r3, r2, r3
 8002fe2:	9308      	str	r3, [sp, #32]
    if (size > (n - r)) {
 8002fe4:	9a01      	ldr	r2, [sp, #4]
 8002fe6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002fe8:	1ad3      	subs	r3, r2, r3
 8002fea:	9a08      	ldr	r2, [sp, #32]
 8002fec:	429a      	cmp	r2, r3
 8002fee:	d903      	bls.n	8002ff8 <ibqReadTimeout+0x98>
      size = n - r;
 8002ff0:	9a01      	ldr	r2, [sp, #4]
 8002ff2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002ff4:	1ad3      	subs	r3, r2, r3
 8002ff6:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8002ff8:	9b08      	ldr	r3, [sp, #32]
 8002ffa:	2b40      	cmp	r3, #64	; 0x40
 8002ffc:	d913      	bls.n	8003026 <ibqReadTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
 8002ffe:	9b03      	ldr	r3, [sp, #12]
 8003000:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003002:	2240      	movs	r2, #64	; 0x40
 8003004:	4619      	mov	r1, r3
 8003006:	9802      	ldr	r0, [sp, #8]
 8003008:	f7fd f98a 	bl	8000320 <memcpy>
      bp        += 64U;
 800300c:	9b02      	ldr	r3, [sp, #8]
 800300e:	3340      	adds	r3, #64	; 0x40
 8003010:	9302      	str	r3, [sp, #8]
      ibqp->ptr += 64U;
 8003012:	9b03      	ldr	r3, [sp, #12]
 8003014:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003016:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800301a:	9b03      	ldr	r3, [sp, #12]
 800301c:	625a      	str	r2, [r3, #36]	; 0x24
      r         += 64U;
 800301e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003020:	3340      	adds	r3, #64	; 0x40
 8003022:	9309      	str	r3, [sp, #36]	; 0x24
 8003024:	e014      	b.n	8003050 <ibqReadTimeout+0xf0>
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 8003026:	9b03      	ldr	r3, [sp, #12]
 8003028:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800302a:	9a08      	ldr	r2, [sp, #32]
 800302c:	4619      	mov	r1, r3
 800302e:	9802      	ldr	r0, [sp, #8]
 8003030:	f7fd f976 	bl	8000320 <memcpy>
      bp        += size;
 8003034:	9a02      	ldr	r2, [sp, #8]
 8003036:	9b08      	ldr	r3, [sp, #32]
 8003038:	4413      	add	r3, r2
 800303a:	9302      	str	r3, [sp, #8]
      ibqp->ptr += size;
 800303c:	9b03      	ldr	r3, [sp, #12]
 800303e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003040:	9b08      	ldr	r3, [sp, #32]
 8003042:	441a      	add	r2, r3
 8003044:	9b03      	ldr	r3, [sp, #12]
 8003046:	625a      	str	r2, [r3, #36]	; 0x24
      r         += size;
 8003048:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800304a:	9b08      	ldr	r3, [sp, #32]
 800304c:	4413      	add	r3, r2
 800304e:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8003050:	9b03      	ldr	r3, [sp, #12]
 8003052:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003054:	9b03      	ldr	r3, [sp, #12]
 8003056:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003058:	429a      	cmp	r2, r3
 800305a:	d302      	bcc.n	8003062 <ibqReadTimeout+0x102>
      ibqReleaseEmptyBufferS(ibqp);
 800305c:	9803      	ldr	r0, [sp, #12]
 800305e:	f7ff ff17 	bl	8002e90 <ibqReleaseEmptyBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 8003062:	f7ff fdb5 	bl	8002bd0 <osalSysUnlock.lto_priv.219>
    if (r >= n) {
 8003066:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8003068:	9b01      	ldr	r3, [sp, #4]
 800306a:	429a      	cmp	r2, r3
 800306c:	d301      	bcc.n	8003072 <ibqReadTimeout+0x112>
      return r;
 800306e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003070:	e002      	b.n	8003078 <ibqReadTimeout+0x118>
    }
    osalSysLock();
 8003072:	f7ff fda5 	bl	8002bc0 <osalSysLock.lto_priv.228>
 8003076:	e783      	b.n	8002f80 <ibqReadTimeout+0x20>
  }
}
 8003078:	4618      	mov	r0, r3
 800307a:	b00b      	add	sp, #44	; 0x2c
 800307c:	f85d fb04 	ldr.w	pc, [sp], #4

08003080 <obqObjectInit>:
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t onfy, void *link) {
 8003080:	b500      	push	{lr}
 8003082:	b085      	sub	sp, #20
 8003084:	9003      	str	r0, [sp, #12]
 8003086:	9102      	str	r1, [sp, #8]
 8003088:	9201      	str	r2, [sp, #4]
 800308a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));
 800308c:	9b03      	ldr	r3, [sp, #12]
 800308e:	2b00      	cmp	r3, #0
 8003090:	d005      	beq.n	800309e <obqObjectInit+0x1e>
 8003092:	9b02      	ldr	r3, [sp, #8]
 8003094:	2b00      	cmp	r3, #0
 8003096:	d002      	beq.n	800309e <obqObjectInit+0x1e>
 8003098:	9b01      	ldr	r3, [sp, #4]
 800309a:	2b01      	cmp	r3, #1
 800309c:	d802      	bhi.n	80030a4 <obqObjectInit+0x24>
 800309e:	4819      	ldr	r0, [pc, #100]	; (8003104 <obqObjectInit+0x84>)
 80030a0:	f7fd fbb6 	bl	8000810 <chSysHalt>

  osalThreadQueueObjectInit(&obqp->waiting);
 80030a4:	9b03      	ldr	r3, [sp, #12]
 80030a6:	4618      	mov	r0, r3
 80030a8:	f7ff fda2 	bl	8002bf0 <osalThreadQueueObjectInit>
  obqp->bcounter = n;
 80030ac:	9b03      	ldr	r3, [sp, #12]
 80030ae:	9a00      	ldr	r2, [sp, #0]
 80030b0:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = bp;
 80030b2:	9b03      	ldr	r3, [sp, #12]
 80030b4:	9a02      	ldr	r2, [sp, #8]
 80030b6:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = bp;
 80030b8:	9b03      	ldr	r3, [sp, #12]
 80030ba:	9a02      	ldr	r2, [sp, #8]
 80030bc:	60da      	str	r2, [r3, #12]
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 80030be:	9b01      	ldr	r3, [sp, #4]
 80030c0:	3304      	adds	r3, #4
 80030c2:	9a00      	ldr	r2, [sp, #0]
 80030c4:	fb02 f303 	mul.w	r3, r2, r3
 80030c8:	9a02      	ldr	r2, [sp, #8]
 80030ca:	441a      	add	r2, r3
 80030cc:	9b03      	ldr	r3, [sp, #12]
 80030ce:	615a      	str	r2, [r3, #20]
  obqp->bsize    = size + sizeof (size_t);
 80030d0:	9b01      	ldr	r3, [sp, #4]
 80030d2:	1d1a      	adds	r2, r3, #4
 80030d4:	9b03      	ldr	r3, [sp, #12]
 80030d6:	619a      	str	r2, [r3, #24]
  obqp->bn       = n;
 80030d8:	9b03      	ldr	r3, [sp, #12]
 80030da:	9a00      	ldr	r2, [sp, #0]
 80030dc:	61da      	str	r2, [r3, #28]
  obqp->buffers  = bp;
 80030de:	9b03      	ldr	r3, [sp, #12]
 80030e0:	9a02      	ldr	r2, [sp, #8]
 80030e2:	621a      	str	r2, [r3, #32]
  obqp->ptr      = NULL;
 80030e4:	9b03      	ldr	r3, [sp, #12]
 80030e6:	2200      	movs	r2, #0
 80030e8:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 80030ea:	9b03      	ldr	r3, [sp, #12]
 80030ec:	2200      	movs	r2, #0
 80030ee:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->notify   = onfy;
 80030f0:	9b03      	ldr	r3, [sp, #12]
 80030f2:	9a06      	ldr	r2, [sp, #24]
 80030f4:	62da      	str	r2, [r3, #44]	; 0x2c
  obqp->link     = link;
 80030f6:	9b03      	ldr	r3, [sp, #12]
 80030f8:	9a07      	ldr	r2, [sp, #28]
 80030fa:	631a      	str	r2, [r3, #48]	; 0x30
}
 80030fc:	b005      	add	sp, #20
 80030fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8003102:	bf00      	nop
 8003104:	0800a760 	.word	0x0800a760
	...

08003110 <obqResetI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {
 8003110:	b500      	push	{lr}
 8003112:	b083      	sub	sp, #12
 8003114:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8003116:	f7fd fca3 	bl	8000a60 <chDbgCheckClassI>

  obqp->bcounter = bqSizeX(obqp);
 800311a:	9b01      	ldr	r3, [sp, #4]
 800311c:	69da      	ldr	r2, [r3, #28]
 800311e:	9b01      	ldr	r3, [sp, #4]
 8003120:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = obqp->buffers;
 8003122:	9b01      	ldr	r3, [sp, #4]
 8003124:	6a1a      	ldr	r2, [r3, #32]
 8003126:	9b01      	ldr	r3, [sp, #4]
 8003128:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = obqp->buffers;
 800312a:	9b01      	ldr	r3, [sp, #4]
 800312c:	6a1a      	ldr	r2, [r3, #32]
 800312e:	9b01      	ldr	r3, [sp, #4]
 8003130:	60da      	str	r2, [r3, #12]
  obqp->ptr      = NULL;
 8003132:	9b01      	ldr	r3, [sp, #4]
 8003134:	2200      	movs	r2, #0
 8003136:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 8003138:	9b01      	ldr	r3, [sp, #4]
 800313a:	2200      	movs	r2, #0
 800313c:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 800313e:	9b01      	ldr	r3, [sp, #4]
 8003140:	f06f 0101 	mvn.w	r1, #1
 8003144:	4618      	mov	r0, r3
 8003146:	f7ff fd83 	bl	8002c50 <osalThreadDequeueAllI>
}
 800314a:	b003      	add	sp, #12
 800314c:	f85d fb04 	ldr.w	pc, [sp], #4

08003150 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 8003150:	b500      	push	{lr}
 8003152:	b083      	sub	sp, #12
 8003154:	9001      	str	r0, [sp, #4]
 8003156:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 8003158:	f7fd fc82 	bl	8000a60 <chDbgCheckClassI>

  if (obqIsEmptyI(obqp)) {
 800315c:	9b01      	ldr	r3, [sp, #4]
 800315e:	68da      	ldr	r2, [r3, #12]
 8003160:	9b01      	ldr	r3, [sp, #4]
 8003162:	691b      	ldr	r3, [r3, #16]
 8003164:	429a      	cmp	r2, r3
 8003166:	d105      	bne.n	8003174 <obqGetFullBufferI+0x24>
 8003168:	9b01      	ldr	r3, [sp, #4]
 800316a:	689b      	ldr	r3, [r3, #8]
 800316c:	2b00      	cmp	r3, #0
 800316e:	d001      	beq.n	8003174 <obqGetFullBufferI+0x24>
 8003170:	2301      	movs	r3, #1
 8003172:	e000      	b.n	8003176 <obqGetFullBufferI+0x26>
 8003174:	2300      	movs	r3, #0
 8003176:	f003 0301 	and.w	r3, r3, #1
 800317a:	b2db      	uxtb	r3, r3
 800317c:	2b00      	cmp	r3, #0
 800317e:	d001      	beq.n	8003184 <obqGetFullBufferI+0x34>
    return NULL;
 8003180:	2300      	movs	r3, #0
 8003182:	e007      	b.n	8003194 <obqGetFullBufferI+0x44>
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 8003184:	9b01      	ldr	r3, [sp, #4]
 8003186:	691b      	ldr	r3, [r3, #16]
 8003188:	681a      	ldr	r2, [r3, #0]
 800318a:	9b00      	ldr	r3, [sp, #0]
 800318c:	601a      	str	r2, [r3, #0]

  return obqp->brdptr + sizeof (size_t);
 800318e:	9b01      	ldr	r3, [sp, #4]
 8003190:	691b      	ldr	r3, [r3, #16]
 8003192:	3304      	adds	r3, #4
}
 8003194:	4618      	mov	r0, r3
 8003196:	b003      	add	sp, #12
 8003198:	f85d fb04 	ldr.w	pc, [sp], #4
 800319c:	0000      	movs	r0, r0
	...

080031a0 <obqReleaseEmptyBufferI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 80031a0:	b500      	push	{lr}
 80031a2:	b083      	sub	sp, #12
 80031a4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 80031a6:	f7fd fc5b 	bl	8000a60 <chDbgCheckClassI>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 80031aa:	9b01      	ldr	r3, [sp, #4]
 80031ac:	68da      	ldr	r2, [r3, #12]
 80031ae:	9b01      	ldr	r3, [sp, #4]
 80031b0:	691b      	ldr	r3, [r3, #16]
 80031b2:	429a      	cmp	r2, r3
 80031b4:	d105      	bne.n	80031c2 <obqReleaseEmptyBufferI+0x22>
 80031b6:	9b01      	ldr	r3, [sp, #4]
 80031b8:	689b      	ldr	r3, [r3, #8]
 80031ba:	2b00      	cmp	r3, #0
 80031bc:	d001      	beq.n	80031c2 <obqReleaseEmptyBufferI+0x22>
 80031be:	2301      	movs	r3, #1
 80031c0:	e000      	b.n	80031c4 <obqReleaseEmptyBufferI+0x24>
 80031c2:	2300      	movs	r3, #0
 80031c4:	f003 0301 	and.w	r3, r3, #1
 80031c8:	b2db      	uxtb	r3, r3
 80031ca:	2b00      	cmp	r3, #0
 80031cc:	d002      	beq.n	80031d4 <obqReleaseEmptyBufferI+0x34>
 80031ce:	4810      	ldr	r0, [pc, #64]	; (8003210 <obqReleaseEmptyBufferI+0x70>)
 80031d0:	f7fd fb1e 	bl	8000810 <chSysHalt>

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 80031d4:	9b01      	ldr	r3, [sp, #4]
 80031d6:	689b      	ldr	r3, [r3, #8]
 80031d8:	1c5a      	adds	r2, r3, #1
 80031da:	9b01      	ldr	r3, [sp, #4]
 80031dc:	609a      	str	r2, [r3, #8]
  obqp->brdptr += obqp->bsize;
 80031de:	9b01      	ldr	r3, [sp, #4]
 80031e0:	691a      	ldr	r2, [r3, #16]
 80031e2:	9b01      	ldr	r3, [sp, #4]
 80031e4:	699b      	ldr	r3, [r3, #24]
 80031e6:	441a      	add	r2, r3
 80031e8:	9b01      	ldr	r3, [sp, #4]
 80031ea:	611a      	str	r2, [r3, #16]
  if (obqp->brdptr >= obqp->btop) {
 80031ec:	9b01      	ldr	r3, [sp, #4]
 80031ee:	691a      	ldr	r2, [r3, #16]
 80031f0:	9b01      	ldr	r3, [sp, #4]
 80031f2:	695b      	ldr	r3, [r3, #20]
 80031f4:	429a      	cmp	r2, r3
 80031f6:	d303      	bcc.n	8003200 <obqReleaseEmptyBufferI+0x60>
    obqp->brdptr = obqp->buffers;
 80031f8:	9b01      	ldr	r3, [sp, #4]
 80031fa:	6a1a      	ldr	r2, [r3, #32]
 80031fc:	9b01      	ldr	r3, [sp, #4]
 80031fe:	611a      	str	r2, [r3, #16]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 8003200:	9b01      	ldr	r3, [sp, #4]
 8003202:	2100      	movs	r1, #0
 8003204:	4618      	mov	r0, r3
 8003206:	f7ff fd13 	bl	8002c30 <osalThreadDequeueNextI>
}
 800320a:	b003      	add	sp, #12
 800320c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003210:	0800a770 	.word	0x0800a770
	...

08003220 <obqGetEmptyBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {
 8003220:	b500      	push	{lr}
 8003222:	b085      	sub	sp, #20
 8003224:	9001      	str	r0, [sp, #4]
 8003226:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 8003228:	f7fd fc32 	bl	8000a90 <chDbgCheckClassS>
 800322c:	e00a      	b.n	8003244 <obqGetEmptyBufferTimeoutS+0x24>

  while (obqIsFullI(obqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
 800322e:	9b01      	ldr	r3, [sp, #4]
 8003230:	9900      	ldr	r1, [sp, #0]
 8003232:	4618      	mov	r0, r3
 8003234:	f7ff fcec 	bl	8002c10 <osalThreadEnqueueTimeoutS>
 8003238:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 800323a:	9b03      	ldr	r3, [sp, #12]
 800323c:	2b00      	cmp	r3, #0
 800323e:	da01      	bge.n	8003244 <obqGetEmptyBufferTimeoutS+0x24>
      return msg;
 8003240:	9b03      	ldr	r3, [sp, #12]
 8003242:	e017      	b.n	8003274 <obqGetEmptyBufferTimeoutS+0x54>
  while (obqIsFullI(obqp)) {
 8003244:	9b01      	ldr	r3, [sp, #4]
 8003246:	689b      	ldr	r3, [r3, #8]
 8003248:	2b00      	cmp	r3, #0
 800324a:	d0f0      	beq.n	800322e <obqGetEmptyBufferTimeoutS+0xe>
    }
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");
 800324c:	9b01      	ldr	r3, [sp, #4]
 800324e:	689b      	ldr	r3, [r3, #8]
 8003250:	2b00      	cmp	r3, #0
 8003252:	d102      	bne.n	800325a <obqGetEmptyBufferTimeoutS+0x3a>
 8003254:	4809      	ldr	r0, [pc, #36]	; (800327c <obqGetEmptyBufferTimeoutS+0x5c>)
 8003256:	f7fd fadb 	bl	8000810 <chSysHalt>

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 800325a:	9b01      	ldr	r3, [sp, #4]
 800325c:	68db      	ldr	r3, [r3, #12]
 800325e:	1d1a      	adds	r2, r3, #4
 8003260:	9b01      	ldr	r3, [sp, #4]
 8003262:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top = obqp->bwrptr + obqp->bsize;
 8003264:	9b01      	ldr	r3, [sp, #4]
 8003266:	68da      	ldr	r2, [r3, #12]
 8003268:	9b01      	ldr	r3, [sp, #4]
 800326a:	699b      	ldr	r3, [r3, #24]
 800326c:	441a      	add	r2, r3
 800326e:	9b01      	ldr	r3, [sp, #4]
 8003270:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 8003272:	2300      	movs	r3, #0
}
 8003274:	4618      	mov	r0, r3
 8003276:	b005      	add	sp, #20
 8003278:	f85d fb04 	ldr.w	pc, [sp], #4
 800327c:	0800a790 	.word	0x0800a790

08003280 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8003280:	b500      	push	{lr}
 8003282:	b083      	sub	sp, #12
 8003284:	9001      	str	r0, [sp, #4]
 8003286:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 8003288:	f7fd fc02 	bl	8000a90 <chDbgCheckClassS>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 800328c:	9b00      	ldr	r3, [sp, #0]
 800328e:	2b00      	cmp	r3, #0
 8003290:	d005      	beq.n	800329e <obqPostFullBufferS+0x1e>
 8003292:	9b01      	ldr	r3, [sp, #4]
 8003294:	699b      	ldr	r3, [r3, #24]
 8003296:	3b04      	subs	r3, #4
 8003298:	9a00      	ldr	r2, [sp, #0]
 800329a:	429a      	cmp	r2, r3
 800329c:	d902      	bls.n	80032a4 <obqPostFullBufferS+0x24>
 800329e:	4819      	ldr	r0, [pc, #100]	; (8003304 <obqPostFullBufferS+0x84>)
 80032a0:	f7fd fab6 	bl	8000810 <chSysHalt>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 80032a4:	9b01      	ldr	r3, [sp, #4]
 80032a6:	689b      	ldr	r3, [r3, #8]
 80032a8:	2b00      	cmp	r3, #0
 80032aa:	d102      	bne.n	80032b2 <obqPostFullBufferS+0x32>
 80032ac:	4815      	ldr	r0, [pc, #84]	; (8003304 <obqPostFullBufferS+0x84>)
 80032ae:	f7fd faaf 	bl	8000810 <chSysHalt>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 80032b2:	9b01      	ldr	r3, [sp, #4]
 80032b4:	68db      	ldr	r3, [r3, #12]
 80032b6:	9a00      	ldr	r2, [sp, #0]
 80032b8:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 80032ba:	9b01      	ldr	r3, [sp, #4]
 80032bc:	689b      	ldr	r3, [r3, #8]
 80032be:	1e5a      	subs	r2, r3, #1
 80032c0:	9b01      	ldr	r3, [sp, #4]
 80032c2:	609a      	str	r2, [r3, #8]
  obqp->bwrptr += obqp->bsize;
 80032c4:	9b01      	ldr	r3, [sp, #4]
 80032c6:	68da      	ldr	r2, [r3, #12]
 80032c8:	9b01      	ldr	r3, [sp, #4]
 80032ca:	699b      	ldr	r3, [r3, #24]
 80032cc:	441a      	add	r2, r3
 80032ce:	9b01      	ldr	r3, [sp, #4]
 80032d0:	60da      	str	r2, [r3, #12]
  if (obqp->bwrptr >= obqp->btop) {
 80032d2:	9b01      	ldr	r3, [sp, #4]
 80032d4:	68da      	ldr	r2, [r3, #12]
 80032d6:	9b01      	ldr	r3, [sp, #4]
 80032d8:	695b      	ldr	r3, [r3, #20]
 80032da:	429a      	cmp	r2, r3
 80032dc:	d303      	bcc.n	80032e6 <obqPostFullBufferS+0x66>
    obqp->bwrptr = obqp->buffers;
 80032de:	9b01      	ldr	r3, [sp, #4]
 80032e0:	6a1a      	ldr	r2, [r3, #32]
 80032e2:	9b01      	ldr	r3, [sp, #4]
 80032e4:	60da      	str	r2, [r3, #12]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 80032e6:	9b01      	ldr	r3, [sp, #4]
 80032e8:	2200      	movs	r2, #0
 80032ea:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 80032ec:	9b01      	ldr	r3, [sp, #4]
 80032ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80032f0:	2b00      	cmp	r3, #0
 80032f2:	d003      	beq.n	80032fc <obqPostFullBufferS+0x7c>
    obqp->notify(obqp);
 80032f4:	9b01      	ldr	r3, [sp, #4]
 80032f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80032f8:	9801      	ldr	r0, [sp, #4]
 80032fa:	4798      	blx	r3
  }
}
 80032fc:	b003      	add	sp, #12
 80032fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8003302:	bf00      	nop
 8003304:	0800a7b0 	.word	0x0800a7b0
	...

08003310 <obqPutTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 8003310:	b500      	push	{lr}
 8003312:	b087      	sub	sp, #28
 8003314:	9003      	str	r0, [sp, #12]
 8003316:	460b      	mov	r3, r1
 8003318:	9201      	str	r2, [sp, #4]
 800331a:	f88d 300b 	strb.w	r3, [sp, #11]
  msg_t msg;

  osalSysLock();
 800331e:	f7ff fc4f 	bl	8002bc0 <osalSysLock.lto_priv.228>

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 8003322:	9b03      	ldr	r3, [sp, #12]
 8003324:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003326:	2b00      	cmp	r3, #0
 8003328:	d10b      	bne.n	8003342 <obqPutTimeout+0x32>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800332a:	9901      	ldr	r1, [sp, #4]
 800332c:	9803      	ldr	r0, [sp, #12]
 800332e:	f7ff ff77 	bl	8003220 <obqGetEmptyBufferTimeoutS>
 8003332:	9005      	str	r0, [sp, #20]
    if (msg != MSG_OK) {
 8003334:	9b05      	ldr	r3, [sp, #20]
 8003336:	2b00      	cmp	r3, #0
 8003338:	d003      	beq.n	8003342 <obqPutTimeout+0x32>
      osalSysUnlock();
 800333a:	f7ff fc49 	bl	8002bd0 <osalSysUnlock.lto_priv.219>
      return msg;
 800333e:	9b05      	ldr	r3, [sp, #20]
 8003340:	e019      	b.n	8003376 <obqPutTimeout+0x66>
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 8003342:	9b03      	ldr	r3, [sp, #12]
 8003344:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003346:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800334a:	701a      	strb	r2, [r3, #0]
  obqp->ptr++;
 800334c:	9b03      	ldr	r3, [sp, #12]
 800334e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003350:	1c5a      	adds	r2, r3, #1
 8003352:	9b03      	ldr	r3, [sp, #12]
 8003354:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8003356:	9b03      	ldr	r3, [sp, #12]
 8003358:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800335a:	9b03      	ldr	r3, [sp, #12]
 800335c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800335e:	429a      	cmp	r2, r3
 8003360:	d306      	bcc.n	8003370 <obqPutTimeout+0x60>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8003362:	9b03      	ldr	r3, [sp, #12]
 8003364:	699b      	ldr	r3, [r3, #24]
 8003366:	3b04      	subs	r3, #4
 8003368:	4619      	mov	r1, r3
 800336a:	9803      	ldr	r0, [sp, #12]
 800336c:	f7ff ff88 	bl	8003280 <obqPostFullBufferS>
  }

  osalSysUnlock();
 8003370:	f7ff fc2e 	bl	8002bd0 <osalSysUnlock.lto_priv.219>
  return MSG_OK;
 8003374:	2300      	movs	r3, #0
}
 8003376:	4618      	mov	r0, r3
 8003378:	b007      	add	sp, #28
 800337a:	f85d fb04 	ldr.w	pc, [sp], #4
 800337e:	bf00      	nop

08003380 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 8003380:	b500      	push	{lr}
 8003382:	b08b      	sub	sp, #44	; 0x2c
 8003384:	9003      	str	r0, [sp, #12]
 8003386:	9102      	str	r1, [sp, #8]
 8003388:	9201      	str	r2, [sp, #4]
 800338a:	9300      	str	r3, [sp, #0]
  size_t w = 0;
 800338c:	2300      	movs	r3, #0
 800338e:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 8003390:	f7ff fc16 	bl	8002bc0 <osalSysLock.lto_priv.228>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8003394:	f7ff fc24 	bl	8002be0 <osalOsGetSystemTimeX.lto_priv.246>
 8003398:	4602      	mov	r2, r0
 800339a:	9b00      	ldr	r3, [sp, #0]
 800339c:	4413      	add	r3, r2
 800339e:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 80033a0:	9b03      	ldr	r3, [sp, #12]
 80033a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80033a4:	2b00      	cmp	r3, #0
 80033a6:	d126      	bne.n	80033f6 <obqWriteTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80033a8:	9b00      	ldr	r3, [sp, #0]
 80033aa:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80033ae:	d002      	beq.n	80033b6 <obqWriteTimeout+0x36>
 80033b0:	9b00      	ldr	r3, [sp, #0]
 80033b2:	2b00      	cmp	r3, #0
 80033b4:	d105      	bne.n	80033c2 <obqWriteTimeout+0x42>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80033b6:	9900      	ldr	r1, [sp, #0]
 80033b8:	9803      	ldr	r0, [sp, #12]
 80033ba:	f7ff ff31 	bl	8003220 <obqGetEmptyBufferTimeoutS>
 80033be:	9007      	str	r0, [sp, #28]
 80033c0:	e012      	b.n	80033e8 <obqWriteTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80033c2:	f7ff fc0d 	bl	8002be0 <osalOsGetSystemTimeX.lto_priv.246>
 80033c6:	4602      	mov	r2, r0
 80033c8:	9b06      	ldr	r3, [sp, #24]
 80033ca:	1a9b      	subs	r3, r3, r2
 80033cc:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80033ce:	9a05      	ldr	r2, [sp, #20]
 80033d0:	9b00      	ldr	r3, [sp, #0]
 80033d2:	429a      	cmp	r2, r3
 80033d4:	d903      	bls.n	80033de <obqWriteTimeout+0x5e>
          osalSysUnlock();
 80033d6:	f7ff fbfb 	bl	8002bd0 <osalSysUnlock.lto_priv.219>
          return w;
 80033da:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80033dc:	e060      	b.n	80034a0 <obqWriteTimeout+0x120>
        }
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 80033de:	9905      	ldr	r1, [sp, #20]
 80033e0:	9803      	ldr	r0, [sp, #12]
 80033e2:	f7ff ff1d 	bl	8003220 <obqGetEmptyBufferTimeoutS>
 80033e6:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 80033e8:	9b07      	ldr	r3, [sp, #28]
 80033ea:	2b00      	cmp	r3, #0
 80033ec:	d003      	beq.n	80033f6 <obqWriteTimeout+0x76>
        osalSysUnlock();
 80033ee:	f7ff fbef 	bl	8002bd0 <osalSysUnlock.lto_priv.219>
        return w;
 80033f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80033f4:	e054      	b.n	80034a0 <obqWriteTimeout+0x120>
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 80033f6:	9b03      	ldr	r3, [sp, #12]
 80033f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80033fa:	461a      	mov	r2, r3
 80033fc:	9b03      	ldr	r3, [sp, #12]
 80033fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003400:	1ad3      	subs	r3, r2, r3
 8003402:	9308      	str	r3, [sp, #32]
    if (size > (n - w)) {
 8003404:	9a01      	ldr	r2, [sp, #4]
 8003406:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003408:	1ad3      	subs	r3, r2, r3
 800340a:	9a08      	ldr	r2, [sp, #32]
 800340c:	429a      	cmp	r2, r3
 800340e:	d903      	bls.n	8003418 <obqWriteTimeout+0x98>
      size = n - w;
 8003410:	9a01      	ldr	r2, [sp, #4]
 8003412:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003414:	1ad3      	subs	r3, r2, r3
 8003416:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8003418:	9b08      	ldr	r3, [sp, #32]
 800341a:	2b40      	cmp	r3, #64	; 0x40
 800341c:	d913      	bls.n	8003446 <obqWriteTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 800341e:	9b03      	ldr	r3, [sp, #12]
 8003420:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003422:	2240      	movs	r2, #64	; 0x40
 8003424:	9902      	ldr	r1, [sp, #8]
 8003426:	4618      	mov	r0, r3
 8003428:	f7fc ff7a 	bl	8000320 <memcpy>
      bp        += 64U;
 800342c:	9b02      	ldr	r3, [sp, #8]
 800342e:	3340      	adds	r3, #64	; 0x40
 8003430:	9302      	str	r3, [sp, #8]
      obqp->ptr += 64U;
 8003432:	9b03      	ldr	r3, [sp, #12]
 8003434:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003436:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800343a:	9b03      	ldr	r3, [sp, #12]
 800343c:	625a      	str	r2, [r3, #36]	; 0x24
      w         += 64U;
 800343e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003440:	3340      	adds	r3, #64	; 0x40
 8003442:	9309      	str	r3, [sp, #36]	; 0x24
 8003444:	e014      	b.n	8003470 <obqWriteTimeout+0xf0>
    }
    else {
      memcpy(obqp->ptr, bp, size);
 8003446:	9b03      	ldr	r3, [sp, #12]
 8003448:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800344a:	9a08      	ldr	r2, [sp, #32]
 800344c:	9902      	ldr	r1, [sp, #8]
 800344e:	4618      	mov	r0, r3
 8003450:	f7fc ff66 	bl	8000320 <memcpy>
      bp        += size;
 8003454:	9a02      	ldr	r2, [sp, #8]
 8003456:	9b08      	ldr	r3, [sp, #32]
 8003458:	4413      	add	r3, r2
 800345a:	9302      	str	r3, [sp, #8]
      obqp->ptr += size;
 800345c:	9b03      	ldr	r3, [sp, #12]
 800345e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003460:	9b08      	ldr	r3, [sp, #32]
 8003462:	441a      	add	r2, r3
 8003464:	9b03      	ldr	r3, [sp, #12]
 8003466:	625a      	str	r2, [r3, #36]	; 0x24
      w         += size;
 8003468:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800346a:	9b08      	ldr	r3, [sp, #32]
 800346c:	4413      	add	r3, r2
 800346e:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8003470:	9b03      	ldr	r3, [sp, #12]
 8003472:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003474:	9b03      	ldr	r3, [sp, #12]
 8003476:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003478:	429a      	cmp	r2, r3
 800347a:	d306      	bcc.n	800348a <obqWriteTimeout+0x10a>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800347c:	9b03      	ldr	r3, [sp, #12]
 800347e:	699b      	ldr	r3, [r3, #24]
 8003480:	3b04      	subs	r3, #4
 8003482:	4619      	mov	r1, r3
 8003484:	9803      	ldr	r0, [sp, #12]
 8003486:	f7ff fefb 	bl	8003280 <obqPostFullBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 800348a:	f7ff fba1 	bl	8002bd0 <osalSysUnlock.lto_priv.219>
    if (w >= n) {
 800348e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8003490:	9b01      	ldr	r3, [sp, #4]
 8003492:	429a      	cmp	r2, r3
 8003494:	d301      	bcc.n	800349a <obqWriteTimeout+0x11a>
      return w;
 8003496:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003498:	e002      	b.n	80034a0 <obqWriteTimeout+0x120>
    }
    osalSysLock();
 800349a:	f7ff fb91 	bl	8002bc0 <osalSysLock.lto_priv.228>
 800349e:	e77f      	b.n	80033a0 <obqWriteTimeout+0x20>
  }
}
 80034a0:	4618      	mov	r0, r3
 80034a2:	b00b      	add	sp, #44	; 0x2c
 80034a4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080034b0 <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 80034b0:	b500      	push	{lr}
 80034b2:	b085      	sub	sp, #20
 80034b4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 80034b6:	f7fd fad3 	bl	8000a60 <chDbgCheckClassI>

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 80034ba:	9b01      	ldr	r3, [sp, #4]
 80034bc:	68da      	ldr	r2, [r3, #12]
 80034be:	9b01      	ldr	r3, [sp, #4]
 80034c0:	691b      	ldr	r3, [r3, #16]
 80034c2:	429a      	cmp	r2, r3
 80034c4:	d105      	bne.n	80034d2 <obqTryFlushI+0x22>
 80034c6:	9b01      	ldr	r3, [sp, #4]
 80034c8:	689b      	ldr	r3, [r3, #8]
 80034ca:	2b00      	cmp	r3, #0
 80034cc:	d001      	beq.n	80034d2 <obqTryFlushI+0x22>
 80034ce:	2301      	movs	r3, #1
 80034d0:	e000      	b.n	80034d4 <obqTryFlushI+0x24>
 80034d2:	2300      	movs	r3, #0
 80034d4:	f003 0301 	and.w	r3, r3, #1
 80034d8:	b2db      	uxtb	r3, r3
 80034da:	2b00      	cmp	r3, #0
 80034dc:	d02d      	beq.n	800353a <obqTryFlushI+0x8a>
 80034de:	9b01      	ldr	r3, [sp, #4]
 80034e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80034e2:	2b00      	cmp	r3, #0
 80034e4:	d029      	beq.n	800353a <obqTryFlushI+0x8a>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 80034e6:	9b01      	ldr	r3, [sp, #4]
 80034e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80034ea:	461a      	mov	r2, r3
 80034ec:	9b01      	ldr	r3, [sp, #4]
 80034ee:	68db      	ldr	r3, [r3, #12]
 80034f0:	1ad3      	subs	r3, r2, r3
 80034f2:	3b04      	subs	r3, #4
 80034f4:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 80034f6:	9b03      	ldr	r3, [sp, #12]
 80034f8:	2b00      	cmp	r3, #0
 80034fa:	d01e      	beq.n	800353a <obqTryFlushI+0x8a>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 80034fc:	9b01      	ldr	r3, [sp, #4]
 80034fe:	68db      	ldr	r3, [r3, #12]
 8003500:	9a03      	ldr	r2, [sp, #12]
 8003502:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 8003504:	9b01      	ldr	r3, [sp, #4]
 8003506:	689b      	ldr	r3, [r3, #8]
 8003508:	1e5a      	subs	r2, r3, #1
 800350a:	9b01      	ldr	r3, [sp, #4]
 800350c:	609a      	str	r2, [r3, #8]
      obqp->bwrptr += obqp->bsize;
 800350e:	9b01      	ldr	r3, [sp, #4]
 8003510:	68da      	ldr	r2, [r3, #12]
 8003512:	9b01      	ldr	r3, [sp, #4]
 8003514:	699b      	ldr	r3, [r3, #24]
 8003516:	441a      	add	r2, r3
 8003518:	9b01      	ldr	r3, [sp, #4]
 800351a:	60da      	str	r2, [r3, #12]
      if (obqp->bwrptr >= obqp->btop) {
 800351c:	9b01      	ldr	r3, [sp, #4]
 800351e:	68da      	ldr	r2, [r3, #12]
 8003520:	9b01      	ldr	r3, [sp, #4]
 8003522:	695b      	ldr	r3, [r3, #20]
 8003524:	429a      	cmp	r2, r3
 8003526:	d303      	bcc.n	8003530 <obqTryFlushI+0x80>
        obqp->bwrptr = obqp->buffers;
 8003528:	9b01      	ldr	r3, [sp, #4]
 800352a:	6a1a      	ldr	r2, [r3, #32]
 800352c:	9b01      	ldr	r3, [sp, #4]
 800352e:	60da      	str	r2, [r3, #12]
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 8003530:	9b01      	ldr	r3, [sp, #4]
 8003532:	2200      	movs	r2, #0
 8003534:	625a      	str	r2, [r3, #36]	; 0x24

      return true;
 8003536:	2301      	movs	r3, #1
 8003538:	e000      	b.n	800353c <obqTryFlushI+0x8c>
    }
  }
  return false;
 800353a:	2300      	movs	r3, #0
}
 800353c:	4618      	mov	r0, r3
 800353e:	b005      	add	sp, #20
 8003540:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003550 <_mmcsd_get_slice>:
 *
 * @notapi
 */
uint32_t _mmcsd_get_slice(const uint32_t *data,
                          uint32_t end,
                          uint32_t start) {
 8003550:	b500      	push	{lr}
 8003552:	b089      	sub	sp, #36	; 0x24
 8003554:	9003      	str	r0, [sp, #12]
 8003556:	9102      	str	r1, [sp, #8]
 8003558:	9201      	str	r2, [sp, #4]
  unsigned startidx, endidx, startoff;
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));
 800355a:	9a02      	ldr	r2, [sp, #8]
 800355c:	9b01      	ldr	r3, [sp, #4]
 800355e:	429a      	cmp	r2, r3
 8003560:	d304      	bcc.n	800356c <_mmcsd_get_slice+0x1c>
 8003562:	9a02      	ldr	r2, [sp, #8]
 8003564:	9b01      	ldr	r3, [sp, #4]
 8003566:	1ad3      	subs	r3, r2, r3
 8003568:	2b1f      	cmp	r3, #31
 800356a:	d902      	bls.n	8003572 <_mmcsd_get_slice+0x22>
 800356c:	481e      	ldr	r0, [pc, #120]	; (80035e8 <_mmcsd_get_slice+0x98>)
 800356e:	f7fd f94f 	bl	8000810 <chSysHalt>

  startidx = start / 32U;
 8003572:	9b01      	ldr	r3, [sp, #4]
 8003574:	095b      	lsrs	r3, r3, #5
 8003576:	9307      	str	r3, [sp, #28]
  startoff = start % 32U;
 8003578:	9b01      	ldr	r3, [sp, #4]
 800357a:	f003 031f 	and.w	r3, r3, #31
 800357e:	9306      	str	r3, [sp, #24]
  endidx   = end / 32U;
 8003580:	9b02      	ldr	r3, [sp, #8]
 8003582:	095b      	lsrs	r3, r3, #5
 8003584:	9305      	str	r3, [sp, #20]
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 8003586:	9b02      	ldr	r3, [sp, #8]
 8003588:	f003 031f 	and.w	r3, r3, #31
 800358c:	3301      	adds	r3, #1
 800358e:	2201      	movs	r2, #1
 8003590:	fa02 f303 	lsl.w	r3, r2, r3
 8003594:	3b01      	subs	r3, #1
 8003596:	9304      	str	r3, [sp, #16]

  /* One or two pieces?*/
  if (startidx < endidx) {
 8003598:	9a07      	ldr	r2, [sp, #28]
 800359a:	9b05      	ldr	r3, [sp, #20]
 800359c:	429a      	cmp	r2, r3
 800359e:	d214      	bcs.n	80035ca <_mmcsd_get_slice+0x7a>
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 80035a0:	9b07      	ldr	r3, [sp, #28]
 80035a2:	009b      	lsls	r3, r3, #2
 80035a4:	9a03      	ldr	r2, [sp, #12]
 80035a6:	4413      	add	r3, r2
 80035a8:	681a      	ldr	r2, [r3, #0]
 80035aa:	9b06      	ldr	r3, [sp, #24]
 80035ac:	40da      	lsrs	r2, r3
           ((data[endidx] & endmask) << (32U - startoff));
 80035ae:	9b05      	ldr	r3, [sp, #20]
 80035b0:	009b      	lsls	r3, r3, #2
 80035b2:	9903      	ldr	r1, [sp, #12]
 80035b4:	440b      	add	r3, r1
 80035b6:	6819      	ldr	r1, [r3, #0]
 80035b8:	9b04      	ldr	r3, [sp, #16]
 80035ba:	4019      	ands	r1, r3
 80035bc:	9b06      	ldr	r3, [sp, #24]
 80035be:	f1c3 0320 	rsb	r3, r3, #32
 80035c2:	fa01 f303 	lsl.w	r3, r1, r3
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 80035c6:	4313      	orrs	r3, r2
 80035c8:	e009      	b.n	80035de <_mmcsd_get_slice+0x8e>
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 80035ca:	9b07      	ldr	r3, [sp, #28]
 80035cc:	009b      	lsls	r3, r3, #2
 80035ce:	9a03      	ldr	r2, [sp, #12]
 80035d0:	4413      	add	r3, r2
 80035d2:	681a      	ldr	r2, [r3, #0]
 80035d4:	9b04      	ldr	r3, [sp, #16]
 80035d6:	401a      	ands	r2, r3
 80035d8:	9b06      	ldr	r3, [sp, #24]
 80035da:	fa22 f303 	lsr.w	r3, r2, r3
}
 80035de:	4618      	mov	r0, r3
 80035e0:	b009      	add	sp, #36	; 0x24
 80035e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80035e6:	bf00      	nop
 80035e8:	0800a7d0 	.word	0x0800a7d0
 80035ec:	00000000 	.word	0x00000000

080035f0 <_mmcsd_get_capacity>:
 * @return              The card capacity.
 * @retval 0            CSD format error
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
 80035f0:	b500      	push	{lr}
 80035f2:	b087      	sub	sp, #28
 80035f4:	9001      	str	r0, [sp, #4]
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);
 80035f6:	9b01      	ldr	r3, [sp, #4]
 80035f8:	2b00      	cmp	r3, #0
 80035fa:	d102      	bne.n	8003602 <_mmcsd_get_capacity+0x12>
 80035fc:	481b      	ldr	r0, [pc, #108]	; (800366c <_mmcsd_get_capacity+0x7c>)
 80035fe:	f7fd f907 	bl	8000810 <chSysHalt>

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8003602:	227e      	movs	r2, #126	; 0x7e
 8003604:	217f      	movs	r1, #127	; 0x7f
 8003606:	9801      	ldr	r0, [sp, #4]
 8003608:	f7ff ffa2 	bl	8003550 <_mmcsd_get_slice>
 800360c:	4603      	mov	r3, r0
 800360e:	2b00      	cmp	r3, #0
 8003610:	d002      	beq.n	8003618 <_mmcsd_get_capacity+0x28>
 8003612:	2b01      	cmp	r3, #1
 8003614:	d01c      	beq.n	8003650 <_mmcsd_get_capacity+0x60>
 8003616:	e024      	b.n	8003662 <_mmcsd_get_capacity+0x72>
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 8003618:	223e      	movs	r2, #62	; 0x3e
 800361a:	2149      	movs	r1, #73	; 0x49
 800361c:	9801      	ldr	r0, [sp, #4]
 800361e:	f7ff ff97 	bl	8003550 <_mmcsd_get_slice>
 8003622:	9005      	str	r0, [sp, #20]
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 8003624:	222f      	movs	r2, #47	; 0x2f
 8003626:	2131      	movs	r1, #49	; 0x31
 8003628:	9801      	ldr	r0, [sp, #4]
 800362a:	f7ff ff91 	bl	8003550 <_mmcsd_get_slice>
 800362e:	9004      	str	r0, [sp, #16]
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 8003630:	2250      	movs	r2, #80	; 0x50
 8003632:	2153      	movs	r1, #83	; 0x53
 8003634:	9801      	ldr	r0, [sp, #4]
 8003636:	f7ff ff8b 	bl	8003550 <_mmcsd_get_slice>
 800363a:	9003      	str	r0, [sp, #12]
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 800363c:	9b05      	ldr	r3, [sp, #20]
 800363e:	1c5a      	adds	r2, r3, #1
 8003640:	9b04      	ldr	r3, [sp, #16]
 8003642:	3302      	adds	r3, #2
 8003644:	409a      	lsls	r2, r3
 8003646:	9b03      	ldr	r3, [sp, #12]
 8003648:	3b09      	subs	r3, #9
 800364a:	fa02 f303 	lsl.w	r3, r2, r3
 800364e:	e009      	b.n	8003664 <_mmcsd_get_capacity+0x74>
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
 8003650:	2230      	movs	r2, #48	; 0x30
 8003652:	2145      	movs	r1, #69	; 0x45
 8003654:	9801      	ldr	r0, [sp, #4]
 8003656:	f7ff ff7b 	bl	8003550 <_mmcsd_get_slice>
 800365a:	4603      	mov	r3, r0
 800365c:	3301      	adds	r3, #1
 800365e:	029b      	lsls	r3, r3, #10
 8003660:	e000      	b.n	8003664 <_mmcsd_get_capacity+0x74>
  default:
    /* Reserved value detected.*/
    break;
  }
  return 0U;
 8003662:	2300      	movs	r3, #0
}
 8003664:	4618      	mov	r0, r3
 8003666:	b007      	add	sp, #28
 8003668:	f85d fb04 	ldr.w	pc, [sp], #4
 800366c:	0800a7f0 	.word	0x0800a7f0

08003670 <_mmcsd_get_capacity_ext>:
 *
 * @return              The card capacity.
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {
 8003670:	b500      	push	{lr}
 8003672:	b083      	sub	sp, #12
 8003674:	9001      	str	r0, [sp, #4]

  osalDbgCheck(NULL != ext_csd);
 8003676:	9b01      	ldr	r3, [sp, #4]
 8003678:	2b00      	cmp	r3, #0
 800367a:	d102      	bne.n	8003682 <_mmcsd_get_capacity_ext+0x12>
 800367c:	480c      	ldr	r0, [pc, #48]	; (80036b0 <_mmcsd_get_capacity_ext+0x40>)
 800367e:	f7fd f8c7 	bl	8000810 <chSysHalt>

  return ((uint32_t)ext_csd[215] << 24U) +
 8003682:	9b01      	ldr	r3, [sp, #4]
 8003684:	33d7      	adds	r3, #215	; 0xd7
 8003686:	781b      	ldrb	r3, [r3, #0]
 8003688:	061a      	lsls	r2, r3, #24
         ((uint32_t)ext_csd[214] << 16U) +
 800368a:	9b01      	ldr	r3, [sp, #4]
 800368c:	33d6      	adds	r3, #214	; 0xd6
 800368e:	781b      	ldrb	r3, [r3, #0]
 8003690:	041b      	lsls	r3, r3, #16
  return ((uint32_t)ext_csd[215] << 24U) +
 8003692:	441a      	add	r2, r3
         ((uint32_t)ext_csd[213] << 8U)  +
 8003694:	9b01      	ldr	r3, [sp, #4]
 8003696:	33d5      	adds	r3, #213	; 0xd5
 8003698:	781b      	ldrb	r3, [r3, #0]
 800369a:	021b      	lsls	r3, r3, #8
         ((uint32_t)ext_csd[214] << 16U) +
 800369c:	4413      	add	r3, r2
         (uint32_t)ext_csd[212];
 800369e:	9a01      	ldr	r2, [sp, #4]
 80036a0:	32d4      	adds	r2, #212	; 0xd4
 80036a2:	7812      	ldrb	r2, [r2, #0]
         ((uint32_t)ext_csd[213] << 8U)  +
 80036a4:	4413      	add	r3, r2
}
 80036a6:	4618      	mov	r0, r3
 80036a8:	b003      	add	sp, #12
 80036aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80036ae:	bf00      	nop
 80036b0:	0800a810 	.word	0x0800a810
	...

080036c0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 80036c0:	b500      	push	{lr}
 80036c2:	b083      	sub	sp, #12
 80036c4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 80036c6:	9801      	ldr	r0, [sp, #4]
 80036c8:	f7fe f9e2 	bl	8001a90 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 80036cc:	b003      	add	sp, #12
 80036ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80036d2:	bf00      	nop
	...

080036e0 <i2cInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void i2cInit(void) {
 80036e0:	b508      	push	{r3, lr}

  i2c_lld_init();
 80036e2:	f003 f9c5 	bl	8006a70 <i2c_lld_init>
}
 80036e6:	bd08      	pop	{r3, pc}
	...

080036f0 <i2cObjectInit>:
 *
 * @param[out] i2cp     pointer to the @p I2CDriver object
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {
 80036f0:	b500      	push	{lr}
 80036f2:	b083      	sub	sp, #12
 80036f4:	9001      	str	r0, [sp, #4]

  i2cp->state  = I2C_STOP;
 80036f6:	9b01      	ldr	r3, [sp, #4]
 80036f8:	2201      	movs	r2, #1
 80036fa:	701a      	strb	r2, [r3, #0]
  i2cp->config = NULL;
 80036fc:	9b01      	ldr	r3, [sp, #4]
 80036fe:	2200      	movs	r2, #0
 8003700:	605a      	str	r2, [r3, #4]

#if I2C_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&i2cp->mutex);
 8003702:	9b01      	ldr	r3, [sp, #4]
 8003704:	330c      	adds	r3, #12
 8003706:	4618      	mov	r0, r3
 8003708:	f7ff ffda 	bl	80036c0 <osalMutexObjectInit>
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
 800370c:	b003      	add	sp, #12
 800370e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003712:	bf00      	nop
	...

08003720 <port_lock.lto_priv.121>:
static inline void port_lock(void) {
 8003720:	b082      	sub	sp, #8
 8003722:	2320      	movs	r3, #32
 8003724:	9301      	str	r3, [sp, #4]
 8003726:	9b01      	ldr	r3, [sp, #4]
 8003728:	f383 8811 	msr	BASEPRI, r3
}
 800372c:	b002      	add	sp, #8
 800372e:	4770      	bx	lr

08003730 <port_unlock.lto_priv.91>:
static inline void port_unlock(void) {
 8003730:	b082      	sub	sp, #8
 8003732:	2300      	movs	r3, #0
 8003734:	9301      	str	r3, [sp, #4]
 8003736:	9b01      	ldr	r3, [sp, #4]
 8003738:	f383 8811 	msr	BASEPRI, r3
}
 800373c:	b002      	add	sp, #8
 800373e:	4770      	bx	lr

08003740 <chSysLock.lto_priv.64>:
static inline void chSysLock(void) {
 8003740:	b508      	push	{r3, lr}
  port_lock();
 8003742:	f7ff ffed 	bl	8003720 <port_lock.lto_priv.121>
  _stats_start_measure_crit_thd();
 8003746:	f7fe f8cb 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800374a:	f7fd f8e9 	bl	8000920 <_dbg_check_lock>
}
 800374e:	bd08      	pop	{r3, pc}

08003750 <chSysUnlock.lto_priv.23>:
static inline void chSysUnlock(void) {
 8003750:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8003752:	f7fd f8fd 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8003756:	f7fe f8cb 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800375a:	4b09      	ldr	r3, [pc, #36]	; (8003780 <chSysUnlock.lto_priv.23+0x30>)
 800375c:	681b      	ldr	r3, [r3, #0]
 800375e:	4a08      	ldr	r2, [pc, #32]	; (8003780 <chSysUnlock.lto_priv.23+0x30>)
 8003760:	4293      	cmp	r3, r2
 8003762:	d00a      	beq.n	800377a <chSysUnlock.lto_priv.23+0x2a>
 8003764:	4b06      	ldr	r3, [pc, #24]	; (8003780 <chSysUnlock.lto_priv.23+0x30>)
 8003766:	699b      	ldr	r3, [r3, #24]
 8003768:	689a      	ldr	r2, [r3, #8]
 800376a:	4b05      	ldr	r3, [pc, #20]	; (8003780 <chSysUnlock.lto_priv.23+0x30>)
 800376c:	681b      	ldr	r3, [r3, #0]
 800376e:	689b      	ldr	r3, [r3, #8]
 8003770:	429a      	cmp	r2, r3
 8003772:	d202      	bcs.n	800377a <chSysUnlock.lto_priv.23+0x2a>
 8003774:	4803      	ldr	r0, [pc, #12]	; (8003784 <chSysUnlock.lto_priv.23+0x34>)
 8003776:	f7fd f84b 	bl	8000810 <chSysHalt>
  port_unlock();
 800377a:	f7ff ffd9 	bl	8003730 <port_unlock.lto_priv.91>
}
 800377e:	bd08      	pop	{r3, pc}
 8003780:	20002128 	.word	0x20002128
 8003784:	0800a8b0 	.word	0x0800a8b0
	...

08003790 <osalSysLock.lto_priv.230>:
static inline void osalSysLock(void) {
 8003790:	b508      	push	{r3, lr}
  chSysLock();
 8003792:	f7ff ffd5 	bl	8003740 <chSysLock.lto_priv.64>
}
 8003796:	bd08      	pop	{r3, pc}
	...

080037a0 <osalSysUnlock.lto_priv.221>:
static inline void osalSysUnlock(void) {
 80037a0:	b508      	push	{r3, lr}
  chSysUnlock();
 80037a2:	f7ff ffd5 	bl	8003750 <chSysUnlock.lto_priv.23>
}
 80037a6:	bd08      	pop	{r3, pc}
	...

080037b0 <osalThreadSleep.lto_priv.217>:
static inline void osalThreadSleep(systime_t time) {
 80037b0:	b500      	push	{lr}
 80037b2:	b083      	sub	sp, #12
 80037b4:	9001      	str	r0, [sp, #4]
  chThdSleep(time);
 80037b6:	9801      	ldr	r0, [sp, #4]
 80037b8:	f7fd fe6a 	bl	8001490 <chThdSleep>
}
 80037bc:	b003      	add	sp, #12
 80037be:	f85d fb04 	ldr.w	pc, [sp], #4
 80037c2:	bf00      	nop
	...

080037d0 <mode_detect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mode_detect(SDCDriver *sdcp) {
 80037d0:	b500      	push	{lr}
 80037d2:	b085      	sub	sp, #20
 80037d4:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  /* V2.0 cards detection.*/
  if (!sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_IF_COND,
 80037d6:	ab03      	add	r3, sp, #12
 80037d8:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 80037dc:	2108      	movs	r1, #8
 80037de:	9801      	ldr	r0, [sp, #4]
 80037e0:	f005 f8f6 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 80037e4:	4603      	mov	r3, r0
 80037e6:	f083 0301 	eor.w	r3, r3, #1
 80037ea:	b2db      	uxtb	r3, r3
 80037ec:	2b00      	cmp	r3, #0
 80037ee:	d01a      	beq.n	8003826 <mode_detect+0x56>
                                  MMCSD_CMD8_PATTERN, resp)) {
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 80037f0:	9b01      	ldr	r3, [sp, #4]
 80037f2:	2201      	movs	r2, #1
 80037f4:	631a      	str	r2, [r3, #48]	; 0x30
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 80037f6:	9b03      	ldr	r3, [sp, #12]
 80037f8:	0a1b      	lsrs	r3, r3, #8
 80037fa:	f003 030f 	and.w	r3, r3, #15
 80037fe:	2b01      	cmp	r3, #1
 8003800:	d001      	beq.n	8003806 <mode_detect+0x36>
      return HAL_FAILED;
 8003802:	2301      	movs	r3, #1
 8003804:	e02a      	b.n	800385c <mode_detect+0x8c>
    }
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8003806:	ab03      	add	r3, sp, #12
 8003808:	2200      	movs	r2, #0
 800380a:	2137      	movs	r1, #55	; 0x37
 800380c:	9801      	ldr	r0, [sp, #4]
 800380e:	f005 f8df 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8003812:	4603      	mov	r3, r0
 8003814:	2b00      	cmp	r3, #0
 8003816:	d104      	bne.n	8003822 <mode_detect+0x52>
        MMCSD_R1_ERROR(resp[0])) {
 8003818:	9a03      	ldr	r2, [sp, #12]
 800381a:	4b12      	ldr	r3, [pc, #72]	; (8003864 <mode_detect+0x94>)
 800381c:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 800381e:	2b00      	cmp	r3, #0
 8003820:	d01b      	beq.n	800385a <mode_detect+0x8a>
      return HAL_FAILED;
 8003822:	2301      	movs	r3, #1
 8003824:	e01a      	b.n	800385c <mode_detect+0x8c>
    }
  }
  else {
    /* MMC or SD V1.1 detection.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8003826:	ab03      	add	r3, sp, #12
 8003828:	2200      	movs	r2, #0
 800382a:	2137      	movs	r1, #55	; 0x37
 800382c:	9801      	ldr	r0, [sp, #4]
 800382e:	f005 f8cf 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8003832:	4603      	mov	r3, r0
 8003834:	2b00      	cmp	r3, #0
 8003836:	d104      	bne.n	8003842 <mode_detect+0x72>
        MMCSD_R1_ERROR(resp[0])) {
 8003838:	9a03      	ldr	r2, [sp, #12]
 800383a:	4b0a      	ldr	r3, [pc, #40]	; (8003864 <mode_detect+0x94>)
 800383c:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 800383e:	2b00      	cmp	r3, #0
 8003840:	d003      	beq.n	800384a <mode_detect+0x7a>
      sdcp->cardmode = SDC_MODE_CARDTYPE_MMC;
 8003842:	9b01      	ldr	r3, [sp, #4]
 8003844:	2202      	movs	r2, #2
 8003846:	631a      	str	r2, [r3, #48]	; 0x30
 8003848:	e007      	b.n	800385a <mode_detect+0x8a>
    }
    else {
      sdcp->cardmode = SDC_MODE_CARDTYPE_SDV11;
 800384a:	9b01      	ldr	r3, [sp, #4]
 800384c:	2200      	movs	r2, #0
 800384e:	631a      	str	r2, [r3, #48]	; 0x30
    
      /* Reset error flag illegal command.*/
      sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8003850:	2200      	movs	r2, #0
 8003852:	2100      	movs	r1, #0
 8003854:	9801      	ldr	r0, [sp, #4]
 8003856:	f005 f85b 	bl	8008910 <sdc_lld_send_cmd_none>
    }
  }

  return HAL_SUCCESS;
 800385a:	2300      	movs	r3, #0
}
 800385c:	4618      	mov	r0, r3
 800385e:	b005      	add	sp, #20
 8003860:	f85d fb04 	ldr.w	pc, [sp], #4
 8003864:	fdffe008 	.word	0xfdffe008
	...

08003870 <mmc_init>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_init(SDCDriver *sdcp) {
 8003870:	b500      	push	{lr}
 8003872:	b087      	sub	sp, #28
 8003874:	9001      	str	r0, [sp, #4]
  uint32_t ocr;
  unsigned i;
  uint32_t resp[1];

  ocr = 0xC0FF8000U;
 8003876:	4b17      	ldr	r3, [pc, #92]	; (80038d4 <mmc_init+0x64>)
 8003878:	9304      	str	r3, [sp, #16]
  i = 0;
 800387a:	2300      	movs	r3, #0
 800387c:	9305      	str	r3, [sp, #20]
  while (true) {
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_INIT, ocr, resp)) {
 800387e:	ab03      	add	r3, sp, #12
 8003880:	9a04      	ldr	r2, [sp, #16]
 8003882:	2101      	movs	r1, #1
 8003884:	9801      	ldr	r0, [sp, #4]
 8003886:	f005 f863 	bl	8008950 <sdc_lld_send_cmd_short>
 800388a:	4603      	mov	r3, r0
 800388c:	2b00      	cmp	r3, #0
 800388e:	d001      	beq.n	8003894 <mmc_init+0x24>
      return HAL_FAILED;
 8003890:	2301      	movs	r3, #1
 8003892:	e01b      	b.n	80038cc <mmc_init+0x5c>
    }
    if ((resp[0] & 0x80000000U) != 0U) {
 8003894:	9b03      	ldr	r3, [sp, #12]
 8003896:	2b00      	cmp	r3, #0
 8003898:	da0c      	bge.n	80038b4 <mmc_init+0x44>
      if ((resp[0] & 0x40000000U) != 0U) {
 800389a:	9b03      	ldr	r3, [sp, #12]
 800389c:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 80038a0:	2b00      	cmp	r3, #0
 80038a2:	d005      	beq.n	80038b0 <mmc_init+0x40>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 80038a4:	9b01      	ldr	r3, [sp, #4]
 80038a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80038a8:	f043 0210 	orr.w	r2, r3, #16
 80038ac:	9b01      	ldr	r3, [sp, #4]
 80038ae:	631a      	str	r2, [r3, #48]	; 0x30
      return HAL_FAILED;
    }
    osalThreadSleepMilliseconds(10);
  }

  return HAL_SUCCESS;
 80038b0:	2300      	movs	r3, #0
 80038b2:	e00b      	b.n	80038cc <mmc_init+0x5c>
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 80038b4:	9b05      	ldr	r3, [sp, #20]
 80038b6:	3301      	adds	r3, #1
 80038b8:	9305      	str	r3, [sp, #20]
 80038ba:	9b05      	ldr	r3, [sp, #20]
 80038bc:	2b63      	cmp	r3, #99	; 0x63
 80038be:	d901      	bls.n	80038c4 <mmc_init+0x54>
      return HAL_FAILED;
 80038c0:	2301      	movs	r3, #1
 80038c2:	e003      	b.n	80038cc <mmc_init+0x5c>
    osalThreadSleepMilliseconds(10);
 80038c4:	2064      	movs	r0, #100	; 0x64
 80038c6:	f7ff ff73 	bl	80037b0 <osalThreadSleep.lto_priv.217>
 80038ca:	e7d8      	b.n	800387e <mmc_init+0xe>
}
 80038cc:	4618      	mov	r0, r3
 80038ce:	b007      	add	sp, #28
 80038d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80038d4:	c0ff8000 	.word	0xc0ff8000
	...

080038e0 <sdc_init>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_init(SDCDriver *sdcp) {
 80038e0:	b500      	push	{lr}
 80038e2:	b087      	sub	sp, #28
 80038e4:	9001      	str	r0, [sp, #4]
  unsigned i;
  uint32_t ocr;
  uint32_t resp[1];

  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_SDV20) {
 80038e6:	9b01      	ldr	r3, [sp, #4]
 80038e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80038ea:	f003 030f 	and.w	r3, r3, #15
 80038ee:	2b01      	cmp	r3, #1
 80038f0:	d102      	bne.n	80038f8 <sdc_init+0x18>
    ocr = SDC_INIT_OCR_V20;
 80038f2:	4b21      	ldr	r3, [pc, #132]	; (8003978 <sdc_init+0x98>)
 80038f4:	9304      	str	r3, [sp, #16]
 80038f6:	e001      	b.n	80038fc <sdc_init+0x1c>
  }
  else {
    ocr = SDC_INIT_OCR;
 80038f8:	4b20      	ldr	r3, [pc, #128]	; (800397c <sdc_init+0x9c>)
 80038fa:	9304      	str	r3, [sp, #16]
  }

  i = 0;
 80038fc:	2300      	movs	r3, #0
 80038fe:	9305      	str	r3, [sp, #20]
  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8003900:	ab03      	add	r3, sp, #12
 8003902:	2200      	movs	r2, #0
 8003904:	2137      	movs	r1, #55	; 0x37
 8003906:	9801      	ldr	r0, [sp, #4]
 8003908:	f005 f862 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 800390c:	4603      	mov	r3, r0
 800390e:	2b00      	cmp	r3, #0
 8003910:	d104      	bne.n	800391c <sdc_init+0x3c>
        MMCSD_R1_ERROR(resp[0])) {
 8003912:	9a03      	ldr	r2, [sp, #12]
 8003914:	4b1a      	ldr	r3, [pc, #104]	; (8003980 <sdc_init+0xa0>)
 8003916:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8003918:	2b00      	cmp	r3, #0
 800391a:	d001      	beq.n	8003920 <sdc_init+0x40>
      return HAL_FAILED;
 800391c:	2301      	movs	r3, #1
 800391e:	e026      	b.n	800396e <sdc_init+0x8e>
    }
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_APP_OP_COND, ocr, resp)) {
 8003920:	ab03      	add	r3, sp, #12
 8003922:	9a04      	ldr	r2, [sp, #16]
 8003924:	2129      	movs	r1, #41	; 0x29
 8003926:	9801      	ldr	r0, [sp, #4]
 8003928:	f005 f812 	bl	8008950 <sdc_lld_send_cmd_short>
 800392c:	4603      	mov	r3, r0
 800392e:	2b00      	cmp	r3, #0
 8003930:	d001      	beq.n	8003936 <sdc_init+0x56>
      return HAL_FAILED;
 8003932:	2301      	movs	r3, #1
 8003934:	e01b      	b.n	800396e <sdc_init+0x8e>
    }
    if ((resp[0] & 0x80000000U) != 0U) {
 8003936:	9b03      	ldr	r3, [sp, #12]
 8003938:	2b00      	cmp	r3, #0
 800393a:	da0c      	bge.n	8003956 <sdc_init+0x76>
      if ((resp[0] & 0x40000000U) != 0U) {
 800393c:	9b03      	ldr	r3, [sp, #12]
 800393e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8003942:	2b00      	cmp	r3, #0
 8003944:	d005      	beq.n	8003952 <sdc_init+0x72>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 8003946:	9b01      	ldr	r3, [sp, #4]
 8003948:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800394a:	f043 0210 	orr.w	r2, r3, #16
 800394e:	9b01      	ldr	r3, [sp, #4]
 8003950:	631a      	str	r2, [r3, #48]	; 0x30
      return HAL_FAILED;
    }
    osalThreadSleepMilliseconds(10);
  }

  return HAL_SUCCESS;
 8003952:	2300      	movs	r3, #0
 8003954:	e00b      	b.n	800396e <sdc_init+0x8e>
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8003956:	9b05      	ldr	r3, [sp, #20]
 8003958:	3301      	adds	r3, #1
 800395a:	9305      	str	r3, [sp, #20]
 800395c:	9b05      	ldr	r3, [sp, #20]
 800395e:	2b63      	cmp	r3, #99	; 0x63
 8003960:	d901      	bls.n	8003966 <sdc_init+0x86>
      return HAL_FAILED;
 8003962:	2301      	movs	r3, #1
 8003964:	e003      	b.n	800396e <sdc_init+0x8e>
    osalThreadSleepMilliseconds(10);
 8003966:	2064      	movs	r0, #100	; 0x64
 8003968:	f7ff ff22 	bl	80037b0 <osalThreadSleep.lto_priv.217>
 800396c:	e7c8      	b.n	8003900 <sdc_init+0x20>
}
 800396e:	4618      	mov	r0, r3
 8003970:	b007      	add	sp, #28
 8003972:	f85d fb04 	ldr.w	pc, [sp], #4
 8003976:	bf00      	nop
 8003978:	50ff8000 	.word	0x50ff8000
 800397c:	80100000 	.word	0x80100000
 8003980:	fdffe008 	.word	0xfdffe008
	...

08003990 <mmc_cmd6_construct>:
 * @return              CMD6 argument.
 *
 * @notapi
 */
static uint32_t mmc_cmd6_construct(mmc_switch_t access, uint32_t idx,
                                   uint32_t value, uint32_t cmd_set) {
 8003990:	b500      	push	{lr}
 8003992:	b085      	sub	sp, #20
 8003994:	9102      	str	r1, [sp, #8]
 8003996:	9201      	str	r2, [sp, #4]
 8003998:	9300      	str	r3, [sp, #0]
 800399a:	4603      	mov	r3, r0
 800399c:	f88d 300f 	strb.w	r3, [sp, #15]

  osalDbgAssert(idx <= 191U, "This field is not writable");
 80039a0:	9b02      	ldr	r3, [sp, #8]
 80039a2:	2bbf      	cmp	r3, #191	; 0xbf
 80039a4:	d902      	bls.n	80039ac <mmc_cmd6_construct+0x1c>
 80039a6:	480c      	ldr	r0, [pc, #48]	; (80039d8 <mmc_cmd6_construct+0x48>)
 80039a8:	f7fc ff32 	bl	8000810 <chSysHalt>
  osalDbgAssert(cmd_set < 8U, "This field has only 3 bits");
 80039ac:	9b00      	ldr	r3, [sp, #0]
 80039ae:	2b07      	cmp	r3, #7
 80039b0:	d902      	bls.n	80039b8 <mmc_cmd6_construct+0x28>
 80039b2:	4809      	ldr	r0, [pc, #36]	; (80039d8 <mmc_cmd6_construct+0x48>)
 80039b4:	f7fc ff2c 	bl	8000810 <chSysHalt>

  return ((uint32_t)access << 24U) | (idx << 16U) | (value << 8U) | cmd_set;
 80039b8:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80039bc:	061a      	lsls	r2, r3, #24
 80039be:	9b02      	ldr	r3, [sp, #8]
 80039c0:	041b      	lsls	r3, r3, #16
 80039c2:	431a      	orrs	r2, r3
 80039c4:	9b01      	ldr	r3, [sp, #4]
 80039c6:	021b      	lsls	r3, r3, #8
 80039c8:	431a      	orrs	r2, r3
 80039ca:	9b00      	ldr	r3, [sp, #0]
 80039cc:	4313      	orrs	r3, r2
}
 80039ce:	4618      	mov	r0, r3
 80039d0:	b005      	add	sp, #20
 80039d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80039d6:	bf00      	nop
 80039d8:	0800a850 	.word	0x0800a850
 80039dc:	00000000 	.word	0x00000000

080039e0 <sdc_cmd6_construct>:
 *
 * @notapi
 */
static uint32_t sdc_cmd6_construct(sd_switch_t mode,
                                   sd_switch_function_t function,
                                   uint32_t value) {
 80039e0:	b500      	push	{lr}
 80039e2:	b085      	sub	sp, #20
 80039e4:	4603      	mov	r3, r0
 80039e6:	9200      	str	r2, [sp, #0]
 80039e8:	f88d 3007 	strb.w	r3, [sp, #7]
 80039ec:	460b      	mov	r3, r1
 80039ee:	f88d 3006 	strb.w	r3, [sp, #6]
  uint32_t ret = 0xFFFFFF;
 80039f2:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80039f6:	9303      	str	r3, [sp, #12]

  osalDbgAssert((value < 16U), "This field has only 4 bits");
 80039f8:	9b00      	ldr	r3, [sp, #0]
 80039fa:	2b0f      	cmp	r3, #15
 80039fc:	d902      	bls.n	8003a04 <sdc_cmd6_construct+0x24>
 80039fe:	480f      	ldr	r0, [pc, #60]	; (8003a3c <sdc_cmd6_construct+0x5c>)
 8003a00:	f7fc ff06 	bl	8000810 <chSysHalt>

  ret &= ~((uint32_t)0xFU << ((uint32_t)function * 4U));
 8003a04:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8003a08:	009b      	lsls	r3, r3, #2
 8003a0a:	220f      	movs	r2, #15
 8003a0c:	fa02 f303 	lsl.w	r3, r2, r3
 8003a10:	43db      	mvns	r3, r3
 8003a12:	9a03      	ldr	r2, [sp, #12]
 8003a14:	4013      	ands	r3, r2
 8003a16:	9303      	str	r3, [sp, #12]
  ret |= value << ((uint32_t)function * 4U);
 8003a18:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8003a1c:	009b      	lsls	r3, r3, #2
 8003a1e:	9a00      	ldr	r2, [sp, #0]
 8003a20:	fa02 f303 	lsl.w	r3, r2, r3
 8003a24:	9a03      	ldr	r2, [sp, #12]
 8003a26:	4313      	orrs	r3, r2
 8003a28:	9303      	str	r3, [sp, #12]
  return ret | ((uint32_t)mode << 31U);
 8003a2a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003a2e:	07da      	lsls	r2, r3, #31
 8003a30:	9b03      	ldr	r3, [sp, #12]
 8003a32:	4313      	orrs	r3, r2
}
 8003a34:	4618      	mov	r0, r3
 8003a36:	b005      	add	sp, #20
 8003a38:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a3c:	0800a870 	.word	0x0800a870

08003a40 <sdc_cmd6_extract_info>:
 * @return              extracted answer.
 *
 * @notapi
 */
static uint16_t sdc_cmd6_extract_info(sd_switch_function_t function,
                                      const uint8_t *buf) {
 8003a40:	b084      	sub	sp, #16
 8003a42:	4603      	mov	r3, r0
 8003a44:	9100      	str	r1, [sp, #0]
 8003a46:	f88d 3007 	strb.w	r3, [sp, #7]

  unsigned start = 12U - ((unsigned)function * 2U);
 8003a4a:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8003a4e:	4613      	mov	r3, r2
 8003a50:	07db      	lsls	r3, r3, #31
 8003a52:	1a9b      	subs	r3, r3, r2
 8003a54:	005b      	lsls	r3, r3, #1
 8003a56:	330c      	adds	r3, #12
 8003a58:	9303      	str	r3, [sp, #12]

  return ((uint16_t)buf[start] << 8U) | (uint16_t)buf[start + 1U];
 8003a5a:	9a00      	ldr	r2, [sp, #0]
 8003a5c:	9b03      	ldr	r3, [sp, #12]
 8003a5e:	4413      	add	r3, r2
 8003a60:	781b      	ldrb	r3, [r3, #0]
 8003a62:	021b      	lsls	r3, r3, #8
 8003a64:	b21a      	sxth	r2, r3
 8003a66:	9b03      	ldr	r3, [sp, #12]
 8003a68:	3301      	adds	r3, #1
 8003a6a:	9900      	ldr	r1, [sp, #0]
 8003a6c:	440b      	add	r3, r1
 8003a6e:	781b      	ldrb	r3, [r3, #0]
 8003a70:	b21b      	sxth	r3, r3
 8003a72:	4313      	orrs	r3, r2
 8003a74:	b21b      	sxth	r3, r3
 8003a76:	b29b      	uxth	r3, r3
}
 8003a78:	4618      	mov	r0, r3
 8003a7a:	b004      	add	sp, #16
 8003a7c:	4770      	bx	lr
 8003a7e:	bf00      	nop

08003a80 <sdc_cmd6_check_status>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_cmd6_check_status(sd_switch_function_t function,
                                 const uint8_t *buf) {
 8003a80:	b084      	sub	sp, #16
 8003a82:	4603      	mov	r3, r0
 8003a84:	9100      	str	r1, [sp, #0]
 8003a86:	f88d 3007 	strb.w	r3, [sp, #7]

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 8003a8a:	9b00      	ldr	r3, [sp, #0]
 8003a8c:	330e      	adds	r3, #14
 8003a8e:	781b      	ldrb	r3, [r3, #0]
 8003a90:	041a      	lsls	r2, r3, #16
        ((uint32_t)buf[15] << 8U) |
 8003a92:	9b00      	ldr	r3, [sp, #0]
 8003a94:	330f      	adds	r3, #15
 8003a96:	781b      	ldrb	r3, [r3, #0]
 8003a98:	021b      	lsls	r3, r3, #8
  tmp = ((uint32_t)buf[14] << 16U) |
 8003a9a:	4313      	orrs	r3, r2
        (uint32_t)buf[16];
 8003a9c:	9a00      	ldr	r2, [sp, #0]
 8003a9e:	3210      	adds	r2, #16
 8003aa0:	7812      	ldrb	r2, [r2, #0]
  tmp = ((uint32_t)buf[14] << 16U) |
 8003aa2:	4313      	orrs	r3, r2
 8003aa4:	9303      	str	r3, [sp, #12]
  status = (tmp >> ((uint32_t)function * 4U)) & 0xFU;
 8003aa6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003aaa:	009b      	lsls	r3, r3, #2
 8003aac:	9a03      	ldr	r2, [sp, #12]
 8003aae:	fa22 f303 	lsr.w	r3, r2, r3
 8003ab2:	f003 030f 	and.w	r3, r3, #15
 8003ab6:	9302      	str	r3, [sp, #8]
  if (0xFU != status) {
 8003ab8:	9b02      	ldr	r3, [sp, #8]
 8003aba:	2b0f      	cmp	r3, #15
 8003abc:	d001      	beq.n	8003ac2 <sdc_cmd6_check_status+0x42>
    return HAL_SUCCESS;
 8003abe:	2300      	movs	r3, #0
 8003ac0:	e000      	b.n	8003ac4 <sdc_cmd6_check_status+0x44>
  }
  return HAL_FAILED;
 8003ac2:	2301      	movs	r3, #1
}
 8003ac4:	4618      	mov	r0, r3
 8003ac6:	b004      	add	sp, #16
 8003ac8:	4770      	bx	lr
 8003aca:	bf00      	nop
 8003acc:	0000      	movs	r0, r0
	...

08003ad0 <sdc_detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 8003ad0:	b5b0      	push	{r4, r5, r7, lr}
 8003ad2:	b088      	sub	sp, #32
 8003ad4:	af02      	add	r7, sp, #8
 8003ad6:	6078      	str	r0, [r7, #4]
 8003ad8:	6039      	str	r1, [r7, #0]
 8003ada:	466b      	mov	r3, sp
 8003adc:	461d      	mov	r5, r3
  uint32_t cmdarg;
  const size_t N = 64;
 8003ade:	2340      	movs	r3, #64	; 0x40
 8003ae0:	617b      	str	r3, [r7, #20]
  uint8_t tmp[N];
 8003ae2:	697b      	ldr	r3, [r7, #20]
 8003ae4:	3b01      	subs	r3, #1
 8003ae6:	613b      	str	r3, [r7, #16]
 8003ae8:	697b      	ldr	r3, [r7, #20]
 8003aea:	4619      	mov	r1, r3
 8003aec:	f04f 0200 	mov.w	r2, #0
 8003af0:	f04f 0300 	mov.w	r3, #0
 8003af4:	f04f 0400 	mov.w	r4, #0
 8003af8:	00d4      	lsls	r4, r2, #3
 8003afa:	ea44 7451 	orr.w	r4, r4, r1, lsr #29
 8003afe:	00cb      	lsls	r3, r1, #3
 8003b00:	697b      	ldr	r3, [r7, #20]
 8003b02:	4619      	mov	r1, r3
 8003b04:	f04f 0200 	mov.w	r2, #0
 8003b08:	f04f 0300 	mov.w	r3, #0
 8003b0c:	f04f 0400 	mov.w	r4, #0
 8003b10:	00d4      	lsls	r4, r2, #3
 8003b12:	ea44 7451 	orr.w	r4, r4, r1, lsr #29
 8003b16:	00cb      	lsls	r3, r1, #3
 8003b18:	697b      	ldr	r3, [r7, #20]
 8003b1a:	3307      	adds	r3, #7
 8003b1c:	08db      	lsrs	r3, r3, #3
 8003b1e:	00db      	lsls	r3, r3, #3
 8003b20:	ebad 0d03 	sub.w	sp, sp, r3
 8003b24:	ab02      	add	r3, sp, #8
 8003b26:	3300      	adds	r3, #0
 8003b28:	60fb      	str	r3, [r7, #12]

  /* Safe default.*/
  *clk = SDC_CLK_25MHz;
 8003b2a:	683b      	ldr	r3, [r7, #0]
 8003b2c:	2200      	movs	r2, #0
 8003b2e:	701a      	strb	r2, [r3, #0]

  /* Looks like only "high capacity" cards produce meaningful results during
     this clock detection procedure.*/
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8003b30:	687b      	ldr	r3, [r7, #4]
 8003b32:	3318      	adds	r3, #24
 8003b34:	227e      	movs	r2, #126	; 0x7e
 8003b36:	217f      	movs	r1, #127	; 0x7f
 8003b38:	4618      	mov	r0, r3
 8003b3a:	f7ff fd09 	bl	8003550 <_mmcsd_get_slice>
 8003b3e:	4603      	mov	r3, r0
 8003b40:	2b00      	cmp	r3, #0
 8003b42:	d104      	bne.n	8003b4e <sdc_detect_bus_clk+0x7e>
    *clk = SDC_CLK_25MHz;
 8003b44:	683b      	ldr	r3, [r7, #0]
 8003b46:	2200      	movs	r2, #0
 8003b48:	701a      	strb	r2, [r3, #0]
    return HAL_SUCCESS;
 8003b4a:	2300      	movs	r3, #0
 8003b4c:	e03c      	b.n	8003bc8 <sdc_detect_bus_clk+0xf8>
  }

  /* Read switch functions' register.*/
  if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, 0)) {
 8003b4e:	68f9      	ldr	r1, [r7, #12]
 8003b50:	2300      	movs	r3, #0
 8003b52:	9300      	str	r3, [sp, #0]
 8003b54:	2306      	movs	r3, #6
 8003b56:	697a      	ldr	r2, [r7, #20]
 8003b58:	6878      	ldr	r0, [r7, #4]
 8003b5a:	f004 ffc9 	bl	8008af0 <sdc_lld_read_special>
 8003b5e:	4603      	mov	r3, r0
 8003b60:	2b00      	cmp	r3, #0
 8003b62:	d001      	beq.n	8003b68 <sdc_detect_bus_clk+0x98>
    return HAL_FAILED;
 8003b64:	2301      	movs	r3, #1
 8003b66:	e02f      	b.n	8003bc8 <sdc_detect_bus_clk+0xf8>
  }

  /* Check card capabilities parsing acquired data.*/
  if ((sdc_cmd6_extract_info(SD_SWITCH_FUNCTION_SPEED, tmp) & 2U) == 2U) {
 8003b68:	68fb      	ldr	r3, [r7, #12]
 8003b6a:	4619      	mov	r1, r3
 8003b6c:	2000      	movs	r0, #0
 8003b6e:	f7ff ff67 	bl	8003a40 <sdc_cmd6_extract_info>
 8003b72:	4603      	mov	r3, r0
 8003b74:	f003 0302 	and.w	r3, r3, #2
 8003b78:	2b02      	cmp	r3, #2
 8003b7a:	d124      	bne.n	8003bc6 <sdc_detect_bus_clk+0xf6>
    /* Construct command to set the bus speed.*/
    cmdarg = sdc_cmd6_construct(SD_SWITCH_SET, SD_SWITCH_FUNCTION_SPEED, 1);
 8003b7c:	2201      	movs	r2, #1
 8003b7e:	2100      	movs	r1, #0
 8003b80:	2001      	movs	r0, #1
 8003b82:	f7ff ff2d 	bl	80039e0 <sdc_cmd6_construct>
 8003b86:	60b8      	str	r0, [r7, #8]

    /* Write constructed command and read operation status in single call.*/
    if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, cmdarg)) {
 8003b88:	68f9      	ldr	r1, [r7, #12]
 8003b8a:	68bb      	ldr	r3, [r7, #8]
 8003b8c:	9300      	str	r3, [sp, #0]
 8003b8e:	2306      	movs	r3, #6
 8003b90:	697a      	ldr	r2, [r7, #20]
 8003b92:	6878      	ldr	r0, [r7, #4]
 8003b94:	f004 ffac 	bl	8008af0 <sdc_lld_read_special>
 8003b98:	4603      	mov	r3, r0
 8003b9a:	2b00      	cmp	r3, #0
 8003b9c:	d001      	beq.n	8003ba2 <sdc_detect_bus_clk+0xd2>
      return HAL_FAILED;
 8003b9e:	2301      	movs	r3, #1
 8003ba0:	e012      	b.n	8003bc8 <sdc_detect_bus_clk+0xf8>
    }

    /* Check card answer for success status bits.*/
    if (HAL_SUCCESS == sdc_cmd6_check_status(SD_SWITCH_FUNCTION_SPEED, tmp)) {
 8003ba2:	68fb      	ldr	r3, [r7, #12]
 8003ba4:	4619      	mov	r1, r3
 8003ba6:	2000      	movs	r0, #0
 8003ba8:	f7ff ff6a 	bl	8003a80 <sdc_cmd6_check_status>
 8003bac:	4603      	mov	r3, r0
 8003bae:	f083 0301 	eor.w	r3, r3, #1
 8003bb2:	b2db      	uxtb	r3, r3
 8003bb4:	2b00      	cmp	r3, #0
 8003bb6:	d003      	beq.n	8003bc0 <sdc_detect_bus_clk+0xf0>
      *clk = SDC_CLK_50MHz;
 8003bb8:	683b      	ldr	r3, [r7, #0]
 8003bba:	2201      	movs	r2, #1
 8003bbc:	701a      	strb	r2, [r3, #0]
 8003bbe:	e002      	b.n	8003bc6 <sdc_detect_bus_clk+0xf6>
    }
    else {
      *clk = SDC_CLK_25MHz;
 8003bc0:	683b      	ldr	r3, [r7, #0]
 8003bc2:	2200      	movs	r2, #0
 8003bc4:	701a      	strb	r2, [r3, #0]
    }
  }

  return HAL_SUCCESS;
 8003bc6:	2300      	movs	r3, #0
 8003bc8:	46ad      	mov	sp, r5
}
 8003bca:	4618      	mov	r0, r3
 8003bcc:	3718      	adds	r7, #24
 8003bce:	46bd      	mov	sp, r7
 8003bd0:	bdb0      	pop	{r4, r5, r7, pc}
 8003bd2:	bf00      	nop
	...

08003be0 <mmc_detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 8003be0:	b500      	push	{lr}
 8003be2:	b087      	sub	sp, #28
 8003be4:	9001      	str	r0, [sp, #4]
 8003be6:	9100      	str	r1, [sp, #0]
  uint32_t cmdarg;
  uint32_t resp[1];
  uint8_t *scratchpad = sdcp->config->scratchpad;
 8003be8:	9b01      	ldr	r3, [sp, #4]
 8003bea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003bec:	681b      	ldr	r3, [r3, #0]
 8003bee:	9305      	str	r3, [sp, #20]

  /* Safe default.*/
  *clk = SDC_CLK_25MHz;
 8003bf0:	9b00      	ldr	r3, [sp, #0]
 8003bf2:	2200      	movs	r2, #0
 8003bf4:	701a      	strb	r2, [r3, #0]

  /* Use safe default when there is no space for data.*/
  if (NULL == scratchpad) {
 8003bf6:	9b05      	ldr	r3, [sp, #20]
 8003bf8:	2b00      	cmp	r3, #0
 8003bfa:	d101      	bne.n	8003c00 <mmc_detect_bus_clk+0x20>
    return HAL_SUCCESS;
 8003bfc:	2300      	movs	r3, #0
 8003bfe:	e01b      	b.n	8003c38 <mmc_detect_bus_clk+0x58>
  }

  cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 185, 1, 0);
 8003c00:	2300      	movs	r3, #0
 8003c02:	2201      	movs	r2, #1
 8003c04:	21b9      	movs	r1, #185	; 0xb9
 8003c06:	2003      	movs	r0, #3
 8003c08:	f7ff fec2 	bl	8003990 <mmc_cmd6_construct>
 8003c0c:	9004      	str	r0, [sp, #16]
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8003c0e:	ab03      	add	r3, sp, #12
 8003c10:	9a04      	ldr	r2, [sp, #16]
 8003c12:	2106      	movs	r1, #6
 8003c14:	9801      	ldr	r0, [sp, #4]
 8003c16:	f004 fedb 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8003c1a:	4603      	mov	r3, r0
 8003c1c:	f083 0301 	eor.w	r3, r3, #1
 8003c20:	b2db      	uxtb	r3, r3
 8003c22:	2b00      	cmp	r3, #0
 8003c24:	d007      	beq.n	8003c36 <mmc_detect_bus_clk+0x56>
                                   MMCSD_R1_ERROR(resp[0]))) {
 8003c26:	9a03      	ldr	r2, [sp, #12]
 8003c28:	4b05      	ldr	r3, [pc, #20]	; (8003c40 <mmc_detect_bus_clk+0x60>)
 8003c2a:	4013      	ands	r3, r2
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8003c2c:	2b00      	cmp	r3, #0
 8003c2e:	d102      	bne.n	8003c36 <mmc_detect_bus_clk+0x56>
    *clk = SDC_CLK_50MHz;
 8003c30:	9b00      	ldr	r3, [sp, #0]
 8003c32:	2201      	movs	r2, #1
 8003c34:	701a      	strb	r2, [r3, #0]
  }

  return HAL_SUCCESS;
 8003c36:	2300      	movs	r3, #0
}
 8003c38:	4618      	mov	r0, r3
 8003c3a:	b007      	add	sp, #28
 8003c3c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c40:	fdffe008 	.word	0xfdffe008
	...

08003c50 <detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 8003c50:	b500      	push	{lr}
 8003c52:	b083      	sub	sp, #12
 8003c54:	9001      	str	r0, [sp, #4]
 8003c56:	9100      	str	r1, [sp, #0]

  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8003c58:	9b01      	ldr	r3, [sp, #4]
 8003c5a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003c5c:	f003 030f 	and.w	r3, r3, #15
 8003c60:	2b02      	cmp	r3, #2
 8003c62:	d105      	bne.n	8003c70 <detect_bus_clk+0x20>
    return mmc_detect_bus_clk(sdcp, clk);
 8003c64:	9900      	ldr	r1, [sp, #0]
 8003c66:	9801      	ldr	r0, [sp, #4]
 8003c68:	f7ff ffba 	bl	8003be0 <mmc_detect_bus_clk>
 8003c6c:	4603      	mov	r3, r0
 8003c6e:	e004      	b.n	8003c7a <detect_bus_clk+0x2a>
  }
  return sdc_detect_bus_clk(sdcp, clk);
 8003c70:	9900      	ldr	r1, [sp, #0]
 8003c72:	9801      	ldr	r0, [sp, #4]
 8003c74:	f7ff ff2c 	bl	8003ad0 <sdc_detect_bus_clk>
 8003c78:	4603      	mov	r3, r0
}
 8003c7a:	4618      	mov	r0, r3
 8003c7c:	b003      	add	sp, #12
 8003c7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c82:	bf00      	nop
	...

08003c90 <sdc_set_bus_width>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_set_bus_width(SDCDriver *sdcp) {
 8003c90:	b500      	push	{lr}
 8003c92:	b085      	sub	sp, #20
 8003c94:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  if (SDC_MODE_1BIT == sdcp->config->bus_width) {
 8003c96:	9b01      	ldr	r3, [sp, #4]
 8003c98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003c9a:	791b      	ldrb	r3, [r3, #4]
 8003c9c:	2b00      	cmp	r3, #0
 8003c9e:	d101      	bne.n	8003ca4 <sdc_set_bus_width+0x14>
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
 8003ca0:	2300      	movs	r3, #0
 8003ca2:	e02c      	b.n	8003cfe <sdc_set_bus_width+0x6e>
  }
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
 8003ca4:	9b01      	ldr	r3, [sp, #4]
 8003ca6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003ca8:	791b      	ldrb	r3, [r3, #4]
 8003caa:	2b01      	cmp	r3, #1
 8003cac:	d124      	bne.n	8003cf8 <sdc_set_bus_width+0x68>
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
 8003cae:	2101      	movs	r1, #1
 8003cb0:	9801      	ldr	r0, [sp, #4]
 8003cb2:	f004 fe05 	bl	80088c0 <sdc_lld_set_bus_mode>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8003cb6:	9b01      	ldr	r3, [sp, #4]
 8003cb8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003cba:	ab03      	add	r3, sp, #12
 8003cbc:	2137      	movs	r1, #55	; 0x37
 8003cbe:	9801      	ldr	r0, [sp, #4]
 8003cc0:	f004 fe86 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8003cc4:	4603      	mov	r3, r0
 8003cc6:	2b00      	cmp	r3, #0
 8003cc8:	d104      	bne.n	8003cd4 <sdc_set_bus_width+0x44>
        MMCSD_R1_ERROR(resp[0])) {
 8003cca:	9a03      	ldr	r2, [sp, #12]
 8003ccc:	4b0e      	ldr	r3, [pc, #56]	; (8003d08 <sdc_set_bus_width+0x78>)
 8003cce:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8003cd0:	2b00      	cmp	r3, #0
 8003cd2:	d001      	beq.n	8003cd8 <sdc_set_bus_width+0x48>
      return HAL_FAILED;
 8003cd4:	2301      	movs	r3, #1
 8003cd6:	e012      	b.n	8003cfe <sdc_set_bus_width+0x6e>
    }

    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8003cd8:	ab03      	add	r3, sp, #12
 8003cda:	2202      	movs	r2, #2
 8003cdc:	2106      	movs	r1, #6
 8003cde:	9801      	ldr	r0, [sp, #4]
 8003ce0:	f004 fe76 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8003ce4:	4603      	mov	r3, r0
 8003ce6:	2b00      	cmp	r3, #0
 8003ce8:	d104      	bne.n	8003cf4 <sdc_set_bus_width+0x64>
        MMCSD_R1_ERROR(resp[0])) {
 8003cea:	9a03      	ldr	r2, [sp, #12]
 8003cec:	4b06      	ldr	r3, [pc, #24]	; (8003d08 <sdc_set_bus_width+0x78>)
 8003cee:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8003cf0:	2b00      	cmp	r3, #0
 8003cf2:	d003      	beq.n	8003cfc <sdc_set_bus_width+0x6c>
      return HAL_FAILED;
 8003cf4:	2301      	movs	r3, #1
 8003cf6:	e002      	b.n	8003cfe <sdc_set_bus_width+0x6e>
    }
  }
  else {
    /* SD card does not support 8bit bus.*/
    return HAL_FAILED;
 8003cf8:	2301      	movs	r3, #1
 8003cfa:	e000      	b.n	8003cfe <sdc_set_bus_width+0x6e>
  }

  return HAL_SUCCESS;
 8003cfc:	2300      	movs	r3, #0
}
 8003cfe:	4618      	mov	r0, r3
 8003d00:	b005      	add	sp, #20
 8003d02:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d06:	bf00      	nop
 8003d08:	fdffe008 	.word	0xfdffe008
 8003d0c:	00000000 	.word	0x00000000

08003d10 <mmc_set_bus_width>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_set_bus_width(SDCDriver *sdcp) {
 8003d10:	b500      	push	{lr}
 8003d12:	b085      	sub	sp, #20
 8003d14:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);
 8003d16:	2300      	movs	r3, #0
 8003d18:	2200      	movs	r2, #0
 8003d1a:	21b7      	movs	r1, #183	; 0xb7
 8003d1c:	2003      	movs	r0, #3
 8003d1e:	f7ff fe37 	bl	8003990 <mmc_cmd6_construct>
 8003d22:	9003      	str	r0, [sp, #12]

  switch(sdcp->config->bus_width){
 8003d24:	9b01      	ldr	r3, [sp, #4]
 8003d26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003d28:	791b      	ldrb	r3, [r3, #4]
 8003d2a:	2b01      	cmp	r3, #1
 8003d2c:	d005      	beq.n	8003d3a <mmc_set_bus_width+0x2a>
 8003d2e:	2b02      	cmp	r3, #2
 8003d30:	d00b      	beq.n	8003d4a <mmc_set_bus_width+0x3a>
 8003d32:	2b00      	cmp	r3, #0
 8003d34:	d111      	bne.n	8003d5a <mmc_set_bus_width+0x4a>
  case SDC_MODE_1BIT:
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
 8003d36:	2300      	movs	r3, #0
 8003d38:	e02a      	b.n	8003d90 <mmc_set_bus_width+0x80>
  case SDC_MODE_4BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 1, 0);
 8003d3a:	2300      	movs	r3, #0
 8003d3c:	2201      	movs	r2, #1
 8003d3e:	21b7      	movs	r1, #183	; 0xb7
 8003d40:	2003      	movs	r0, #3
 8003d42:	f7ff fe25 	bl	8003990 <mmc_cmd6_construct>
 8003d46:	9003      	str	r0, [sp, #12]
 8003d48:	e00a      	b.n	8003d60 <mmc_set_bus_width+0x50>
    break;
  case SDC_MODE_8BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
 8003d4a:	2300      	movs	r3, #0
 8003d4c:	2202      	movs	r2, #2
 8003d4e:	21b7      	movs	r1, #183	; 0xb7
 8003d50:	2003      	movs	r0, #3
 8003d52:	f7ff fe1d 	bl	8003990 <mmc_cmd6_construct>
 8003d56:	9003      	str	r0, [sp, #12]
 8003d58:	e002      	b.n	8003d60 <mmc_set_bus_width+0x50>
    break;
  default:
    osalDbgAssert(false, "unexpected case");
 8003d5a:	480f      	ldr	r0, [pc, #60]	; (8003d98 <mmc_set_bus_width+0x88>)
 8003d5c:	f7fc fd58 	bl	8000810 <chSysHalt>
    break;
  }

  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
 8003d60:	9b01      	ldr	r3, [sp, #4]
 8003d62:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003d64:	791b      	ldrb	r3, [r3, #4]
 8003d66:	4619      	mov	r1, r3
 8003d68:	9801      	ldr	r0, [sp, #4]
 8003d6a:	f004 fda9 	bl	80088c0 <sdc_lld_set_bus_mode>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8003d6e:	ab02      	add	r3, sp, #8
 8003d70:	9a03      	ldr	r2, [sp, #12]
 8003d72:	2106      	movs	r1, #6
 8003d74:	9801      	ldr	r0, [sp, #4]
 8003d76:	f004 fe2b 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8003d7a:	4603      	mov	r3, r0
 8003d7c:	2b00      	cmp	r3, #0
 8003d7e:	d104      	bne.n	8003d8a <mmc_set_bus_width+0x7a>
      MMCSD_R1_ERROR(resp[0])) {
 8003d80:	9a02      	ldr	r2, [sp, #8]
 8003d82:	4b06      	ldr	r3, [pc, #24]	; (8003d9c <mmc_set_bus_width+0x8c>)
 8003d84:	4013      	ands	r3, r2
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8003d86:	2b00      	cmp	r3, #0
 8003d88:	d001      	beq.n	8003d8e <mmc_set_bus_width+0x7e>
    return HAL_FAILED;
 8003d8a:	2301      	movs	r3, #1
 8003d8c:	e000      	b.n	8003d90 <mmc_set_bus_width+0x80>
  }

  return HAL_SUCCESS;
 8003d8e:	2300      	movs	r3, #0
}
 8003d90:	4618      	mov	r0, r3
 8003d92:	b005      	add	sp, #20
 8003d94:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d98:	0800a890 	.word	0x0800a890
 8003d9c:	fdffe008 	.word	0xfdffe008

08003da0 <_sdc_wait_for_transfer_state>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 8003da0:	b500      	push	{lr}
 8003da2:	b085      	sub	sp, #20
 8003da4:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
 8003da6:	9b01      	ldr	r3, [sp, #4]
 8003da8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003daa:	ab03      	add	r3, sp, #12
 8003dac:	210d      	movs	r1, #13
 8003dae:	9801      	ldr	r0, [sp, #4]
 8003db0:	f004 fe0e 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8003db4:	4603      	mov	r3, r0
 8003db6:	2b00      	cmp	r3, #0
 8003db8:	d104      	bne.n	8003dc4 <_sdc_wait_for_transfer_state+0x24>
                                   sdcp->rca, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
 8003dba:	9a03      	ldr	r2, [sp, #12]
 8003dbc:	4b0d      	ldr	r3, [pc, #52]	; (8003df4 <_sdc_wait_for_transfer_state+0x54>)
 8003dbe:	4013      	ands	r3, r2
                                   sdcp->rca, resp) ||
 8003dc0:	2b00      	cmp	r3, #0
 8003dc2:	d001      	beq.n	8003dc8 <_sdc_wait_for_transfer_state+0x28>
      return HAL_FAILED;
 8003dc4:	2301      	movs	r3, #1
 8003dc6:	e011      	b.n	8003dec <_sdc_wait_for_transfer_state+0x4c>
    }

    switch (MMCSD_R1_STS(resp[0])) {
 8003dc8:	9b03      	ldr	r3, [sp, #12]
 8003dca:	0a5b      	lsrs	r3, r3, #9
 8003dcc:	f003 030f 	and.w	r3, r3, #15
 8003dd0:	2b04      	cmp	r3, #4
 8003dd2:	d004      	beq.n	8003dde <_sdc_wait_for_transfer_state+0x3e>
 8003dd4:	2b04      	cmp	r3, #4
 8003dd6:	d308      	bcc.n	8003dea <_sdc_wait_for_transfer_state+0x4a>
 8003dd8:	2b07      	cmp	r3, #7
 8003dda:	d806      	bhi.n	8003dea <_sdc_wait_for_transfer_state+0x4a>
 8003ddc:	e001      	b.n	8003de2 <_sdc_wait_for_transfer_state+0x42>
    case MMCSD_STS_TRAN:
      return HAL_SUCCESS;
 8003dde:	2300      	movs	r3, #0
 8003de0:	e004      	b.n	8003dec <_sdc_wait_for_transfer_state+0x4c>
    case MMCSD_STS_DATA:
    case MMCSD_STS_RCV:
    case MMCSD_STS_PRG:
#if SDC_NICE_WAITING == TRUE
      osalThreadSleepMilliseconds(1);
 8003de2:	200a      	movs	r0, #10
 8003de4:	f7ff fce4 	bl	80037b0 <osalThreadSleep.lto_priv.217>
 8003de8:	e7dd      	b.n	8003da6 <_sdc_wait_for_transfer_state+0x6>
#endif
      continue;
    default:
      /* The card should have been initialized so any other state is not
         valid and is reported as an error.*/
      return HAL_FAILED;
 8003dea:	2301      	movs	r3, #1
    }
  }
}
 8003dec:	4618      	mov	r0, r3
 8003dee:	b005      	add	sp, #20
 8003df0:	f85d fb04 	ldr.w	pc, [sp], #4
 8003df4:	fdffe008 	.word	0xfdffe008
	...

08003e00 <sdcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdcInit(void) {
 8003e00:	b508      	push	{r3, lr}

  sdc_lld_init();
 8003e02:	f004 fd05 	bl	8008810 <sdc_lld_init>
}
 8003e06:	bd08      	pop	{r3, pc}
	...

08003e10 <sdcObjectInit>:
 *
 * @param[out] sdcp     pointer to the @p SDCDriver object
 *
 * @init
 */
void sdcObjectInit(SDCDriver *sdcp) {
 8003e10:	b082      	sub	sp, #8
 8003e12:	9001      	str	r0, [sp, #4]

  sdcp->vmt      = &sdc_vmt;
 8003e14:	9b01      	ldr	r3, [sp, #4]
 8003e16:	4a08      	ldr	r2, [pc, #32]	; (8003e38 <sdcObjectInit+0x28>)
 8003e18:	601a      	str	r2, [r3, #0]
  sdcp->state    = BLK_STOP;
 8003e1a:	9b01      	ldr	r3, [sp, #4]
 8003e1c:	2201      	movs	r2, #1
 8003e1e:	711a      	strb	r2, [r3, #4]
  sdcp->errors   = SDC_NO_ERROR;
 8003e20:	9b01      	ldr	r3, [sp, #4]
 8003e22:	2200      	movs	r2, #0
 8003e24:	635a      	str	r2, [r3, #52]	; 0x34
  sdcp->config   = NULL;
 8003e26:	9b01      	ldr	r3, [sp, #4]
 8003e28:	2200      	movs	r2, #0
 8003e2a:	62da      	str	r2, [r3, #44]	; 0x2c
  sdcp->capacity = 0;
 8003e2c:	9b01      	ldr	r3, [sp, #4]
 8003e2e:	2200      	movs	r2, #0
 8003e30:	629a      	str	r2, [r3, #40]	; 0x28
}
 8003e32:	b002      	add	sp, #8
 8003e34:	4770      	bx	lr
 8003e36:	bf00      	nop
 8003e38:	0800a830 	.word	0x0800a830
 8003e3c:	00000000 	.word	0x00000000

08003e40 <sdcConnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcConnect(SDCDriver *sdcp) {
 8003e40:	b500      	push	{lr}
 8003e42:	b089      	sub	sp, #36	; 0x24
 8003e44:	9003      	str	r0, [sp, #12]
  uint32_t resp[1];
  sdcbusclk_t clk = SDC_CLK_25MHz;
 8003e46:	2300      	movs	r3, #0
 8003e48:	f88d 3017 	strb.w	r3, [sp, #23]

  osalDbgCheck(sdcp != NULL);
 8003e4c:	9b03      	ldr	r3, [sp, #12]
 8003e4e:	2b00      	cmp	r3, #0
 8003e50:	d102      	bne.n	8003e58 <sdcConnect+0x18>
 8003e52:	486f      	ldr	r0, [pc, #444]	; (8004010 <sdcConnect+0x1d0>)
 8003e54:	f7fc fcdc 	bl	8000810 <chSysHalt>
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
 8003e58:	9b03      	ldr	r3, [sp, #12]
 8003e5a:	791b      	ldrb	r3, [r3, #4]
 8003e5c:	2b02      	cmp	r3, #2
 8003e5e:	d006      	beq.n	8003e6e <sdcConnect+0x2e>
 8003e60:	9b03      	ldr	r3, [sp, #12]
 8003e62:	791b      	ldrb	r3, [r3, #4]
 8003e64:	2b05      	cmp	r3, #5
 8003e66:	d002      	beq.n	8003e6e <sdcConnect+0x2e>
 8003e68:	4869      	ldr	r0, [pc, #420]	; (8004010 <sdcConnect+0x1d0>)
 8003e6a:	f7fc fcd1 	bl	8000810 <chSysHalt>
                "invalid state");

  /* Connection procedure in progress.*/
  sdcp->state = BLK_CONNECTING;
 8003e6e:	9b03      	ldr	r3, [sp, #12]
 8003e70:	2203      	movs	r2, #3
 8003e72:	711a      	strb	r2, [r3, #4]

  /* Card clock initialization.*/
  sdc_lld_start_clk(sdcp);
 8003e74:	9803      	ldr	r0, [sp, #12]
 8003e76:	f004 fce3 	bl	8008840 <sdc_lld_start_clk>

  /* Enforces the initial card state.*/
  sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8003e7a:	2200      	movs	r2, #0
 8003e7c:	2100      	movs	r1, #0
 8003e7e:	9803      	ldr	r0, [sp, #12]
 8003e80:	f004 fd46 	bl	8008910 <sdc_lld_send_cmd_none>

  /* Detect card type.*/
  if (HAL_FAILED == mode_detect(sdcp)) {
 8003e84:	9803      	ldr	r0, [sp, #12]
 8003e86:	f7ff fca3 	bl	80037d0 <mode_detect>
 8003e8a:	4603      	mov	r3, r0
 8003e8c:	2b00      	cmp	r3, #0
 8003e8e:	f040 80b4 	bne.w	8003ffa <sdcConnect+0x1ba>
    goto failed;
  }

  /* Perform specific initialization procedure.*/
  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_MMC) {
 8003e92:	9b03      	ldr	r3, [sp, #12]
 8003e94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003e96:	f003 030f 	and.w	r3, r3, #15
 8003e9a:	2b02      	cmp	r3, #2
 8003e9c:	d107      	bne.n	8003eae <sdcConnect+0x6e>
    if (HAL_FAILED == mmc_init(sdcp)) {
 8003e9e:	9803      	ldr	r0, [sp, #12]
 8003ea0:	f7ff fce6 	bl	8003870 <mmc_init>
 8003ea4:	4603      	mov	r3, r0
 8003ea6:	2b00      	cmp	r3, #0
 8003ea8:	f040 80a7 	bne.w	8003ffa <sdcConnect+0x1ba>
 8003eac:	e006      	b.n	8003ebc <sdcConnect+0x7c>
      goto failed;
    }
  }
  else {
    if (HAL_FAILED == sdc_init(sdcp)) {
 8003eae:	9803      	ldr	r0, [sp, #12]
 8003eb0:	f7ff fd16 	bl	80038e0 <sdc_init>
 8003eb4:	4603      	mov	r3, r0
 8003eb6:	2b00      	cmp	r3, #0
 8003eb8:	f040 809f 	bne.w	8003ffa <sdcConnect+0x1ba>
      goto failed;
    }
  }

  /* Reads CID.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_ALL_SEND_CID, 0, sdcp->cid)) {
 8003ebc:	9b03      	ldr	r3, [sp, #12]
 8003ebe:	3308      	adds	r3, #8
 8003ec0:	2200      	movs	r2, #0
 8003ec2:	2102      	movs	r1, #2
 8003ec4:	9803      	ldr	r0, [sp, #12]
 8003ec6:	f004 fdc3 	bl	8008a50 <sdc_lld_send_cmd_long_crc>
 8003eca:	4603      	mov	r3, r0
 8003ecc:	2b00      	cmp	r3, #0
 8003ece:	f040 8094 	bne.w	8003ffa <sdcConnect+0x1ba>
    goto failed;
  }

  /* Asks for the RCA.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_RELATIVE_ADDR,
 8003ed2:	9b03      	ldr	r3, [sp, #12]
 8003ed4:	3338      	adds	r3, #56	; 0x38
 8003ed6:	2200      	movs	r2, #0
 8003ed8:	2103      	movs	r1, #3
 8003eda:	9803      	ldr	r0, [sp, #12]
 8003edc:	f004 fd78 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8003ee0:	4603      	mov	r3, r0
 8003ee2:	2b00      	cmp	r3, #0
 8003ee4:	f040 8089 	bne.w	8003ffa <sdcConnect+0x1ba>
                                 0, &sdcp->rca)) {
    goto failed;
  }

  /* Reads CSD.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 8003ee8:	9b03      	ldr	r3, [sp, #12]
 8003eea:	6b9a      	ldr	r2, [r3, #56]	; 0x38
                                sdcp->rca, sdcp->csd)) {
 8003eec:	9b03      	ldr	r3, [sp, #12]
 8003eee:	3318      	adds	r3, #24
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 8003ef0:	2109      	movs	r1, #9
 8003ef2:	9803      	ldr	r0, [sp, #12]
 8003ef4:	f004 fdac 	bl	8008a50 <sdc_lld_send_cmd_long_crc>
 8003ef8:	4603      	mov	r3, r0
 8003efa:	2b00      	cmp	r3, #0
 8003efc:	d17d      	bne.n	8003ffa <sdcConnect+0x1ba>
    goto failed;
  }

  /* Selects the card for operations.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEL_DESEL_CARD,
 8003efe:	9b03      	ldr	r3, [sp, #12]
 8003f00:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003f02:	ab06      	add	r3, sp, #24
 8003f04:	2107      	movs	r1, #7
 8003f06:	9803      	ldr	r0, [sp, #12]
 8003f08:	f004 fd62 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8003f0c:	4603      	mov	r3, r0
 8003f0e:	2b00      	cmp	r3, #0
 8003f10:	d173      	bne.n	8003ffa <sdcConnect+0x1ba>
                                 sdcp->rca, resp)) {
    goto failed;
  }

  /* Switches to high speed.*/
  if (HAL_SUCCESS != detect_bus_clk(sdcp, &clk)) {
 8003f12:	f10d 0317 	add.w	r3, sp, #23
 8003f16:	4619      	mov	r1, r3
 8003f18:	9803      	ldr	r0, [sp, #12]
 8003f1a:	f7ff fe99 	bl	8003c50 <detect_bus_clk>
 8003f1e:	4603      	mov	r3, r0
 8003f20:	2b00      	cmp	r3, #0
 8003f22:	d16a      	bne.n	8003ffa <sdcConnect+0x1ba>
    goto failed;
  }
  sdc_lld_set_data_clk(sdcp, clk);
 8003f24:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8003f28:	4619      	mov	r1, r3
 8003f2a:	9803      	ldr	r0, [sp, #12]
 8003f2c:	f004 fca8 	bl	8008880 <sdc_lld_set_data_clk>

  /* Reads extended CSD if needed and possible.*/
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8003f30:	9b03      	ldr	r3, [sp, #12]
 8003f32:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003f34:	f003 030f 	and.w	r3, r3, #15
 8003f38:	2b02      	cmp	r3, #2
 8003f3a:	d12c      	bne.n	8003f96 <sdcConnect+0x156>

    /* The card is a MMC, checking if it is a large device.*/
    if (_mmcsd_get_slice(sdcp->csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE) > 1U) {
 8003f3c:	9b03      	ldr	r3, [sp, #12]
 8003f3e:	3318      	adds	r3, #24
 8003f40:	227e      	movs	r2, #126	; 0x7e
 8003f42:	217f      	movs	r1, #127	; 0x7f
 8003f44:	4618      	mov	r0, r3
 8003f46:	f7ff fb03 	bl	8003550 <_mmcsd_get_slice>
 8003f4a:	4603      	mov	r3, r0
 8003f4c:	2b01      	cmp	r3, #1
 8003f4e:	d919      	bls.n	8003f84 <sdcConnect+0x144>
      uint8_t *ext_csd = sdcp->config->scratchpad;
 8003f50:	9b03      	ldr	r3, [sp, #12]
 8003f52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003f54:	681b      	ldr	r3, [r3, #0]
 8003f56:	9307      	str	r3, [sp, #28]

      /* Size detection requires the buffer.*/
      if (NULL == ext_csd) {
 8003f58:	9b07      	ldr	r3, [sp, #28]
 8003f5a:	2b00      	cmp	r3, #0
 8003f5c:	d04d      	beq.n	8003ffa <sdcConnect+0x1ba>
        goto failed;
      }

      if(sdc_lld_read_special(sdcp, ext_csd, 512, MMCSD_CMD_SEND_EXT_CSD, 0)) {
 8003f5e:	2300      	movs	r3, #0
 8003f60:	9300      	str	r3, [sp, #0]
 8003f62:	2308      	movs	r3, #8
 8003f64:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003f68:	9907      	ldr	r1, [sp, #28]
 8003f6a:	9803      	ldr	r0, [sp, #12]
 8003f6c:	f004 fdc0 	bl	8008af0 <sdc_lld_read_special>
 8003f70:	4603      	mov	r3, r0
 8003f72:	2b00      	cmp	r3, #0
 8003f74:	d141      	bne.n	8003ffa <sdcConnect+0x1ba>
        goto failed;
      }

      /* Capacity from the EXT_CSD.*/
      sdcp->capacity = _mmcsd_get_capacity_ext(ext_csd);
 8003f76:	9807      	ldr	r0, [sp, #28]
 8003f78:	f7ff fb7a 	bl	8003670 <_mmcsd_get_capacity_ext>
 8003f7c:	4602      	mov	r2, r0
 8003f7e:	9b03      	ldr	r3, [sp, #12]
 8003f80:	629a      	str	r2, [r3, #40]	; 0x28
    }
    else {
      /* Capacity from the normal CSD.*/
      sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 8003f82:	e010      	b.n	8003fa6 <sdcConnect+0x166>
 8003f84:	9b03      	ldr	r3, [sp, #12]
 8003f86:	3318      	adds	r3, #24
 8003f88:	4618      	mov	r0, r3
 8003f8a:	f7ff fb31 	bl	80035f0 <_mmcsd_get_capacity>
 8003f8e:	4602      	mov	r2, r0
 8003f90:	9b03      	ldr	r3, [sp, #12]
 8003f92:	629a      	str	r2, [r3, #40]	; 0x28
 8003f94:	e007      	b.n	8003fa6 <sdcConnect+0x166>
    }
  }
  else {
    /* The card is an SDC, capacity from the normal CSD.*/
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 8003f96:	9b03      	ldr	r3, [sp, #12]
 8003f98:	3318      	adds	r3, #24
 8003f9a:	4618      	mov	r0, r3
 8003f9c:	f7ff fb28 	bl	80035f0 <_mmcsd_get_capacity>
 8003fa0:	4602      	mov	r2, r0
 8003fa2:	9b03      	ldr	r3, [sp, #12]
 8003fa4:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Block length fixed at 512 bytes.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
 8003fa6:	ab06      	add	r3, sp, #24
 8003fa8:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003fac:	2110      	movs	r1, #16
 8003fae:	9803      	ldr	r0, [sp, #12]
 8003fb0:	f004 fd0e 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8003fb4:	4603      	mov	r3, r0
 8003fb6:	2b00      	cmp	r3, #0
 8003fb8:	d11f      	bne.n	8003ffa <sdcConnect+0x1ba>
                                 MMCSD_BLOCK_SIZE, resp) ||
      MMCSD_R1_ERROR(resp[0])) {
 8003fba:	9a06      	ldr	r2, [sp, #24]
 8003fbc:	4b15      	ldr	r3, [pc, #84]	; (8004014 <sdcConnect+0x1d4>)
 8003fbe:	4013      	ands	r3, r2
                                 MMCSD_BLOCK_SIZE, resp) ||
 8003fc0:	2b00      	cmp	r3, #0
 8003fc2:	d11a      	bne.n	8003ffa <sdcConnect+0x1ba>
    goto failed;
  }

  /* Switches to wide bus mode.*/
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
 8003fc4:	9b03      	ldr	r3, [sp, #12]
 8003fc6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003fc8:	f003 030f 	and.w	r3, r3, #15
 8003fcc:	2b01      	cmp	r3, #1
 8003fce:	d902      	bls.n	8003fd6 <sdcConnect+0x196>
 8003fd0:	2b02      	cmp	r3, #2
 8003fd2:	d007      	beq.n	8003fe4 <sdcConnect+0x1a4>
  case SDC_MODE_CARDTYPE_MMC:
    if (HAL_FAILED == mmc_set_bus_width(sdcp)) {
      goto failed;
    }
    break;
  default:
 8003fd4:	e011      	b.n	8003ffa <sdcConnect+0x1ba>
    if (HAL_FAILED == sdc_set_bus_width(sdcp)) {
 8003fd6:	9803      	ldr	r0, [sp, #12]
 8003fd8:	f7ff fe5a 	bl	8003c90 <sdc_set_bus_width>
 8003fdc:	4603      	mov	r3, r0
 8003fde:	2b00      	cmp	r3, #0
 8003fe0:	d10b      	bne.n	8003ffa <sdcConnect+0x1ba>
 8003fe2:	e005      	b.n	8003ff0 <sdcConnect+0x1b0>
    if (HAL_FAILED == mmc_set_bus_width(sdcp)) {
 8003fe4:	9803      	ldr	r0, [sp, #12]
 8003fe6:	f7ff fe93 	bl	8003d10 <mmc_set_bus_width>
 8003fea:	4603      	mov	r3, r0
 8003fec:	2b00      	cmp	r3, #0
 8003fee:	d104      	bne.n	8003ffa <sdcConnect+0x1ba>
    /* Unknown type.*/
    goto failed;
  }

  /* Initialization complete.*/
  sdcp->state = BLK_READY;
 8003ff0:	9b03      	ldr	r3, [sp, #12]
 8003ff2:	2205      	movs	r2, #5
 8003ff4:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 8003ff6:	2300      	movs	r3, #0
 8003ff8:	e006      	b.n	8004008 <sdcConnect+0x1c8>

  /* Connection failed, state reset to BLK_ACTIVE.*/
failed:
  sdc_lld_stop_clk(sdcp);
 8003ffa:	9803      	ldr	r0, [sp, #12]
 8003ffc:	f004 fc50 	bl	80088a0 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 8004000:	9b03      	ldr	r3, [sp, #12]
 8004002:	2202      	movs	r2, #2
 8004004:	711a      	strb	r2, [r3, #4]
  return HAL_FAILED;
 8004006:	2301      	movs	r3, #1
}
 8004008:	4618      	mov	r0, r3
 800400a:	b009      	add	sp, #36	; 0x24
 800400c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004010:	0800a8c0 	.word	0x0800a8c0
 8004014:	fdffe008 	.word	0xfdffe008
	...

08004020 <sdcDisconnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcDisconnect(SDCDriver *sdcp) {
 8004020:	b500      	push	{lr}
 8004022:	b083      	sub	sp, #12
 8004024:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdcp != NULL);
 8004026:	9b01      	ldr	r3, [sp, #4]
 8004028:	2b00      	cmp	r3, #0
 800402a:	d102      	bne.n	8004032 <sdcDisconnect+0x12>
 800402c:	481a      	ldr	r0, [pc, #104]	; (8004098 <sdcDisconnect+0x78>)
 800402e:	f7fc fbef 	bl	8000810 <chSysHalt>

  osalSysLock();
 8004032:	f7ff fbad 	bl	8003790 <osalSysLock.lto_priv.230>
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
 8004036:	9b01      	ldr	r3, [sp, #4]
 8004038:	791b      	ldrb	r3, [r3, #4]
 800403a:	2b02      	cmp	r3, #2
 800403c:	d006      	beq.n	800404c <sdcDisconnect+0x2c>
 800403e:	9b01      	ldr	r3, [sp, #4]
 8004040:	791b      	ldrb	r3, [r3, #4]
 8004042:	2b05      	cmp	r3, #5
 8004044:	d002      	beq.n	800404c <sdcDisconnect+0x2c>
 8004046:	4814      	ldr	r0, [pc, #80]	; (8004098 <sdcDisconnect+0x78>)
 8004048:	f7fc fbe2 	bl	8000810 <chSysHalt>
                "invalid state");
  if (sdcp->state == BLK_ACTIVE) {
 800404c:	9b01      	ldr	r3, [sp, #4]
 800404e:	791b      	ldrb	r3, [r3, #4]
 8004050:	2b02      	cmp	r3, #2
 8004052:	d103      	bne.n	800405c <sdcDisconnect+0x3c>
    osalSysUnlock();
 8004054:	f7ff fba4 	bl	80037a0 <osalSysUnlock.lto_priv.221>
    return HAL_SUCCESS;
 8004058:	2300      	movs	r3, #0
 800405a:	e019      	b.n	8004090 <sdcDisconnect+0x70>
  }
  sdcp->state = BLK_DISCONNECTING;
 800405c:	9b01      	ldr	r3, [sp, #4]
 800405e:	2204      	movs	r2, #4
 8004060:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8004062:	f7ff fb9d 	bl	80037a0 <osalSysUnlock.lto_priv.221>

  /* Waits for eventual pending operations completion.*/
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8004066:	9801      	ldr	r0, [sp, #4]
 8004068:	f7ff fe9a 	bl	8003da0 <_sdc_wait_for_transfer_state>
 800406c:	4603      	mov	r3, r0
 800406e:	2b00      	cmp	r3, #0
 8004070:	d007      	beq.n	8004082 <sdcDisconnect+0x62>
    sdc_lld_stop_clk(sdcp);
 8004072:	9801      	ldr	r0, [sp, #4]
 8004074:	f004 fc14 	bl	80088a0 <sdc_lld_stop_clk>
    sdcp->state = BLK_ACTIVE;
 8004078:	9b01      	ldr	r3, [sp, #4]
 800407a:	2202      	movs	r2, #2
 800407c:	711a      	strb	r2, [r3, #4]
    return HAL_FAILED;
 800407e:	2301      	movs	r3, #1
 8004080:	e006      	b.n	8004090 <sdcDisconnect+0x70>
  }

  /* Card clock stopped.*/
  sdc_lld_stop_clk(sdcp);
 8004082:	9801      	ldr	r0, [sp, #4]
 8004084:	f004 fc0c 	bl	80088a0 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 8004088:	9b01      	ldr	r3, [sp, #4]
 800408a:	2202      	movs	r2, #2
 800408c:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 800408e:	2300      	movs	r3, #0
}
 8004090:	4618      	mov	r0, r3
 8004092:	b003      	add	sp, #12
 8004094:	f85d fb04 	ldr.w	pc, [sp], #4
 8004098:	0800a8d0 	.word	0x0800a8d0
 800409c:	00000000 	.word	0x00000000

080040a0 <sdcRead>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 80040a0:	b500      	push	{lr}
 80040a2:	b087      	sub	sp, #28
 80040a4:	9003      	str	r0, [sp, #12]
 80040a6:	9102      	str	r1, [sp, #8]
 80040a8:	9201      	str	r2, [sp, #4]
 80040aa:	9300      	str	r3, [sp, #0]
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
 80040ac:	9b03      	ldr	r3, [sp, #12]
 80040ae:	2b00      	cmp	r3, #0
 80040b0:	d005      	beq.n	80040be <sdcRead+0x1e>
 80040b2:	9b01      	ldr	r3, [sp, #4]
 80040b4:	2b00      	cmp	r3, #0
 80040b6:	d002      	beq.n	80040be <sdcRead+0x1e>
 80040b8:	9b00      	ldr	r3, [sp, #0]
 80040ba:	2b00      	cmp	r3, #0
 80040bc:	d102      	bne.n	80040c4 <sdcRead+0x24>
 80040be:	4817      	ldr	r0, [pc, #92]	; (800411c <sdcRead+0x7c>)
 80040c0:	f7fc fba6 	bl	8000810 <chSysHalt>
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");
 80040c4:	9b03      	ldr	r3, [sp, #12]
 80040c6:	791b      	ldrb	r3, [r3, #4]
 80040c8:	2b05      	cmp	r3, #5
 80040ca:	d002      	beq.n	80040d2 <sdcRead+0x32>
 80040cc:	4813      	ldr	r0, [pc, #76]	; (800411c <sdcRead+0x7c>)
 80040ce:	f7fc fb9f 	bl	8000810 <chSysHalt>

  if ((startblk + n - 1U) > sdcp->capacity){
 80040d2:	9a02      	ldr	r2, [sp, #8]
 80040d4:	9b00      	ldr	r3, [sp, #0]
 80040d6:	4413      	add	r3, r2
 80040d8:	1e5a      	subs	r2, r3, #1
 80040da:	9b03      	ldr	r3, [sp, #12]
 80040dc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80040de:	429a      	cmp	r2, r3
 80040e0:	d907      	bls.n	80040f2 <sdcRead+0x52>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 80040e2:	9b03      	ldr	r3, [sp, #12]
 80040e4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80040e6:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 80040ea:	9b03      	ldr	r3, [sp, #12]
 80040ec:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_FAILED;
 80040ee:	2301      	movs	r3, #1
 80040f0:	e010      	b.n	8004114 <sdcRead+0x74>
  }

  /* Read operation in progress.*/
  sdcp->state = BLK_READING;
 80040f2:	9b03      	ldr	r3, [sp, #12]
 80040f4:	2206      	movs	r2, #6
 80040f6:	711a      	strb	r2, [r3, #4]

  status = sdc_lld_read(sdcp, startblk, buf, n);
 80040f8:	9b00      	ldr	r3, [sp, #0]
 80040fa:	9a01      	ldr	r2, [sp, #4]
 80040fc:	9902      	ldr	r1, [sp, #8]
 80040fe:	9803      	ldr	r0, [sp, #12]
 8004100:	f004 fe0e 	bl	8008d20 <sdc_lld_read>
 8004104:	4603      	mov	r3, r0
 8004106:	f88d 3017 	strb.w	r3, [sp, #23]

  /* Read operation finished.*/
  sdcp->state = BLK_READY;
 800410a:	9b03      	ldr	r3, [sp, #12]
 800410c:	2205      	movs	r2, #5
 800410e:	711a      	strb	r2, [r3, #4]
  return status;
 8004110:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 8004114:	4618      	mov	r0, r3
 8004116:	b007      	add	sp, #28
 8004118:	f85d fb04 	ldr.w	pc, [sp], #4
 800411c:	0800a8e0 	.word	0x0800a8e0

08004120 <sdcWrite>:
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcWrite(SDCDriver *sdcp, uint32_t startblk,
              const uint8_t *buf, uint32_t n) {
 8004120:	b500      	push	{lr}
 8004122:	b087      	sub	sp, #28
 8004124:	9003      	str	r0, [sp, #12]
 8004126:	9102      	str	r1, [sp, #8]
 8004128:	9201      	str	r2, [sp, #4]
 800412a:	9300      	str	r3, [sp, #0]
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
 800412c:	9b03      	ldr	r3, [sp, #12]
 800412e:	2b00      	cmp	r3, #0
 8004130:	d005      	beq.n	800413e <sdcWrite+0x1e>
 8004132:	9b01      	ldr	r3, [sp, #4]
 8004134:	2b00      	cmp	r3, #0
 8004136:	d002      	beq.n	800413e <sdcWrite+0x1e>
 8004138:	9b00      	ldr	r3, [sp, #0]
 800413a:	2b00      	cmp	r3, #0
 800413c:	d102      	bne.n	8004144 <sdcWrite+0x24>
 800413e:	4817      	ldr	r0, [pc, #92]	; (800419c <sdcWrite+0x7c>)
 8004140:	f7fc fb66 	bl	8000810 <chSysHalt>
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");
 8004144:	9b03      	ldr	r3, [sp, #12]
 8004146:	791b      	ldrb	r3, [r3, #4]
 8004148:	2b05      	cmp	r3, #5
 800414a:	d002      	beq.n	8004152 <sdcWrite+0x32>
 800414c:	4813      	ldr	r0, [pc, #76]	; (800419c <sdcWrite+0x7c>)
 800414e:	f7fc fb5f 	bl	8000810 <chSysHalt>

  if ((startblk + n - 1U) > sdcp->capacity){
 8004152:	9a02      	ldr	r2, [sp, #8]
 8004154:	9b00      	ldr	r3, [sp, #0]
 8004156:	4413      	add	r3, r2
 8004158:	1e5a      	subs	r2, r3, #1
 800415a:	9b03      	ldr	r3, [sp, #12]
 800415c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800415e:	429a      	cmp	r2, r3
 8004160:	d907      	bls.n	8004172 <sdcWrite+0x52>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8004162:	9b03      	ldr	r3, [sp, #12]
 8004164:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004166:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 800416a:	9b03      	ldr	r3, [sp, #12]
 800416c:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_FAILED;
 800416e:	2301      	movs	r3, #1
 8004170:	e010      	b.n	8004194 <sdcWrite+0x74>
  }

  /* Write operation in progress.*/
  sdcp->state = BLK_WRITING;
 8004172:	9b03      	ldr	r3, [sp, #12]
 8004174:	2207      	movs	r2, #7
 8004176:	711a      	strb	r2, [r3, #4]

  status = sdc_lld_write(sdcp, startblk, buf, n);
 8004178:	9b00      	ldr	r3, [sp, #0]
 800417a:	9a01      	ldr	r2, [sp, #4]
 800417c:	9902      	ldr	r1, [sp, #8]
 800417e:	9803      	ldr	r0, [sp, #12]
 8004180:	f004 fe0e 	bl	8008da0 <sdc_lld_write>
 8004184:	4603      	mov	r3, r0
 8004186:	f88d 3017 	strb.w	r3, [sp, #23]

  /* Write operation finished.*/
  sdcp->state = BLK_READY;
 800418a:	9b03      	ldr	r3, [sp, #12]
 800418c:	2205      	movs	r2, #5
 800418e:	711a      	strb	r2, [r3, #4]
  return status;
 8004190:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 8004194:	4618      	mov	r0, r3
 8004196:	b007      	add	sp, #28
 8004198:	f85d fb04 	ldr.w	pc, [sp], #4
 800419c:	0800a8f0 	.word	0x0800a8f0

080041a0 <sdcSync>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcSync(SDCDriver *sdcp) {
 80041a0:	b500      	push	{lr}
 80041a2:	b085      	sub	sp, #20
 80041a4:	9001      	str	r0, [sp, #4]
  bool result;

  osalDbgCheck(sdcp != NULL);
 80041a6:	9b01      	ldr	r3, [sp, #4]
 80041a8:	2b00      	cmp	r3, #0
 80041aa:	d102      	bne.n	80041b2 <sdcSync+0x12>
 80041ac:	480d      	ldr	r0, [pc, #52]	; (80041e4 <sdcSync+0x44>)
 80041ae:	f7fc fb2f 	bl	8000810 <chSysHalt>

  if (sdcp->state != BLK_READY) {
 80041b2:	9b01      	ldr	r3, [sp, #4]
 80041b4:	791b      	ldrb	r3, [r3, #4]
 80041b6:	2b05      	cmp	r3, #5
 80041b8:	d001      	beq.n	80041be <sdcSync+0x1e>
    return HAL_FAILED;
 80041ba:	2301      	movs	r3, #1
 80041bc:	e00d      	b.n	80041da <sdcSync+0x3a>
  }

  /* Synchronization operation in progress.*/
  sdcp->state = BLK_SYNCING;
 80041be:	9b01      	ldr	r3, [sp, #4]
 80041c0:	2208      	movs	r2, #8
 80041c2:	711a      	strb	r2, [r3, #4]

  result = sdc_lld_sync(sdcp);
 80041c4:	9801      	ldr	r0, [sp, #4]
 80041c6:	f004 fe2b 	bl	8008e20 <sdc_lld_sync>
 80041ca:	4603      	mov	r3, r0
 80041cc:	f88d 300f 	strb.w	r3, [sp, #15]

  /* Synchronization operation finished.*/
  sdcp->state = BLK_READY;
 80041d0:	9b01      	ldr	r3, [sp, #4]
 80041d2:	2205      	movs	r2, #5
 80041d4:	711a      	strb	r2, [r3, #4]
  return result;
 80041d6:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 80041da:	4618      	mov	r0, r3
 80041dc:	b005      	add	sp, #20
 80041de:	f85d fb04 	ldr.w	pc, [sp], #4
 80041e2:	bf00      	nop
 80041e4:	0800a900 	.word	0x0800a900
	...

080041f0 <sdcGetInfo>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcGetInfo(SDCDriver *sdcp, BlockDeviceInfo *bdip) {
 80041f0:	b500      	push	{lr}
 80041f2:	b083      	sub	sp, #12
 80041f4:	9001      	str	r0, [sp, #4]
 80041f6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((sdcp != NULL) && (bdip != NULL));
 80041f8:	9b01      	ldr	r3, [sp, #4]
 80041fa:	2b00      	cmp	r3, #0
 80041fc:	d002      	beq.n	8004204 <sdcGetInfo+0x14>
 80041fe:	9b00      	ldr	r3, [sp, #0]
 8004200:	2b00      	cmp	r3, #0
 8004202:	d102      	bne.n	800420a <sdcGetInfo+0x1a>
 8004204:	480a      	ldr	r0, [pc, #40]	; (8004230 <sdcGetInfo+0x40>)
 8004206:	f7fc fb03 	bl	8000810 <chSysHalt>

  if (sdcp->state != BLK_READY) {
 800420a:	9b01      	ldr	r3, [sp, #4]
 800420c:	791b      	ldrb	r3, [r3, #4]
 800420e:	2b05      	cmp	r3, #5
 8004210:	d001      	beq.n	8004216 <sdcGetInfo+0x26>
    return HAL_FAILED;
 8004212:	2301      	movs	r3, #1
 8004214:	e008      	b.n	8004228 <sdcGetInfo+0x38>
  }

  bdip->blk_num = sdcp->capacity;
 8004216:	9b01      	ldr	r3, [sp, #4]
 8004218:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800421a:	9b00      	ldr	r3, [sp, #0]
 800421c:	605a      	str	r2, [r3, #4]
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 800421e:	9b00      	ldr	r3, [sp, #0]
 8004220:	f44f 7200 	mov.w	r2, #512	; 0x200
 8004224:	601a      	str	r2, [r3, #0]

  return HAL_SUCCESS;
 8004226:	2300      	movs	r3, #0
}
 8004228:	4618      	mov	r0, r3
 800422a:	b003      	add	sp, #12
 800422c:	f85d fb04 	ldr.w	pc, [sp], #4
 8004230:	0800a910 	.word	0x0800a910
	...

08004240 <port_lock.lto_priv.122>:
static inline void port_lock(void) {
 8004240:	b082      	sub	sp, #8
 8004242:	2320      	movs	r3, #32
 8004244:	9301      	str	r3, [sp, #4]
 8004246:	9b01      	ldr	r3, [sp, #4]
 8004248:	f383 8811 	msr	BASEPRI, r3
}
 800424c:	b002      	add	sp, #8
 800424e:	4770      	bx	lr

08004250 <port_unlock.lto_priv.92>:
static inline void port_unlock(void) {
 8004250:	b082      	sub	sp, #8
 8004252:	2300      	movs	r3, #0
 8004254:	9301      	str	r3, [sp, #4]
 8004256:	9b01      	ldr	r3, [sp, #4]
 8004258:	f383 8811 	msr	BASEPRI, r3
}
 800425c:	b002      	add	sp, #8
 800425e:	4770      	bx	lr

08004260 <chSysLock.lto_priv.65>:
static inline void chSysLock(void) {
 8004260:	b508      	push	{r3, lr}
  port_lock();
 8004262:	f7ff ffed 	bl	8004240 <port_lock.lto_priv.122>
  _stats_start_measure_crit_thd();
 8004266:	f7fd fb3b 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800426a:	f7fc fb59 	bl	8000920 <_dbg_check_lock>
}
 800426e:	bd08      	pop	{r3, pc}

08004270 <chSysUnlock.lto_priv.24>:
static inline void chSysUnlock(void) {
 8004270:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8004272:	f7fc fb6d 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8004276:	f7fd fb3b 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800427a:	4b09      	ldr	r3, [pc, #36]	; (80042a0 <chSysUnlock.lto_priv.24+0x30>)
 800427c:	681b      	ldr	r3, [r3, #0]
 800427e:	4a08      	ldr	r2, [pc, #32]	; (80042a0 <chSysUnlock.lto_priv.24+0x30>)
 8004280:	4293      	cmp	r3, r2
 8004282:	d00a      	beq.n	800429a <chSysUnlock.lto_priv.24+0x2a>
 8004284:	4b06      	ldr	r3, [pc, #24]	; (80042a0 <chSysUnlock.lto_priv.24+0x30>)
 8004286:	699b      	ldr	r3, [r3, #24]
 8004288:	689a      	ldr	r2, [r3, #8]
 800428a:	4b05      	ldr	r3, [pc, #20]	; (80042a0 <chSysUnlock.lto_priv.24+0x30>)
 800428c:	681b      	ldr	r3, [r3, #0]
 800428e:	689b      	ldr	r3, [r3, #8]
 8004290:	429a      	cmp	r2, r3
 8004292:	d202      	bcs.n	800429a <chSysUnlock.lto_priv.24+0x2a>
 8004294:	4803      	ldr	r0, [pc, #12]	; (80042a4 <chSysUnlock.lto_priv.24+0x34>)
 8004296:	f7fc fabb 	bl	8000810 <chSysHalt>
  port_unlock();
 800429a:	f7ff ffd9 	bl	8004250 <port_unlock.lto_priv.92>
}
 800429e:	bd08      	pop	{r3, pc}
 80042a0:	20002128 	.word	0x20002128
 80042a4:	0800a950 	.word	0x0800a950
	...

080042b0 <chEvtObjectInit.lto_priv.269>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 80042b0:	b082      	sub	sp, #8
 80042b2:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 80042b4:	9b01      	ldr	r3, [sp, #4]
 80042b6:	9a01      	ldr	r2, [sp, #4]
 80042b8:	601a      	str	r2, [r3, #0]
}
 80042ba:	b002      	add	sp, #8
 80042bc:	4770      	bx	lr
 80042be:	bf00      	nop

080042c0 <chIQIsEmptyI.lto_priv.274>:
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 80042c0:	b500      	push	{lr}
 80042c2:	b083      	sub	sp, #12
 80042c4:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 80042c6:	f7fc fbcb 	bl	8000a60 <chDbgCheckClassI>
  return (bool)(chQSpaceI(iqp) == 0U);
 80042ca:	9b01      	ldr	r3, [sp, #4]
 80042cc:	689b      	ldr	r3, [r3, #8]
 80042ce:	2b00      	cmp	r3, #0
 80042d0:	bf0c      	ite	eq
 80042d2:	2301      	moveq	r3, #1
 80042d4:	2300      	movne	r3, #0
 80042d6:	b2db      	uxtb	r3, r3
}
 80042d8:	4618      	mov	r0, r3
 80042da:	b003      	add	sp, #12
 80042dc:	f85d fb04 	ldr.w	pc, [sp], #4

080042e0 <osalSysLock.lto_priv.231>:
static inline void osalSysLock(void) {
 80042e0:	b508      	push	{r3, lr}
  chSysLock();
 80042e2:	f7ff ffbd 	bl	8004260 <chSysLock.lto_priv.65>
}
 80042e6:	bd08      	pop	{r3, pc}
	...

080042f0 <osalSysUnlock.lto_priv.222>:
static inline void osalSysUnlock(void) {
 80042f0:	b508      	push	{r3, lr}
  chSysUnlock();
 80042f2:	f7ff ffbd 	bl	8004270 <chSysUnlock.lto_priv.24>
}
 80042f6:	bd08      	pop	{r3, pc}
	...

08004300 <osalEventObjectInit.lto_priv.267>:
static inline void osalEventObjectInit(event_source_t *esp) {
 8004300:	b500      	push	{lr}
 8004302:	b083      	sub	sp, #12
 8004304:	9001      	str	r0, [sp, #4]
  chEvtObjectInit(esp);
 8004306:	9801      	ldr	r0, [sp, #4]
 8004308:	f7ff ffd2 	bl	80042b0 <chEvtObjectInit.lto_priv.269>
}
 800430c:	b003      	add	sp, #12
 800430e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004312:	bf00      	nop
	...

08004320 <osalEventBroadcastFlagsI.lto_priv.203>:
                                            eventflags_t flags) {
 8004320:	b500      	push	{lr}
 8004322:	b083      	sub	sp, #12
 8004324:	9001      	str	r0, [sp, #4]
 8004326:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 8004328:	9900      	ldr	r1, [sp, #0]
 800432a:	9801      	ldr	r0, [sp, #4]
 800432c:	f7fd fcd0 	bl	8001cd0 <chEvtBroadcastFlagsI>
}
 8004330:	b003      	add	sp, #12
 8004332:	f85d fb04 	ldr.w	pc, [sp], #4
 8004336:	bf00      	nop
	...

08004340 <write.lto_priv.265>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8004340:	b500      	push	{lr}
 8004342:	b085      	sub	sp, #20
 8004344:	9003      	str	r0, [sp, #12]
 8004346:	9102      	str	r1, [sp, #8]
 8004348:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800434a:	9b03      	ldr	r3, [sp, #12]
 800434c:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8004350:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004354:	9a01      	ldr	r2, [sp, #4]
 8004356:	9902      	ldr	r1, [sp, #8]
 8004358:	f7fe f922 	bl	80025a0 <chOQWriteTimeout>
 800435c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800435e:	4618      	mov	r0, r3
 8004360:	b005      	add	sp, #20
 8004362:	f85d fb04 	ldr.w	pc, [sp], #4
 8004366:	bf00      	nop
	...

08004370 <read.lto_priv.263>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8004370:	b500      	push	{lr}
 8004372:	b085      	sub	sp, #20
 8004374:	9003      	str	r0, [sp, #12]
 8004376:	9102      	str	r1, [sp, #8]
 8004378:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800437a:	9b03      	ldr	r3, [sp, #12]
 800437c:	f103 000c 	add.w	r0, r3, #12
 8004380:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004384:	9a01      	ldr	r2, [sp, #4]
 8004386:	9902      	ldr	r1, [sp, #8]
 8004388:	f7fe f80a 	bl	80023a0 <chIQReadTimeout>
 800438c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 800438e:	4618      	mov	r0, r3
 8004390:	b005      	add	sp, #20
 8004392:	f85d fb04 	ldr.w	pc, [sp], #4
 8004396:	bf00      	nop
	...

080043a0 <put.lto_priv.200>:

static msg_t put(void *ip, uint8_t b) {
 80043a0:	b500      	push	{lr}
 80043a2:	b083      	sub	sp, #12
 80043a4:	9001      	str	r0, [sp, #4]
 80043a6:	460b      	mov	r3, r1
 80043a8:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80043ac:	9b01      	ldr	r3, [sp, #4]
 80043ae:	3330      	adds	r3, #48	; 0x30
 80043b0:	f89d 1003 	ldrb.w	r1, [sp, #3]
 80043b4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80043b8:	4618      	mov	r0, r3
 80043ba:	f7fe f879 	bl	80024b0 <chOQPutTimeout>
 80043be:	4603      	mov	r3, r0
}
 80043c0:	4618      	mov	r0, r3
 80043c2:	b003      	add	sp, #12
 80043c4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080043d0 <get.lto_priv.197>:

static msg_t get(void *ip) {
 80043d0:	b500      	push	{lr}
 80043d2:	b083      	sub	sp, #12
 80043d4:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80043d6:	9b01      	ldr	r3, [sp, #4]
 80043d8:	330c      	adds	r3, #12
 80043da:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80043de:	4618      	mov	r0, r3
 80043e0:	f7fd ff96 	bl	8002310 <chIQGetTimeout>
 80043e4:	4603      	mov	r3, r0
}
 80043e6:	4618      	mov	r0, r3
 80043e8:	b003      	add	sp, #12
 80043ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80043ee:	bf00      	nop

080043f0 <putt.lto_priv.261>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 80043f0:	b500      	push	{lr}
 80043f2:	b085      	sub	sp, #20
 80043f4:	9003      	str	r0, [sp, #12]
 80043f6:	460b      	mov	r3, r1
 80043f8:	9201      	str	r2, [sp, #4]
 80043fa:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80043fe:	9b03      	ldr	r3, [sp, #12]
 8004400:	3330      	adds	r3, #48	; 0x30
 8004402:	f89d 100b 	ldrb.w	r1, [sp, #11]
 8004406:	9a01      	ldr	r2, [sp, #4]
 8004408:	4618      	mov	r0, r3
 800440a:	f7fe f851 	bl	80024b0 <chOQPutTimeout>
 800440e:	4603      	mov	r3, r0
}
 8004410:	4618      	mov	r0, r3
 8004412:	b005      	add	sp, #20
 8004414:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004420 <gett.lto_priv.259>:

static msg_t gett(void *ip, systime_t timeout) {
 8004420:	b500      	push	{lr}
 8004422:	b083      	sub	sp, #12
 8004424:	9001      	str	r0, [sp, #4]
 8004426:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8004428:	9b01      	ldr	r3, [sp, #4]
 800442a:	330c      	adds	r3, #12
 800442c:	9900      	ldr	r1, [sp, #0]
 800442e:	4618      	mov	r0, r3
 8004430:	f7fd ff6e 	bl	8002310 <chIQGetTimeout>
 8004434:	4603      	mov	r3, r0
}
 8004436:	4618      	mov	r0, r3
 8004438:	b003      	add	sp, #12
 800443a:	f85d fb04 	ldr.w	pc, [sp], #4
 800443e:	bf00      	nop

08004440 <writet.lto_priv.257>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8004440:	b500      	push	{lr}
 8004442:	b085      	sub	sp, #20
 8004444:	9003      	str	r0, [sp, #12]
 8004446:	9102      	str	r1, [sp, #8]
 8004448:	9201      	str	r2, [sp, #4]
 800444a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 800444c:	9b03      	ldr	r3, [sp, #12]
 800444e:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8004452:	9b00      	ldr	r3, [sp, #0]
 8004454:	9a01      	ldr	r2, [sp, #4]
 8004456:	9902      	ldr	r1, [sp, #8]
 8004458:	f7fe f8a2 	bl	80025a0 <chOQWriteTimeout>
 800445c:	4603      	mov	r3, r0
}
 800445e:	4618      	mov	r0, r3
 8004460:	b005      	add	sp, #20
 8004462:	f85d fb04 	ldr.w	pc, [sp], #4
 8004466:	bf00      	nop
	...

08004470 <readt.lto_priv.255>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8004470:	b500      	push	{lr}
 8004472:	b085      	sub	sp, #20
 8004474:	9003      	str	r0, [sp, #12]
 8004476:	9102      	str	r1, [sp, #8]
 8004478:	9201      	str	r2, [sp, #4]
 800447a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 800447c:	9b03      	ldr	r3, [sp, #12]
 800447e:	f103 000c 	add.w	r0, r3, #12
 8004482:	9b00      	ldr	r3, [sp, #0]
 8004484:	9a01      	ldr	r2, [sp, #4]
 8004486:	9902      	ldr	r1, [sp, #8]
 8004488:	f7fd ff8a 	bl	80023a0 <chIQReadTimeout>
 800448c:	4603      	mov	r3, r0
}
 800448e:	4618      	mov	r0, r3
 8004490:	b005      	add	sp, #20
 8004492:	f85d fb04 	ldr.w	pc, [sp], #4
 8004496:	bf00      	nop
	...

080044a0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 80044a0:	b508      	push	{r3, lr}

  sd_lld_init();
 80044a2:	f004 fe85 	bl	80091b0 <sd_lld_init>
}
 80044a6:	bd08      	pop	{r3, pc}
	...

080044b0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80044b0:	b500      	push	{lr}
 80044b2:	b087      	sub	sp, #28
 80044b4:	9005      	str	r0, [sp, #20]
 80044b6:	9104      	str	r1, [sp, #16]
 80044b8:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 80044ba:	9b05      	ldr	r3, [sp, #20]
 80044bc:	4a13      	ldr	r2, [pc, #76]	; (800450c <sdObjectInit+0x5c>)
 80044be:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 80044c0:	9b05      	ldr	r3, [sp, #20]
 80044c2:	3304      	adds	r3, #4
 80044c4:	4618      	mov	r0, r3
 80044c6:	f7ff ff1b 	bl	8004300 <osalEventObjectInit.lto_priv.267>
  sdp->state = SD_STOP;
 80044ca:	9b05      	ldr	r3, [sp, #20]
 80044cc:	2201      	movs	r2, #1
 80044ce:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80044d0:	9b05      	ldr	r3, [sp, #20]
 80044d2:	f103 000c 	add.w	r0, r3, #12
 80044d6:	9b05      	ldr	r3, [sp, #20]
 80044d8:	f103 0154 	add.w	r1, r3, #84	; 0x54
 80044dc:	9b05      	ldr	r3, [sp, #20]
 80044de:	9300      	str	r3, [sp, #0]
 80044e0:	9b04      	ldr	r3, [sp, #16]
 80044e2:	f44f 7280 	mov.w	r2, #256	; 0x100
 80044e6:	f7fd feb3 	bl	8002250 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80044ea:	9b05      	ldr	r3, [sp, #20]
 80044ec:	f103 0030 	add.w	r0, r3, #48	; 0x30
 80044f0:	9b05      	ldr	r3, [sp, #20]
 80044f2:	f503 71aa 	add.w	r1, r3, #340	; 0x154
 80044f6:	9b05      	ldr	r3, [sp, #20]
 80044f8:	9300      	str	r3, [sp, #0]
 80044fa:	9b03      	ldr	r3, [sp, #12]
 80044fc:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004500:	f7fd ffae 	bl	8002460 <chOQObjectInit>
}
 8004504:	b007      	add	sp, #28
 8004506:	f85d fb04 	ldr.w	pc, [sp], #4
 800450a:	bf00      	nop
 800450c:	0800a920 	.word	0x0800a920

08004510 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8004510:	b500      	push	{lr}
 8004512:	b083      	sub	sp, #12
 8004514:	9001      	str	r0, [sp, #4]
 8004516:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);
 8004518:	9b01      	ldr	r3, [sp, #4]
 800451a:	2b00      	cmp	r3, #0
 800451c:	d102      	bne.n	8004524 <sdStart+0x14>
 800451e:	480e      	ldr	r0, [pc, #56]	; (8004558 <sdStart+0x48>)
 8004520:	f7fc f976 	bl	8000810 <chSysHalt>

  osalSysLock();
 8004524:	f7ff fedc 	bl	80042e0 <osalSysLock.lto_priv.231>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 8004528:	9b01      	ldr	r3, [sp, #4]
 800452a:	7a1b      	ldrb	r3, [r3, #8]
 800452c:	2b01      	cmp	r3, #1
 800452e:	d006      	beq.n	800453e <sdStart+0x2e>
 8004530:	9b01      	ldr	r3, [sp, #4]
 8004532:	7a1b      	ldrb	r3, [r3, #8]
 8004534:	2b02      	cmp	r3, #2
 8004536:	d002      	beq.n	800453e <sdStart+0x2e>
 8004538:	4807      	ldr	r0, [pc, #28]	; (8004558 <sdStart+0x48>)
 800453a:	f7fc f969 	bl	8000810 <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
 800453e:	9900      	ldr	r1, [sp, #0]
 8004540:	9801      	ldr	r0, [sp, #4]
 8004542:	f004 fe4d 	bl	80091e0 <sd_lld_start>
  sdp->state = SD_READY;
 8004546:	9b01      	ldr	r3, [sp, #4]
 8004548:	2202      	movs	r2, #2
 800454a:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800454c:	f7ff fed0 	bl	80042f0 <osalSysUnlock.lto_priv.222>
}
 8004550:	b003      	add	sp, #12
 8004552:	f85d fb04 	ldr.w	pc, [sp], #4
 8004556:	bf00      	nop
 8004558:	0800a940 	.word	0x0800a940
 800455c:	00000000 	.word	0x00000000

08004560 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8004560:	b500      	push	{lr}
 8004562:	b083      	sub	sp, #12
 8004564:	9001      	str	r0, [sp, #4]
 8004566:	460b      	mov	r3, r1
 8004568:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
 800456c:	f7fc fa78 	bl	8000a60 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
 8004570:	9b01      	ldr	r3, [sp, #4]
 8004572:	2b00      	cmp	r3, #0
 8004574:	d102      	bne.n	800457c <sdIncomingDataI+0x1c>
 8004576:	4812      	ldr	r0, [pc, #72]	; (80045c0 <sdIncomingDataI+0x60>)
 8004578:	f7fc f94a 	bl	8000810 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
 800457c:	9b01      	ldr	r3, [sp, #4]
 800457e:	330c      	adds	r3, #12
 8004580:	4618      	mov	r0, r3
 8004582:	f7ff fe9d 	bl	80042c0 <chIQIsEmptyI.lto_priv.274>
 8004586:	4603      	mov	r3, r0
 8004588:	2b00      	cmp	r3, #0
 800458a:	d005      	beq.n	8004598 <sdIncomingDataI+0x38>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 800458c:	9b01      	ldr	r3, [sp, #4]
 800458e:	3304      	adds	r3, #4
 8004590:	2104      	movs	r1, #4
 8004592:	4618      	mov	r0, r3
 8004594:	f7ff fec4 	bl	8004320 <osalEventBroadcastFlagsI.lto_priv.203>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8004598:	9b01      	ldr	r3, [sp, #4]
 800459a:	330c      	adds	r3, #12
 800459c:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80045a0:	4611      	mov	r1, r2
 80045a2:	4618      	mov	r0, r3
 80045a4:	f7fd fe7c 	bl	80022a0 <chIQPutI>
 80045a8:	4603      	mov	r3, r0
 80045aa:	2b00      	cmp	r3, #0
 80045ac:	da05      	bge.n	80045ba <sdIncomingDataI+0x5a>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 80045ae:	9b01      	ldr	r3, [sp, #4]
 80045b0:	3304      	adds	r3, #4
 80045b2:	2180      	movs	r1, #128	; 0x80
 80045b4:	4618      	mov	r0, r3
 80045b6:	f7ff feb3 	bl	8004320 <osalEventBroadcastFlagsI.lto_priv.203>
}
 80045ba:	b003      	add	sp, #12
 80045bc:	f85d fb04 	ldr.w	pc, [sp], #4
 80045c0:	0800a960 	.word	0x0800a960
	...

080045d0 <port_lock.lto_priv.123>:
static inline void port_lock(void) {
 80045d0:	b082      	sub	sp, #8
 80045d2:	2320      	movs	r3, #32
 80045d4:	9301      	str	r3, [sp, #4]
 80045d6:	9b01      	ldr	r3, [sp, #4]
 80045d8:	f383 8811 	msr	BASEPRI, r3
}
 80045dc:	b002      	add	sp, #8
 80045de:	4770      	bx	lr

080045e0 <port_unlock.lto_priv.93>:
static inline void port_unlock(void) {
 80045e0:	b082      	sub	sp, #8
 80045e2:	2300      	movs	r3, #0
 80045e4:	9301      	str	r3, [sp, #4]
 80045e6:	9b01      	ldr	r3, [sp, #4]
 80045e8:	f383 8811 	msr	BASEPRI, r3
}
 80045ec:	b002      	add	sp, #8
 80045ee:	4770      	bx	lr

080045f0 <port_lock_from_isr.lto_priv.186>:
static inline void port_lock_from_isr(void) {
 80045f0:	b508      	push	{r3, lr}
  port_lock();
 80045f2:	f7ff ffed 	bl	80045d0 <port_lock.lto_priv.123>
}
 80045f6:	bd08      	pop	{r3, pc}
	...

08004600 <port_unlock_from_isr.lto_priv.173>:
static inline void port_unlock_from_isr(void) {
 8004600:	b508      	push	{r3, lr}
  port_unlock();
 8004602:	f7ff ffed 	bl	80045e0 <port_unlock.lto_priv.93>
}
 8004606:	bd08      	pop	{r3, pc}
	...

08004610 <chSysLock.lto_priv.66>:
static inline void chSysLock(void) {
 8004610:	b508      	push	{r3, lr}
  port_lock();
 8004612:	f7ff ffdd 	bl	80045d0 <port_lock.lto_priv.123>
  _stats_start_measure_crit_thd();
 8004616:	f7fd f963 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800461a:	f7fc f981 	bl	8000920 <_dbg_check_lock>
}
 800461e:	bd08      	pop	{r3, pc}

08004620 <chSysUnlock.lto_priv.25>:
static inline void chSysUnlock(void) {
 8004620:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8004622:	f7fc f995 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8004626:	f7fd f963 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800462a:	4b09      	ldr	r3, [pc, #36]	; (8004650 <chSysUnlock.lto_priv.25+0x30>)
 800462c:	681b      	ldr	r3, [r3, #0]
 800462e:	4a08      	ldr	r2, [pc, #32]	; (8004650 <chSysUnlock.lto_priv.25+0x30>)
 8004630:	4293      	cmp	r3, r2
 8004632:	d00a      	beq.n	800464a <chSysUnlock.lto_priv.25+0x2a>
 8004634:	4b06      	ldr	r3, [pc, #24]	; (8004650 <chSysUnlock.lto_priv.25+0x30>)
 8004636:	699b      	ldr	r3, [r3, #24]
 8004638:	689a      	ldr	r2, [r3, #8]
 800463a:	4b05      	ldr	r3, [pc, #20]	; (8004650 <chSysUnlock.lto_priv.25+0x30>)
 800463c:	681b      	ldr	r3, [r3, #0]
 800463e:	689b      	ldr	r3, [r3, #8]
 8004640:	429a      	cmp	r2, r3
 8004642:	d202      	bcs.n	800464a <chSysUnlock.lto_priv.25+0x2a>
 8004644:	4803      	ldr	r0, [pc, #12]	; (8004654 <chSysUnlock.lto_priv.25+0x34>)
 8004646:	f7fc f8e3 	bl	8000810 <chSysHalt>
  port_unlock();
 800464a:	f7ff ffc9 	bl	80045e0 <port_unlock.lto_priv.93>
}
 800464e:	bd08      	pop	{r3, pc}
 8004650:	20002128 	.word	0x20002128
 8004654:	0800a9a0 	.word	0x0800a9a0
	...

08004660 <chSysLockFromISR.lto_priv.160>:
static inline void chSysLockFromISR(void) {
 8004660:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8004662:	f7ff ffc5 	bl	80045f0 <port_lock_from_isr.lto_priv.186>
  _stats_start_measure_crit_isr();
 8004666:	f7fd f94b 	bl	8001900 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800466a:	f7fc f989 	bl	8000980 <_dbg_check_lock_from_isr>
}
 800466e:	bd08      	pop	{r3, pc}

08004670 <chSysUnlockFromISR.lto_priv.150>:
static inline void chSysUnlockFromISR(void) {
 8004670:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 8004672:	f7fc f99d 	bl	80009b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8004676:	f7fd f94b 	bl	8001910 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800467a:	f7ff ffc1 	bl	8004600 <port_unlock_from_isr.lto_priv.173>
}
 800467e:	bd08      	pop	{r3, pc}

08004680 <chEvtObjectInit.lto_priv.270>:
static inline void chEvtObjectInit(event_source_t *esp) {
 8004680:	b082      	sub	sp, #8
 8004682:	9001      	str	r0, [sp, #4]
  esp->es_next = (event_listener_t *)esp;
 8004684:	9b01      	ldr	r3, [sp, #4]
 8004686:	9a01      	ldr	r2, [sp, #4]
 8004688:	601a      	str	r2, [r3, #0]
}
 800468a:	b002      	add	sp, #8
 800468c:	4770      	bx	lr
 800468e:	bf00      	nop

08004690 <osalSysLock.lto_priv.232>:
static inline void osalSysLock(void) {
 8004690:	b508      	push	{r3, lr}
  chSysLock();
 8004692:	f7ff ffbd 	bl	8004610 <chSysLock.lto_priv.66>
}
 8004696:	bd08      	pop	{r3, pc}
	...

080046a0 <osalSysUnlock.lto_priv.223>:
static inline void osalSysUnlock(void) {
 80046a0:	b508      	push	{r3, lr}
  chSysUnlock();
 80046a2:	f7ff ffbd 	bl	8004620 <chSysUnlock.lto_priv.25>
}
 80046a6:	bd08      	pop	{r3, pc}
	...

080046b0 <osalSysLockFromISR.lto_priv.140>:
static inline void osalSysLockFromISR(void) {
 80046b0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80046b2:	f7ff ffd5 	bl	8004660 <chSysLockFromISR.lto_priv.160>
}
 80046b6:	bd08      	pop	{r3, pc}
	...

080046c0 <osalSysUnlockFromISR.lto_priv.132>:
static inline void osalSysUnlockFromISR(void) {
 80046c0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 80046c2:	f7ff ffd5 	bl	8004670 <chSysUnlockFromISR.lto_priv.150>
}
 80046c6:	bd08      	pop	{r3, pc}
	...

080046d0 <osalEventObjectInit.lto_priv.268>:
static inline void osalEventObjectInit(event_source_t *esp) {
 80046d0:	b500      	push	{lr}
 80046d2:	b083      	sub	sp, #12
 80046d4:	9001      	str	r0, [sp, #4]
  chEvtObjectInit(esp);
 80046d6:	9801      	ldr	r0, [sp, #4]
 80046d8:	f7ff ffd2 	bl	8004680 <chEvtObjectInit.lto_priv.270>
}
 80046dc:	b003      	add	sp, #12
 80046de:	f85d fb04 	ldr.w	pc, [sp], #4
 80046e2:	bf00      	nop
	...

080046f0 <osalEventBroadcastFlagsI.lto_priv.204>:
                                            eventflags_t flags) {
 80046f0:	b500      	push	{lr}
 80046f2:	b083      	sub	sp, #12
 80046f4:	9001      	str	r0, [sp, #4]
 80046f6:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 80046f8:	9900      	ldr	r1, [sp, #0]
 80046fa:	9801      	ldr	r0, [sp, #4]
 80046fc:	f7fd fae8 	bl	8001cd0 <chEvtBroadcastFlagsI>
}
 8004700:	b003      	add	sp, #12
 8004702:	f85d fb04 	ldr.w	pc, [sp], #4
 8004706:	bf00      	nop
	...

08004710 <sdu_start_receive>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static bool sdu_start_receive(SerialUSBDriver *sdup) {
 8004710:	b500      	push	{lr}
 8004712:	b085      	sub	sp, #20
 8004714:	9001      	str	r0, [sp, #4]
  uint8_t *buf;

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004716:	9b01      	ldr	r3, [sp, #4]
 8004718:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800471c:	681b      	ldr	r3, [r3, #0]
 800471e:	781b      	ldrb	r3, [r3, #0]
 8004720:	2b04      	cmp	r3, #4
 8004722:	d103      	bne.n	800472c <sdu_start_receive+0x1c>
      (sdup->state != SDU_READY)) {
 8004724:	9b01      	ldr	r3, [sp, #4]
 8004726:	7a1b      	ldrb	r3, [r3, #8]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004728:	2b02      	cmp	r3, #2
 800472a:	d001      	beq.n	8004730 <sdu_start_receive+0x20>
    return true;
 800472c:	2301      	movs	r3, #1
 800472e:	e02b      	b.n	8004788 <sdu_start_receive+0x78>
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8004730:	9b01      	ldr	r3, [sp, #4]
 8004732:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004736:	681b      	ldr	r3, [r3, #0]
 8004738:	895a      	ldrh	r2, [r3, #10]
 800473a:	9b01      	ldr	r3, [sp, #4]
 800473c:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004740:	791b      	ldrb	r3, [r3, #4]
 8004742:	4619      	mov	r1, r3
 8004744:	2301      	movs	r3, #1
 8004746:	408b      	lsls	r3, r1
 8004748:	b29b      	uxth	r3, r3
 800474a:	4013      	ands	r3, r2
 800474c:	b29b      	uxth	r3, r3
 800474e:	2b00      	cmp	r3, #0
 8004750:	d001      	beq.n	8004756 <sdu_start_receive+0x46>
    return true;
 8004752:	2301      	movs	r3, #1
 8004754:	e018      	b.n	8004788 <sdu_start_receive+0x78>
  }

  /* Checking if there is a buffer ready for incoming data.*/
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 8004756:	9b01      	ldr	r3, [sp, #4]
 8004758:	330c      	adds	r3, #12
 800475a:	4618      	mov	r0, r3
 800475c:	f7fe faf0 	bl	8002d40 <ibqGetEmptyBufferI>
 8004760:	9003      	str	r0, [sp, #12]
  if (buf == NULL) {
 8004762:	9b03      	ldr	r3, [sp, #12]
 8004764:	2b00      	cmp	r3, #0
 8004766:	d101      	bne.n	800476c <sdu_start_receive+0x5c>
    return true;
 8004768:	2301      	movs	r3, #1
 800476a:	e00d      	b.n	8004788 <sdu_start_receive+0x78>
  }

  /* Buffer found, starting a new transaction.*/
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 800476c:	9b01      	ldr	r3, [sp, #4]
 800476e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004772:	6818      	ldr	r0, [r3, #0]
 8004774:	9b01      	ldr	r3, [sp, #4]
 8004776:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800477a:	7959      	ldrb	r1, [r3, #5]
 800477c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8004780:	9a03      	ldr	r2, [sp, #12]
 8004782:	f000 ff35 	bl	80055f0 <usbStartReceiveI>
                   buf, SERIAL_USB_BUFFERS_SIZE);

  return false;
 8004786:	2300      	movs	r3, #0
}
 8004788:	4618      	mov	r0, r3
 800478a:	b005      	add	sp, #20
 800478c:	f85d fb04 	ldr.w	pc, [sp], #4

08004790 <write.lto_priv.266>:

/*
 * Interface implementation.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8004790:	b500      	push	{lr}
 8004792:	b085      	sub	sp, #20
 8004794:	9003      	str	r0, [sp, #12]
 8004796:	9102      	str	r1, [sp, #8]
 8004798:	9201      	str	r2, [sp, #4]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800479a:	9b03      	ldr	r3, [sp, #12]
 800479c:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80047a0:	681b      	ldr	r3, [r3, #0]
 80047a2:	781b      	ldrb	r3, [r3, #0]
 80047a4:	2b04      	cmp	r3, #4
 80047a6:	d001      	beq.n	80047ac <write.lto_priv.266+0x1c>
    return 0;
 80047a8:	2300      	movs	r3, #0
 80047aa:	e009      	b.n	80047c0 <write.lto_priv.266+0x30>
  }

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 80047ac:	9b03      	ldr	r3, [sp, #12]
 80047ae:	f103 0040 	add.w	r0, r3, #64	; 0x40
 80047b2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80047b6:	9a01      	ldr	r2, [sp, #4]
 80047b8:	9902      	ldr	r1, [sp, #8]
 80047ba:	f7fe fde1 	bl	8003380 <obqWriteTimeout>
 80047be:	4603      	mov	r3, r0
                         n, TIME_INFINITE);
}
 80047c0:	4618      	mov	r0, r3
 80047c2:	b005      	add	sp, #20
 80047c4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080047d0 <read.lto_priv.264>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 80047d0:	b500      	push	{lr}
 80047d2:	b085      	sub	sp, #20
 80047d4:	9003      	str	r0, [sp, #12]
 80047d6:	9102      	str	r1, [sp, #8]
 80047d8:	9201      	str	r2, [sp, #4]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 80047da:	9b03      	ldr	r3, [sp, #12]
 80047dc:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80047e0:	681b      	ldr	r3, [r3, #0]
 80047e2:	781b      	ldrb	r3, [r3, #0]
 80047e4:	2b04      	cmp	r3, #4
 80047e6:	d001      	beq.n	80047ec <read.lto_priv.264+0x1c>
    return 0;
 80047e8:	2300      	movs	r3, #0
 80047ea:	e009      	b.n	8004800 <read.lto_priv.264+0x30>
  }

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 80047ec:	9b03      	ldr	r3, [sp, #12]
 80047ee:	f103 000c 	add.w	r0, r3, #12
 80047f2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80047f6:	9a01      	ldr	r2, [sp, #4]
 80047f8:	9902      	ldr	r1, [sp, #8]
 80047fa:	f7fe fbb1 	bl	8002f60 <ibqReadTimeout>
 80047fe:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 8004800:	4618      	mov	r0, r3
 8004802:	b005      	add	sp, #20
 8004804:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004810 <put.lto_priv.201>:

static msg_t put(void *ip, uint8_t b) {
 8004810:	b500      	push	{lr}
 8004812:	b083      	sub	sp, #12
 8004814:	9001      	str	r0, [sp, #4]
 8004816:	460b      	mov	r3, r1
 8004818:	f88d 3003 	strb.w	r3, [sp, #3]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800481c:	9b01      	ldr	r3, [sp, #4]
 800481e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004822:	681b      	ldr	r3, [r3, #0]
 8004824:	781b      	ldrb	r3, [r3, #0]
 8004826:	2b04      	cmp	r3, #4
 8004828:	d002      	beq.n	8004830 <put.lto_priv.201+0x20>
    return MSG_RESET;
 800482a:	f06f 0301 	mvn.w	r3, #1
 800482e:	e009      	b.n	8004844 <put.lto_priv.201+0x34>
  }

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8004830:	9b01      	ldr	r3, [sp, #4]
 8004832:	3340      	adds	r3, #64	; 0x40
 8004834:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8004838:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800483c:	4618      	mov	r0, r3
 800483e:	f7fe fd67 	bl	8003310 <obqPutTimeout>
 8004842:	4603      	mov	r3, r0
}
 8004844:	4618      	mov	r0, r3
 8004846:	b003      	add	sp, #12
 8004848:	f85d fb04 	ldr.w	pc, [sp], #4
 800484c:	0000      	movs	r0, r0
	...

08004850 <get.lto_priv.198>:

static msg_t get(void *ip) {
 8004850:	b500      	push	{lr}
 8004852:	b083      	sub	sp, #12
 8004854:	9001      	str	r0, [sp, #4]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004856:	9b01      	ldr	r3, [sp, #4]
 8004858:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800485c:	681b      	ldr	r3, [r3, #0]
 800485e:	781b      	ldrb	r3, [r3, #0]
 8004860:	2b04      	cmp	r3, #4
 8004862:	d002      	beq.n	800486a <get.lto_priv.198+0x1a>
    return MSG_RESET;
 8004864:	f06f 0301 	mvn.w	r3, #1
 8004868:	e007      	b.n	800487a <get.lto_priv.198+0x2a>
  }

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 800486a:	9b01      	ldr	r3, [sp, #4]
 800486c:	330c      	adds	r3, #12
 800486e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8004872:	4618      	mov	r0, r3
 8004874:	f7fe fb44 	bl	8002f00 <ibqGetTimeout>
 8004878:	4603      	mov	r3, r0
}
 800487a:	4618      	mov	r0, r3
 800487c:	b003      	add	sp, #12
 800487e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004882:	bf00      	nop
	...

08004890 <putt.lto_priv.262>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8004890:	b500      	push	{lr}
 8004892:	b085      	sub	sp, #20
 8004894:	9003      	str	r0, [sp, #12]
 8004896:	460b      	mov	r3, r1
 8004898:	9201      	str	r2, [sp, #4]
 800489a:	f88d 300b 	strb.w	r3, [sp, #11]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800489e:	9b03      	ldr	r3, [sp, #12]
 80048a0:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80048a4:	681b      	ldr	r3, [r3, #0]
 80048a6:	781b      	ldrb	r3, [r3, #0]
 80048a8:	2b04      	cmp	r3, #4
 80048aa:	d002      	beq.n	80048b2 <putt.lto_priv.262+0x22>
    return MSG_RESET;
 80048ac:	f06f 0301 	mvn.w	r3, #1
 80048b0:	e008      	b.n	80048c4 <putt.lto_priv.262+0x34>
  }

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 80048b2:	9b03      	ldr	r3, [sp, #12]
 80048b4:	3340      	adds	r3, #64	; 0x40
 80048b6:	f89d 100b 	ldrb.w	r1, [sp, #11]
 80048ba:	9a01      	ldr	r2, [sp, #4]
 80048bc:	4618      	mov	r0, r3
 80048be:	f7fe fd27 	bl	8003310 <obqPutTimeout>
 80048c2:	4603      	mov	r3, r0
}
 80048c4:	4618      	mov	r0, r3
 80048c6:	b005      	add	sp, #20
 80048c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80048cc:	0000      	movs	r0, r0
	...

080048d0 <gett.lto_priv.260>:

static msg_t gett(void *ip, systime_t timeout) {
 80048d0:	b500      	push	{lr}
 80048d2:	b083      	sub	sp, #12
 80048d4:	9001      	str	r0, [sp, #4]
 80048d6:	9100      	str	r1, [sp, #0]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 80048d8:	9b01      	ldr	r3, [sp, #4]
 80048da:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80048de:	681b      	ldr	r3, [r3, #0]
 80048e0:	781b      	ldrb	r3, [r3, #0]
 80048e2:	2b04      	cmp	r3, #4
 80048e4:	d002      	beq.n	80048ec <gett.lto_priv.260+0x1c>
    return MSG_RESET;
 80048e6:	f06f 0301 	mvn.w	r3, #1
 80048ea:	e006      	b.n	80048fa <gett.lto_priv.260+0x2a>
  }

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 80048ec:	9b01      	ldr	r3, [sp, #4]
 80048ee:	330c      	adds	r3, #12
 80048f0:	9900      	ldr	r1, [sp, #0]
 80048f2:	4618      	mov	r0, r3
 80048f4:	f7fe fb04 	bl	8002f00 <ibqGetTimeout>
 80048f8:	4603      	mov	r3, r0
}
 80048fa:	4618      	mov	r0, r3
 80048fc:	b003      	add	sp, #12
 80048fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004902:	bf00      	nop
	...

08004910 <writet.lto_priv.258>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8004910:	b500      	push	{lr}
 8004912:	b085      	sub	sp, #20
 8004914:	9003      	str	r0, [sp, #12]
 8004916:	9102      	str	r1, [sp, #8]
 8004918:	9201      	str	r2, [sp, #4]
 800491a:	9300      	str	r3, [sp, #0]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800491c:	9b03      	ldr	r3, [sp, #12]
 800491e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004922:	681b      	ldr	r3, [r3, #0]
 8004924:	781b      	ldrb	r3, [r3, #0]
 8004926:	2b04      	cmp	r3, #4
 8004928:	d001      	beq.n	800492e <writet.lto_priv.258+0x1e>
    return 0;
 800492a:	2300      	movs	r3, #0
 800492c:	e008      	b.n	8004940 <writet.lto_priv.258+0x30>
  }

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 800492e:	9b03      	ldr	r3, [sp, #12]
 8004930:	f103 0040 	add.w	r0, r3, #64	; 0x40
 8004934:	9b00      	ldr	r3, [sp, #0]
 8004936:	9a01      	ldr	r2, [sp, #4]
 8004938:	9902      	ldr	r1, [sp, #8]
 800493a:	f7fe fd21 	bl	8003380 <obqWriteTimeout>
 800493e:	4603      	mov	r3, r0
}
 8004940:	4618      	mov	r0, r3
 8004942:	b005      	add	sp, #20
 8004944:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004950 <readt.lto_priv.256>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8004950:	b500      	push	{lr}
 8004952:	b085      	sub	sp, #20
 8004954:	9003      	str	r0, [sp, #12]
 8004956:	9102      	str	r1, [sp, #8]
 8004958:	9201      	str	r2, [sp, #4]
 800495a:	9300      	str	r3, [sp, #0]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800495c:	9b03      	ldr	r3, [sp, #12]
 800495e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004962:	681b      	ldr	r3, [r3, #0]
 8004964:	781b      	ldrb	r3, [r3, #0]
 8004966:	2b04      	cmp	r3, #4
 8004968:	d001      	beq.n	800496e <readt.lto_priv.256+0x1e>
    return 0;
 800496a:	2300      	movs	r3, #0
 800496c:	e008      	b.n	8004980 <readt.lto_priv.256+0x30>
  }

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 800496e:	9b03      	ldr	r3, [sp, #12]
 8004970:	f103 000c 	add.w	r0, r3, #12
 8004974:	9b00      	ldr	r3, [sp, #0]
 8004976:	9a01      	ldr	r2, [sp, #4]
 8004978:	9902      	ldr	r1, [sp, #8]
 800497a:	f7fe faf1 	bl	8002f60 <ibqReadTimeout>
 800497e:	4603      	mov	r3, r0
}
 8004980:	4618      	mov	r0, r3
 8004982:	b005      	add	sp, #20
 8004984:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08004990 <ibnotify>:
/**
 * @brief   Notification of empty buffer released into the input buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void ibnotify(io_buffers_queue_t *bqp) {
 8004990:	b500      	push	{lr}
 8004992:	b085      	sub	sp, #20
 8004994:	9001      	str	r0, [sp, #4]
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8004996:	9b01      	ldr	r3, [sp, #4]
 8004998:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800499a:	9303      	str	r3, [sp, #12]
  (void) sdu_start_receive(sdup);
 800499c:	9803      	ldr	r0, [sp, #12]
 800499e:	f7ff feb7 	bl	8004710 <sdu_start_receive>
}
 80049a2:	b005      	add	sp, #20
 80049a4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080049b0 <obnotify>:
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 80049b0:	b500      	push	{lr}
 80049b2:	b087      	sub	sp, #28
 80049b4:	9001      	str	r0, [sp, #4]
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 80049b6:	9b01      	ldr	r3, [sp, #4]
 80049b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80049ba:	9305      	str	r3, [sp, #20]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80049bc:	9b05      	ldr	r3, [sp, #20]
 80049be:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80049c2:	681b      	ldr	r3, [r3, #0]
 80049c4:	781b      	ldrb	r3, [r3, #0]
 80049c6:	2b04      	cmp	r3, #4
 80049c8:	d12c      	bne.n	8004a24 <obnotify+0x74>
      (sdup->state != SDU_READY)) {
 80049ca:	9b05      	ldr	r3, [sp, #20]
 80049cc:	7a1b      	ldrb	r3, [r3, #8]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80049ce:	2b02      	cmp	r3, #2
 80049d0:	d128      	bne.n	8004a24 <obnotify+0x74>
    return;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80049d2:	9b05      	ldr	r3, [sp, #20]
 80049d4:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80049d8:	681b      	ldr	r3, [r3, #0]
 80049da:	891a      	ldrh	r2, [r3, #8]
 80049dc:	9b05      	ldr	r3, [sp, #20]
 80049de:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80049e2:	791b      	ldrb	r3, [r3, #4]
 80049e4:	4619      	mov	r1, r3
 80049e6:	2301      	movs	r3, #1
 80049e8:	408b      	lsls	r3, r1
 80049ea:	b29b      	uxth	r3, r3
 80049ec:	4013      	ands	r3, r2
 80049ee:	b29b      	uxth	r3, r3
 80049f0:	2b00      	cmp	r3, #0
 80049f2:	d118      	bne.n	8004a26 <obnotify+0x76>
    /* Trying to get a full buffer.*/
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80049f4:	9b05      	ldr	r3, [sp, #20]
 80049f6:	3340      	adds	r3, #64	; 0x40
 80049f8:	aa03      	add	r2, sp, #12
 80049fa:	4611      	mov	r1, r2
 80049fc:	4618      	mov	r0, r3
 80049fe:	f7fe fba7 	bl	8003150 <obqGetFullBufferI>
 8004a02:	9004      	str	r0, [sp, #16]
    if (buf != NULL) {
 8004a04:	9b04      	ldr	r3, [sp, #16]
 8004a06:	2b00      	cmp	r3, #0
 8004a08:	d00d      	beq.n	8004a26 <obnotify+0x76>
      /* Buffer found, starting a new transaction.*/
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8004a0a:	9b05      	ldr	r3, [sp, #20]
 8004a0c:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004a10:	6818      	ldr	r0, [r3, #0]
 8004a12:	9b05      	ldr	r3, [sp, #20]
 8004a14:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004a18:	7919      	ldrb	r1, [r3, #4]
 8004a1a:	9b03      	ldr	r3, [sp, #12]
 8004a1c:	9a04      	ldr	r2, [sp, #16]
 8004a1e:	f000 fe37 	bl	8005690 <usbStartTransmitI>
 8004a22:	e000      	b.n	8004a26 <obnotify+0x76>
    return;
 8004a24:	bf00      	nop
    }
  }
}
 8004a26:	b007      	add	sp, #28
 8004a28:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a2c:	0000      	movs	r0, r0
	...

08004a30 <sduInit>:
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
}
 8004a30:	4770      	bx	lr
 8004a32:	bf00      	nop
	...

08004a40 <sduObjectInit>:
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 8004a40:	b500      	push	{lr}
 8004a42:	b085      	sub	sp, #20
 8004a44:	9003      	str	r0, [sp, #12]

  sdup->vmt = &vmt;
 8004a46:	9b03      	ldr	r3, [sp, #12]
 8004a48:	4a15      	ldr	r2, [pc, #84]	; (8004aa0 <sduObjectInit+0x60>)
 8004a4a:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdup->event);
 8004a4c:	9b03      	ldr	r3, [sp, #12]
 8004a4e:	3304      	adds	r3, #4
 8004a50:	4618      	mov	r0, r3
 8004a52:	f7ff fe3d 	bl	80046d0 <osalEventObjectInit.lto_priv.268>
  sdup->state = SDU_STOP;
 8004a56:	9b03      	ldr	r3, [sp, #12]
 8004a58:	2201      	movs	r2, #1
 8004a5a:	721a      	strb	r2, [r3, #8]
  ibqObjectInit(&sdup->ibqueue, sdup->ib,
 8004a5c:	9b03      	ldr	r3, [sp, #12]
 8004a5e:	f103 000c 	add.w	r0, r3, #12
 8004a62:	9b03      	ldr	r3, [sp, #12]
 8004a64:	f103 0174 	add.w	r1, r3, #116	; 0x74
 8004a68:	9b03      	ldr	r3, [sp, #12]
 8004a6a:	9301      	str	r3, [sp, #4]
 8004a6c:	4b0d      	ldr	r3, [pc, #52]	; (8004aa4 <sduObjectInit+0x64>)
 8004a6e:	9300      	str	r3, [sp, #0]
 8004a70:	2302      	movs	r3, #2
 8004a72:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004a76:	f7fe f8fb 	bl	8002c70 <ibqObjectInit>
                SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER,
                ibnotify, sdup);
  obqObjectInit(&sdup->obqueue, sdup->ob,
 8004a7a:	9b03      	ldr	r3, [sp, #12]
 8004a7c:	f103 0040 	add.w	r0, r3, #64	; 0x40
 8004a80:	9b03      	ldr	r3, [sp, #12]
 8004a82:	f503 711f 	add.w	r1, r3, #636	; 0x27c
 8004a86:	9b03      	ldr	r3, [sp, #12]
 8004a88:	9301      	str	r3, [sp, #4]
 8004a8a:	4b07      	ldr	r3, [pc, #28]	; (8004aa8 <sduObjectInit+0x68>)
 8004a8c:	9300      	str	r3, [sp, #0]
 8004a8e:	2302      	movs	r3, #2
 8004a90:	f44f 7280 	mov.w	r2, #256	; 0x100
 8004a94:	f7fe faf4 	bl	8003080 <obqObjectInit>
                SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER,
                obnotify, sdup);
}
 8004a98:	b005      	add	sp, #20
 8004a9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a9e:	bf00      	nop
 8004aa0:	0800a970 	.word	0x0800a970
 8004aa4:	08004991 	.word	0x08004991
 8004aa8:	080049b1 	.word	0x080049b1
 8004aac:	00000000 	.word	0x00000000

08004ab0 <sduStart>:
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
 8004ab0:	b500      	push	{lr}
 8004ab2:	b085      	sub	sp, #20
 8004ab4:	9001      	str	r0, [sp, #4]
 8004ab6:	9100      	str	r1, [sp, #0]
  USBDriver *usbp = config->usbp;
 8004ab8:	9b00      	ldr	r3, [sp, #0]
 8004aba:	681b      	ldr	r3, [r3, #0]
 8004abc:	9303      	str	r3, [sp, #12]

  osalDbgCheck(sdup != NULL);
 8004abe:	9b01      	ldr	r3, [sp, #4]
 8004ac0:	2b00      	cmp	r3, #0
 8004ac2:	d102      	bne.n	8004aca <sduStart+0x1a>
 8004ac4:	481c      	ldr	r0, [pc, #112]	; (8004b38 <sduStart+0x88>)
 8004ac6:	f7fb fea3 	bl	8000810 <chSysHalt>

  osalSysLock();
 8004aca:	f7ff fde1 	bl	8004690 <osalSysLock.lto_priv.232>
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 8004ace:	9b01      	ldr	r3, [sp, #4]
 8004ad0:	7a1b      	ldrb	r3, [r3, #8]
 8004ad2:	2b01      	cmp	r3, #1
 8004ad4:	d006      	beq.n	8004ae4 <sduStart+0x34>
 8004ad6:	9b01      	ldr	r3, [sp, #4]
 8004ad8:	7a1b      	ldrb	r3, [r3, #8]
 8004ada:	2b02      	cmp	r3, #2
 8004adc:	d002      	beq.n	8004ae4 <sduStart+0x34>
 8004ade:	4816      	ldr	r0, [pc, #88]	; (8004b38 <sduStart+0x88>)
 8004ae0:	f7fb fe96 	bl	8000810 <chSysHalt>
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 8004ae4:	9b00      	ldr	r3, [sp, #0]
 8004ae6:	791b      	ldrb	r3, [r3, #4]
 8004ae8:	3b01      	subs	r3, #1
 8004aea:	9a03      	ldr	r2, [sp, #12]
 8004aec:	3308      	adds	r3, #8
 8004aee:	009b      	lsls	r3, r3, #2
 8004af0:	4413      	add	r3, r2
 8004af2:	9a01      	ldr	r2, [sp, #4]
 8004af4:	605a      	str	r2, [r3, #4]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 8004af6:	9b00      	ldr	r3, [sp, #0]
 8004af8:	795b      	ldrb	r3, [r3, #5]
 8004afa:	1e5a      	subs	r2, r3, #1
 8004afc:	9b03      	ldr	r3, [sp, #12]
 8004afe:	320e      	adds	r2, #14
 8004b00:	9901      	ldr	r1, [sp, #4]
 8004b02:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  if (config->int_in > 0U) {
 8004b06:	9b00      	ldr	r3, [sp, #0]
 8004b08:	799b      	ldrb	r3, [r3, #6]
 8004b0a:	2b00      	cmp	r3, #0
 8004b0c:	d008      	beq.n	8004b20 <sduStart+0x70>
    usbp->in_params[config->int_in - 1U]  = sdup;
 8004b0e:	9b00      	ldr	r3, [sp, #0]
 8004b10:	799b      	ldrb	r3, [r3, #6]
 8004b12:	3b01      	subs	r3, #1
 8004b14:	9a03      	ldr	r2, [sp, #12]
 8004b16:	3308      	adds	r3, #8
 8004b18:	009b      	lsls	r3, r3, #2
 8004b1a:	4413      	add	r3, r2
 8004b1c:	9a01      	ldr	r2, [sp, #4]
 8004b1e:	605a      	str	r2, [r3, #4]
  }
  sdup->config = config;
 8004b20:	9b01      	ldr	r3, [sp, #4]
 8004b22:	9a00      	ldr	r2, [sp, #0]
 8004b24:	f8c3 2484 	str.w	r2, [r3, #1156]	; 0x484
  sdup->state = SDU_READY;
 8004b28:	9b01      	ldr	r3, [sp, #4]
 8004b2a:	2202      	movs	r2, #2
 8004b2c:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 8004b2e:	f7ff fdb7 	bl	80046a0 <osalSysUnlock.lto_priv.223>
}
 8004b32:	b005      	add	sp, #20
 8004b34:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b38:	0800a990 	.word	0x0800a990
 8004b3c:	00000000 	.word	0x00000000

08004b40 <sduDisconnectI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduDisconnectI(SerialUSBDriver *sdup) {
 8004b40:	b500      	push	{lr}
 8004b42:	b083      	sub	sp, #12
 8004b44:	9001      	str	r0, [sp, #4]

  /* Queues reset in order to signal the driver stop to the application.*/
  chnAddFlagsI(sdup, CHN_DISCONNECTED);
 8004b46:	9b01      	ldr	r3, [sp, #4]
 8004b48:	3304      	adds	r3, #4
 8004b4a:	2102      	movs	r1, #2
 8004b4c:	4618      	mov	r0, r3
 8004b4e:	f7ff fdcf 	bl	80046f0 <osalEventBroadcastFlagsI.lto_priv.204>
  ibqResetI(&sdup->ibqueue);
 8004b52:	9b01      	ldr	r3, [sp, #4]
 8004b54:	330c      	adds	r3, #12
 8004b56:	4618      	mov	r0, r3
 8004b58:	f7fe f8d2 	bl	8002d00 <ibqResetI>
  obqResetI(&sdup->obqueue);
 8004b5c:	9b01      	ldr	r3, [sp, #4]
 8004b5e:	3340      	adds	r3, #64	; 0x40
 8004b60:	4618      	mov	r0, r3
 8004b62:	f7fe fad5 	bl	8003110 <obqResetI>
}
 8004b66:	b003      	add	sp, #12
 8004b68:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b6c:	0000      	movs	r0, r0
	...

08004b70 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 8004b70:	b500      	push	{lr}
 8004b72:	b083      	sub	sp, #12
 8004b74:	9001      	str	r0, [sp, #4]

  ibqResetI(&sdup->ibqueue);
 8004b76:	9b01      	ldr	r3, [sp, #4]
 8004b78:	330c      	adds	r3, #12
 8004b7a:	4618      	mov	r0, r3
 8004b7c:	f7fe f8c0 	bl	8002d00 <ibqResetI>
  obqResetI(&sdup->obqueue);
 8004b80:	9b01      	ldr	r3, [sp, #4]
 8004b82:	3340      	adds	r3, #64	; 0x40
 8004b84:	4618      	mov	r0, r3
 8004b86:	f7fe fac3 	bl	8003110 <obqResetI>
  chnAddFlagsI(sdup, CHN_CONNECTED);
 8004b8a:	9b01      	ldr	r3, [sp, #4]
 8004b8c:	3304      	adds	r3, #4
 8004b8e:	2101      	movs	r1, #1
 8004b90:	4618      	mov	r0, r3
 8004b92:	f7ff fdad 	bl	80046f0 <osalEventBroadcastFlagsI.lto_priv.204>
  (void) sdu_start_receive(sdup);
 8004b96:	9801      	ldr	r0, [sp, #4]
 8004b98:	f7ff fdba 	bl	8004710 <sdu_start_receive>
}
 8004b9c:	b003      	add	sp, #12
 8004b9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004ba2:	bf00      	nop
	...

08004bb0 <sduRequestsHook>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The hook status.
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {
 8004bb0:	b082      	sub	sp, #8
 8004bb2:	9001      	str	r0, [sp, #4]

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8004bb4:	9b01      	ldr	r3, [sp, #4]
 8004bb6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8004bba:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8004bbe:	2b20      	cmp	r3, #32
 8004bc0:	d12c      	bne.n	8004c1c <sduRequestsHook+0x6c>
    switch (usbp->setup[1]) {
 8004bc2:	9b01      	ldr	r3, [sp, #4]
 8004bc4:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8004bc8:	2b21      	cmp	r3, #33	; 0x21
 8004bca:	d004      	beq.n	8004bd6 <sduRequestsHook+0x26>
 8004bcc:	2b22      	cmp	r3, #34	; 0x22
 8004bce:	d018      	beq.n	8004c02 <sduRequestsHook+0x52>
 8004bd0:	2b20      	cmp	r3, #32
 8004bd2:	d00b      	beq.n	8004bec <sduRequestsHook+0x3c>
 8004bd4:	e020      	b.n	8004c18 <sduRequestsHook+0x68>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8004bd6:	9b01      	ldr	r3, [sp, #4]
 8004bd8:	4a12      	ldr	r2, [pc, #72]	; (8004c24 <sduRequestsHook+0x74>)
 8004bda:	651a      	str	r2, [r3, #80]	; 0x50
 8004bdc:	9b01      	ldr	r3, [sp, #4]
 8004bde:	2207      	movs	r2, #7
 8004be0:	655a      	str	r2, [r3, #84]	; 0x54
 8004be2:	9b01      	ldr	r3, [sp, #4]
 8004be4:	2200      	movs	r2, #0
 8004be6:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 8004be8:	2301      	movs	r3, #1
 8004bea:	e018      	b.n	8004c1e <sduRequestsHook+0x6e>
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8004bec:	9b01      	ldr	r3, [sp, #4]
 8004bee:	4a0d      	ldr	r2, [pc, #52]	; (8004c24 <sduRequestsHook+0x74>)
 8004bf0:	651a      	str	r2, [r3, #80]	; 0x50
 8004bf2:	9b01      	ldr	r3, [sp, #4]
 8004bf4:	2207      	movs	r2, #7
 8004bf6:	655a      	str	r2, [r3, #84]	; 0x54
 8004bf8:	9b01      	ldr	r3, [sp, #4]
 8004bfa:	2200      	movs	r2, #0
 8004bfc:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 8004bfe:	2301      	movs	r3, #1
 8004c00:	e00d      	b.n	8004c1e <sduRequestsHook+0x6e>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8004c02:	9b01      	ldr	r3, [sp, #4]
 8004c04:	2200      	movs	r2, #0
 8004c06:	651a      	str	r2, [r3, #80]	; 0x50
 8004c08:	9b01      	ldr	r3, [sp, #4]
 8004c0a:	2200      	movs	r2, #0
 8004c0c:	655a      	str	r2, [r3, #84]	; 0x54
 8004c0e:	9b01      	ldr	r3, [sp, #4]
 8004c10:	2200      	movs	r2, #0
 8004c12:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 8004c14:	2301      	movs	r3, #1
 8004c16:	e002      	b.n	8004c1e <sduRequestsHook+0x6e>
    default:
      return false;
 8004c18:	2300      	movs	r3, #0
 8004c1a:	e000      	b.n	8004c1e <sduRequestsHook+0x6e>
    }
  }
  return false;
 8004c1c:	2300      	movs	r3, #0
}
 8004c1e:	4618      	mov	r0, r3
 8004c20:	b002      	add	sp, #8
 8004c22:	4770      	bx	lr
 8004c24:	20000000 	.word	0x20000000
	...

08004c30 <sduSOFHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduSOFHookI(SerialUSBDriver *sdup) {
 8004c30:	b500      	push	{lr}
 8004c32:	b085      	sub	sp, #20
 8004c34:	9001      	str	r0, [sp, #4]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004c36:	9b01      	ldr	r3, [sp, #4]
 8004c38:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004c3c:	681b      	ldr	r3, [r3, #0]
 8004c3e:	781b      	ldrb	r3, [r3, #0]
 8004c40:	2b04      	cmp	r3, #4
 8004c42:	d136      	bne.n	8004cb2 <sduSOFHookI+0x82>
      (sdup->state != SDU_READY)) {
 8004c44:	9b01      	ldr	r3, [sp, #4]
 8004c46:	7a1b      	ldrb	r3, [r3, #8]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004c48:	2b02      	cmp	r3, #2
 8004c4a:	d132      	bne.n	8004cb2 <sduSOFHookI+0x82>
    return;
  }

  /* If there is already a transaction ongoing then another one cannot be
     started.*/
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8004c4c:	9b01      	ldr	r3, [sp, #4]
 8004c4e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004c52:	681b      	ldr	r3, [r3, #0]
 8004c54:	891a      	ldrh	r2, [r3, #8]
 8004c56:	9b01      	ldr	r3, [sp, #4]
 8004c58:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004c5c:	791b      	ldrb	r3, [r3, #4]
 8004c5e:	4619      	mov	r1, r3
 8004c60:	2301      	movs	r3, #1
 8004c62:	408b      	lsls	r3, r1
 8004c64:	b29b      	uxth	r3, r3
 8004c66:	4013      	ands	r3, r2
 8004c68:	b29b      	uxth	r3, r3
 8004c6a:	2b00      	cmp	r3, #0
 8004c6c:	d121      	bne.n	8004cb2 <sduSOFHookI+0x82>
    return;
  }

  /* Checking if there only a buffer partially filled, if so then it is
     enforced in the queue and transmitted.*/
  if (obqTryFlushI(&sdup->obqueue)) {
 8004c6e:	9b01      	ldr	r3, [sp, #4]
 8004c70:	3340      	adds	r3, #64	; 0x40
 8004c72:	4618      	mov	r0, r3
 8004c74:	f7fe fc1c 	bl	80034b0 <obqTryFlushI>
 8004c78:	4603      	mov	r3, r0
 8004c7a:	2b00      	cmp	r3, #0
 8004c7c:	d019      	beq.n	8004cb2 <sduSOFHookI+0x82>
    size_t n;
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8004c7e:	9b01      	ldr	r3, [sp, #4]
 8004c80:	3340      	adds	r3, #64	; 0x40
 8004c82:	aa02      	add	r2, sp, #8
 8004c84:	4611      	mov	r1, r2
 8004c86:	4618      	mov	r0, r3
 8004c88:	f7fe fa62 	bl	8003150 <obqGetFullBufferI>
 8004c8c:	9003      	str	r0, [sp, #12]

    osalDbgAssert(buf != NULL, "queue is empty");
 8004c8e:	9b03      	ldr	r3, [sp, #12]
 8004c90:	2b00      	cmp	r3, #0
 8004c92:	d102      	bne.n	8004c9a <sduSOFHookI+0x6a>
 8004c94:	4808      	ldr	r0, [pc, #32]	; (8004cb8 <sduSOFHookI+0x88>)
 8004c96:	f7fb fdbb 	bl	8000810 <chSysHalt>

    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8004c9a:	9b01      	ldr	r3, [sp, #4]
 8004c9c:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004ca0:	6818      	ldr	r0, [r3, #0]
 8004ca2:	9b01      	ldr	r3, [sp, #4]
 8004ca4:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004ca8:	7919      	ldrb	r1, [r3, #4]
 8004caa:	9b02      	ldr	r3, [sp, #8]
 8004cac:	9a03      	ldr	r2, [sp, #12]
 8004cae:	f000 fcef 	bl	8005690 <usbStartTransmitI>
  }
}
 8004cb2:	b005      	add	sp, #20
 8004cb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8004cb8:	0800a9b0 	.word	0x0800a9b0
 8004cbc:	00000000 	.word	0x00000000

08004cc0 <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8004cc0:	b500      	push	{lr}
 8004cc2:	b087      	sub	sp, #28
 8004cc4:	9001      	str	r0, [sp, #4]
 8004cc6:	460b      	mov	r3, r1
 8004cc8:	f88d 3003 	strb.w	r3, [sp, #3]
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8004ccc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004cd0:	3b01      	subs	r3, #1
 8004cd2:	9a01      	ldr	r2, [sp, #4]
 8004cd4:	3308      	adds	r3, #8
 8004cd6:	009b      	lsls	r3, r3, #2
 8004cd8:	4413      	add	r3, r2
 8004cda:	685b      	ldr	r3, [r3, #4]
 8004cdc:	9305      	str	r3, [sp, #20]

  if (sdup == NULL) {
 8004cde:	9b05      	ldr	r3, [sp, #20]
 8004ce0:	2b00      	cmp	r3, #0
 8004ce2:	d056      	beq.n	8004d92 <sduDataTransmitted+0xd2>
    return;
  }

  osalSysLockFromISR();
 8004ce4:	f7ff fce4 	bl	80046b0 <osalSysLockFromISR.lto_priv.140>

  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);
 8004ce8:	9b05      	ldr	r3, [sp, #20]
 8004cea:	3304      	adds	r3, #4
 8004cec:	2108      	movs	r1, #8
 8004cee:	4618      	mov	r0, r3
 8004cf0:	f7ff fcfe 	bl	80046f0 <osalEventBroadcastFlagsI.lto_priv.204>

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8004cf4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004cf8:	9a01      	ldr	r2, [sp, #4]
 8004cfa:	3302      	adds	r3, #2
 8004cfc:	009b      	lsls	r3, r3, #2
 8004cfe:	4413      	add	r3, r2
 8004d00:	685b      	ldr	r3, [r3, #4]
 8004d02:	695b      	ldr	r3, [r3, #20]
 8004d04:	681b      	ldr	r3, [r3, #0]
 8004d06:	2b00      	cmp	r3, #0
 8004d08:	d004      	beq.n	8004d14 <sduDataTransmitted+0x54>
    obqReleaseEmptyBufferI(&sdup->obqueue);
 8004d0a:	9b05      	ldr	r3, [sp, #20]
 8004d0c:	3340      	adds	r3, #64	; 0x40
 8004d0e:	4618      	mov	r0, r3
 8004d10:	f7fe fa46 	bl	80031a0 <obqReleaseEmptyBufferI>
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8004d14:	9b05      	ldr	r3, [sp, #20]
 8004d16:	3340      	adds	r3, #64	; 0x40
 8004d18:	aa03      	add	r2, sp, #12
 8004d1a:	4611      	mov	r1, r2
 8004d1c:	4618      	mov	r0, r3
 8004d1e:	f7fe fa17 	bl	8003150 <obqGetFullBufferI>
 8004d22:	9004      	str	r0, [sp, #16]

  if (buf != NULL) {
 8004d24:	9b04      	ldr	r3, [sp, #16]
 8004d26:	2b00      	cmp	r3, #0
 8004d28:	d007      	beq.n	8004d3a <sduDataTransmitted+0x7a>
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
 8004d2a:	9b03      	ldr	r3, [sp, #12]
 8004d2c:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8004d30:	9a04      	ldr	r2, [sp, #16]
 8004d32:	9801      	ldr	r0, [sp, #4]
 8004d34:	f000 fcac 	bl	8005690 <usbStartTransmitI>
 8004d38:	e028      	b.n	8004d8c <sduDataTransmitted+0xcc>
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8004d3a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004d3e:	9a01      	ldr	r2, [sp, #4]
 8004d40:	3302      	adds	r3, #2
 8004d42:	009b      	lsls	r3, r3, #2
 8004d44:	4413      	add	r3, r2
 8004d46:	685b      	ldr	r3, [r3, #4]
 8004d48:	695b      	ldr	r3, [r3, #20]
 8004d4a:	681b      	ldr	r3, [r3, #0]
 8004d4c:	2b00      	cmp	r3, #0
 8004d4e:	d01d      	beq.n	8004d8c <sduDataTransmitted+0xcc>
           ((usbp->epc[ep]->in_state->txsize &
 8004d50:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004d54:	9a01      	ldr	r2, [sp, #4]
 8004d56:	3302      	adds	r3, #2
 8004d58:	009b      	lsls	r3, r3, #2
 8004d5a:	4413      	add	r3, r2
 8004d5c:	685b      	ldr	r3, [r3, #4]
 8004d5e:	695b      	ldr	r3, [r3, #20]
 8004d60:	681a      	ldr	r2, [r3, #0]
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 8004d62:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004d66:	9901      	ldr	r1, [sp, #4]
 8004d68:	3302      	adds	r3, #2
 8004d6a:	009b      	lsls	r3, r3, #2
 8004d6c:	440b      	add	r3, r1
 8004d6e:	685b      	ldr	r3, [r3, #4]
 8004d70:	8a1b      	ldrh	r3, [r3, #16]
 8004d72:	3b01      	subs	r3, #1
           ((usbp->epc[ep]->in_state->txsize &
 8004d74:	4013      	ands	r3, r2
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8004d76:	2b00      	cmp	r3, #0
 8004d78:	d108      	bne.n	8004d8c <sduDataTransmitted+0xcc>
    /* Transmit zero sized packet in case the last one has maximum allowed
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 8004d7a:	9b01      	ldr	r3, [sp, #4]
 8004d7c:	f103 025c 	add.w	r2, r3, #92	; 0x5c
 8004d80:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8004d84:	2300      	movs	r3, #0
 8004d86:	9801      	ldr	r0, [sp, #4]
 8004d88:	f000 fc82 	bl	8005690 <usbStartTransmitI>
  }
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
 8004d8c:	f7ff fc98 	bl	80046c0 <osalSysUnlockFromISR.lto_priv.132>
 8004d90:	e000      	b.n	8004d94 <sduDataTransmitted+0xd4>
    return;
 8004d92:	bf00      	nop
}
 8004d94:	b007      	add	sp, #28
 8004d96:	f85d fb04 	ldr.w	pc, [sp], #4
 8004d9a:	bf00      	nop
 8004d9c:	0000      	movs	r0, r0
	...

08004da0 <sduDataReceived>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 8004da0:	b500      	push	{lr}
 8004da2:	b085      	sub	sp, #20
 8004da4:	9001      	str	r0, [sp, #4]
 8004da6:	460b      	mov	r3, r1
 8004da8:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t size;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8004dac:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004db0:	1e5a      	subs	r2, r3, #1
 8004db2:	9b01      	ldr	r3, [sp, #4]
 8004db4:	320e      	adds	r2, #14
 8004db6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8004dba:	9303      	str	r3, [sp, #12]

  if (sdup == NULL) {
 8004dbc:	9b03      	ldr	r3, [sp, #12]
 8004dbe:	2b00      	cmp	r3, #0
 8004dc0:	d024      	beq.n	8004e0c <sduDataReceived+0x6c>
    return;
  }

  osalSysLockFromISR();
 8004dc2:	f7ff fc75 	bl	80046b0 <osalSysLockFromISR.lto_priv.140>

  /* Checking for zero-size transactions.*/
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8004dc6:	9b03      	ldr	r3, [sp, #12]
 8004dc8:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004dcc:	681a      	ldr	r2, [r3, #0]
 8004dce:	9b03      	ldr	r3, [sp, #12]
 8004dd0:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8004dd4:	795b      	ldrb	r3, [r3, #5]
 8004dd6:	3302      	adds	r3, #2
 8004dd8:	009b      	lsls	r3, r3, #2
 8004dda:	4413      	add	r3, r2
 8004ddc:	685b      	ldr	r3, [r3, #4]
 8004dde:	699b      	ldr	r3, [r3, #24]
 8004de0:	685b      	ldr	r3, [r3, #4]
 8004de2:	9302      	str	r3, [sp, #8]
                                       sdup->config->bulk_out);
  if (size > (size_t)0) {
 8004de4:	9b02      	ldr	r3, [sp, #8]
 8004de6:	2b00      	cmp	r3, #0
 8004de8:	d00b      	beq.n	8004e02 <sduDataReceived+0x62>
    /* Signaling that data is available in the input queue.*/
    chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);
 8004dea:	9b03      	ldr	r3, [sp, #12]
 8004dec:	3304      	adds	r3, #4
 8004dee:	2104      	movs	r1, #4
 8004df0:	4618      	mov	r0, r3
 8004df2:	f7ff fc7d 	bl	80046f0 <osalEventBroadcastFlagsI.lto_priv.204>

    /* Posting the filled buffer in the queue.*/
    ibqPostFullBufferI(&sdup->ibqueue, size);
 8004df6:	9b03      	ldr	r3, [sp, #12]
 8004df8:	330c      	adds	r3, #12
 8004dfa:	9902      	ldr	r1, [sp, #8]
 8004dfc:	4618      	mov	r0, r3
 8004dfe:	f7fd ffbf 	bl	8002d80 <ibqPostFullBufferI>
  }

  /* The endpoint cannot be busy, we are in the context of the callback,
     so a packet is in the buffer for sure. Trying to get a free buffer
     for the next transaction.*/
  (void) sdu_start_receive(sdup);
 8004e02:	9803      	ldr	r0, [sp, #12]
 8004e04:	f7ff fc84 	bl	8004710 <sdu_start_receive>

  osalSysUnlockFromISR();
 8004e08:	f7ff fc5a 	bl	80046c0 <osalSysUnlockFromISR.lto_priv.132>
}
 8004e0c:	b005      	add	sp, #20
 8004e0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004e12:	bf00      	nop
	...

08004e20 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 8004e20:	b082      	sub	sp, #8
 8004e22:	9001      	str	r0, [sp, #4]
 8004e24:	460b      	mov	r3, r1
 8004e26:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)usbp;
  (void)ep;
}
 8004e2a:	b002      	add	sp, #8
 8004e2c:	4770      	bx	lr
 8004e2e:	bf00      	nop

08004e30 <port_lock.lto_priv.124>:
static inline void port_lock(void) {
 8004e30:	b082      	sub	sp, #8
 8004e32:	2320      	movs	r3, #32
 8004e34:	9301      	str	r3, [sp, #4]
 8004e36:	9b01      	ldr	r3, [sp, #4]
 8004e38:	f383 8811 	msr	BASEPRI, r3
}
 8004e3c:	b002      	add	sp, #8
 8004e3e:	4770      	bx	lr

08004e40 <port_unlock.lto_priv.94>:
static inline void port_unlock(void) {
 8004e40:	b082      	sub	sp, #8
 8004e42:	2300      	movs	r3, #0
 8004e44:	9301      	str	r3, [sp, #4]
 8004e46:	9b01      	ldr	r3, [sp, #4]
 8004e48:	f383 8811 	msr	BASEPRI, r3
}
 8004e4c:	b002      	add	sp, #8
 8004e4e:	4770      	bx	lr

08004e50 <port_lock_from_isr.lto_priv.187>:
static inline void port_lock_from_isr(void) {
 8004e50:	b508      	push	{r3, lr}
  port_lock();
 8004e52:	f7ff ffed 	bl	8004e30 <port_lock.lto_priv.124>
}
 8004e56:	bd08      	pop	{r3, pc}
	...

08004e60 <port_unlock_from_isr.lto_priv.174>:
static inline void port_unlock_from_isr(void) {
 8004e60:	b508      	push	{r3, lr}
  port_unlock();
 8004e62:	f7ff ffed 	bl	8004e40 <port_unlock.lto_priv.94>
}
 8004e66:	bd08      	pop	{r3, pc}
	...

08004e70 <chSysLock.lto_priv.67>:
static inline void chSysLock(void) {
 8004e70:	b508      	push	{r3, lr}
  port_lock();
 8004e72:	f7ff ffdd 	bl	8004e30 <port_lock.lto_priv.124>
  _stats_start_measure_crit_thd();
 8004e76:	f7fc fd33 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8004e7a:	f7fb fd51 	bl	8000920 <_dbg_check_lock>
}
 8004e7e:	bd08      	pop	{r3, pc}

08004e80 <chSysUnlock.lto_priv.26>:
static inline void chSysUnlock(void) {
 8004e80:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8004e82:	f7fb fd65 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8004e86:	f7fc fd33 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004e8a:	4b09      	ldr	r3, [pc, #36]	; (8004eb0 <chSysUnlock.lto_priv.26+0x30>)
 8004e8c:	681b      	ldr	r3, [r3, #0]
 8004e8e:	4a08      	ldr	r2, [pc, #32]	; (8004eb0 <chSysUnlock.lto_priv.26+0x30>)
 8004e90:	4293      	cmp	r3, r2
 8004e92:	d00a      	beq.n	8004eaa <chSysUnlock.lto_priv.26+0x2a>
 8004e94:	4b06      	ldr	r3, [pc, #24]	; (8004eb0 <chSysUnlock.lto_priv.26+0x30>)
 8004e96:	699b      	ldr	r3, [r3, #24]
 8004e98:	689a      	ldr	r2, [r3, #8]
 8004e9a:	4b05      	ldr	r3, [pc, #20]	; (8004eb0 <chSysUnlock.lto_priv.26+0x30>)
 8004e9c:	681b      	ldr	r3, [r3, #0]
 8004e9e:	689b      	ldr	r3, [r3, #8]
 8004ea0:	429a      	cmp	r2, r3
 8004ea2:	d202      	bcs.n	8004eaa <chSysUnlock.lto_priv.26+0x2a>
 8004ea4:	4803      	ldr	r0, [pc, #12]	; (8004eb4 <chSysUnlock.lto_priv.26+0x34>)
 8004ea6:	f7fb fcb3 	bl	8000810 <chSysHalt>
  port_unlock();
 8004eaa:	f7ff ffc9 	bl	8004e40 <port_unlock.lto_priv.94>
}
 8004eae:	bd08      	pop	{r3, pc}
 8004eb0:	20002128 	.word	0x20002128
 8004eb4:	0800aa00 	.word	0x0800aa00
	...

08004ec0 <chSysLockFromISR.lto_priv.161>:
static inline void chSysLockFromISR(void) {
 8004ec0:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8004ec2:	f7ff ffc5 	bl	8004e50 <port_lock_from_isr.lto_priv.187>
  _stats_start_measure_crit_isr();
 8004ec6:	f7fc fd1b 	bl	8001900 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8004eca:	f7fb fd59 	bl	8000980 <_dbg_check_lock_from_isr>
}
 8004ece:	bd08      	pop	{r3, pc}

08004ed0 <chSysUnlockFromISR.lto_priv.151>:
static inline void chSysUnlockFromISR(void) {
 8004ed0:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 8004ed2:	f7fb fd6d 	bl	80009b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8004ed6:	f7fc fd1b 	bl	8001910 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 8004eda:	f7ff ffc1 	bl	8004e60 <port_unlock_from_isr.lto_priv.174>
}
 8004ede:	bd08      	pop	{r3, pc}

08004ee0 <osalSysLock.lto_priv.233>:
static inline void osalSysLock(void) {
 8004ee0:	b508      	push	{r3, lr}
  chSysLock();
 8004ee2:	f7ff ffc5 	bl	8004e70 <chSysLock.lto_priv.67>
}
 8004ee6:	bd08      	pop	{r3, pc}
	...

08004ef0 <osalSysUnlock.lto_priv.224>:
static inline void osalSysUnlock(void) {
 8004ef0:	b508      	push	{r3, lr}
  chSysUnlock();
 8004ef2:	f7ff ffc5 	bl	8004e80 <chSysUnlock.lto_priv.26>
}
 8004ef6:	bd08      	pop	{r3, pc}
	...

08004f00 <osalSysLockFromISR.lto_priv.141>:
static inline void osalSysLockFromISR(void) {
 8004f00:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8004f02:	f7ff ffdd 	bl	8004ec0 <chSysLockFromISR.lto_priv.161>
}
 8004f06:	bd08      	pop	{r3, pc}
	...

08004f10 <osalSysUnlockFromISR.lto_priv.133>:
static inline void osalSysUnlockFromISR(void) {
 8004f10:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8004f12:	f7ff ffdd 	bl	8004ed0 <chSysUnlockFromISR.lto_priv.151>
}
 8004f16:	bd08      	pop	{r3, pc}
	...

08004f20 <osalThreadResumeI.lto_priv.210>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8004f20:	b500      	push	{lr}
 8004f22:	b083      	sub	sp, #12
 8004f24:	9001      	str	r0, [sp, #4]
 8004f26:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 8004f28:	9900      	ldr	r1, [sp, #0]
 8004f2a:	9801      	ldr	r0, [sp, #4]
 8004f2c:	f7fc fb30 	bl	8001590 <chThdResumeI>
}
 8004f30:	b003      	add	sp, #12
 8004f32:	f85d fb04 	ldr.w	pc, [sp], #4
 8004f36:	bf00      	nop
	...

08004f40 <get_hword>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static uint16_t get_hword(uint8_t *p) {
 8004f40:	b084      	sub	sp, #16
 8004f42:	9001      	str	r0, [sp, #4]
  uint16_t hw;

  hw  = (uint16_t)*p++;
 8004f44:	9b01      	ldr	r3, [sp, #4]
 8004f46:	1c5a      	adds	r2, r3, #1
 8004f48:	9201      	str	r2, [sp, #4]
 8004f4a:	781b      	ldrb	r3, [r3, #0]
 8004f4c:	f8ad 300e 	strh.w	r3, [sp, #14]
  hw |= (uint16_t)*p << 8U;
 8004f50:	9b01      	ldr	r3, [sp, #4]
 8004f52:	781b      	ldrb	r3, [r3, #0]
 8004f54:	021b      	lsls	r3, r3, #8
 8004f56:	b21a      	sxth	r2, r3
 8004f58:	f9bd 300e 	ldrsh.w	r3, [sp, #14]
 8004f5c:	4313      	orrs	r3, r2
 8004f5e:	b21b      	sxth	r3, r3
 8004f60:	f8ad 300e 	strh.w	r3, [sp, #14]
  return hw;
 8004f64:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
 8004f68:	4618      	mov	r0, r3
 8004f6a:	b004      	add	sp, #16
 8004f6c:	4770      	bx	lr
 8004f6e:	bf00      	nop

08004f70 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 8004f70:	b500      	push	{lr}
 8004f72:	b083      	sub	sp, #12
 8004f74:	9001      	str	r0, [sp, #4]

  usbp->address = usbp->setup[2];
 8004f76:	9b01      	ldr	r3, [sp, #4]
 8004f78:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 8004f7c:	9b01      	ldr	r3, [sp, #4]
 8004f7e:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usb_lld_set_address(usbp);
 8004f82:	9801      	ldr	r0, [sp, #4]
 8004f84:	f002 fdbc 	bl	8007b00 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8004f88:	9b01      	ldr	r3, [sp, #4]
 8004f8a:	685b      	ldr	r3, [r3, #4]
 8004f8c:	681b      	ldr	r3, [r3, #0]
 8004f8e:	2b00      	cmp	r3, #0
 8004f90:	d005      	beq.n	8004f9e <set_address+0x2e>
 8004f92:	9b01      	ldr	r3, [sp, #4]
 8004f94:	685b      	ldr	r3, [r3, #4]
 8004f96:	681b      	ldr	r3, [r3, #0]
 8004f98:	2101      	movs	r1, #1
 8004f9a:	9801      	ldr	r0, [sp, #4]
 8004f9c:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 8004f9e:	9b01      	ldr	r3, [sp, #4]
 8004fa0:	2203      	movs	r2, #3
 8004fa2:	701a      	strb	r2, [r3, #0]
}
 8004fa4:	b003      	add	sp, #12
 8004fa6:	f85d fb04 	ldr.w	pc, [sp], #4
 8004faa:	bf00      	nop
 8004fac:	0000      	movs	r0, r0
	...

08004fb0 <default_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The request handling exit code.
 * @retval false        Request not recognized by the handler or error.
 * @retval true         Request handled.
 */
static bool default_handler(USBDriver *usbp) {
 8004fb0:	b570      	push	{r4, r5, r6, lr}
 8004fb2:	b084      	sub	sp, #16
 8004fb4:	9001      	str	r0, [sp, #4]
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8004fb6:	9b01      	ldr	r3, [sp, #4]
 8004fb8:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8004fbc:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 8004fc0:	9b01      	ldr	r3, [sp, #4]
 8004fc2:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8004fc6:	021b      	lsls	r3, r3, #8
                                        USB_RTYPE_TYPE_MASK)) |
 8004fc8:	4313      	orrs	r3, r2
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8004fca:	f240 3202 	movw	r2, #770	; 0x302
 8004fce:	4293      	cmp	r3, r2
 8004fd0:	f000 819f 	beq.w	8005312 <default_handler+0x362>
 8004fd4:	f240 3202 	movw	r2, #770	; 0x302
 8004fd8:	4293      	cmp	r3, r2
 8004fda:	d815      	bhi.n	8005008 <default_handler+0x58>
 8004fdc:	2b02      	cmp	r3, #2
 8004fde:	f000 810e 	beq.w	80051fe <default_handler+0x24e>
 8004fe2:	2b02      	cmp	r3, #2
 8004fe4:	d805      	bhi.n	8004ff2 <default_handler+0x42>
 8004fe6:	2b00      	cmp	r3, #0
 8004fe8:	d027      	beq.n	800503a <default_handler+0x8a>
 8004fea:	2b01      	cmp	r3, #1
 8004fec:	f000 80fc 	beq.w	80051e8 <default_handler+0x238>
 8004ff0:	e1c3      	b.n	800537a <default_handler+0x3ca>
 8004ff2:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8004ff6:	f000 8158 	beq.w	80052aa <default_handler+0x2fa>
 8004ffa:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8004ffe:	d044      	beq.n	800508a <default_handler+0xda>
 8005000:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005004:	d026      	beq.n	8005054 <default_handler+0xa4>
 8005006:	e1b8      	b.n	800537a <default_handler+0x3ca>
 8005008:	f240 6201 	movw	r2, #1537	; 0x601
 800500c:	4293      	cmp	r3, r2
 800500e:	d806      	bhi.n	800501e <default_handler+0x6e>
 8005010:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8005014:	d26c      	bcs.n	80050f0 <default_handler+0x140>
 8005016:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800501a:	d051      	beq.n	80050c0 <default_handler+0x110>
 800501c:	e1ad      	b.n	800537a <default_handler+0x3ca>
 800501e:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 8005022:	f000 8098 	beq.w	8005156 <default_handler+0x1a6>
 8005026:	f640 4202 	movw	r2, #3074	; 0xc02
 800502a:	4293      	cmp	r3, r2
 800502c:	f000 80dc 	beq.w	80051e8 <default_handler+0x238>
 8005030:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8005034:	f000 8082 	beq.w	800513c <default_handler+0x18c>
 8005038:	e19f      	b.n	800537a <default_handler+0x3ca>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 800503a:	9b01      	ldr	r3, [sp, #4]
 800503c:	f103 0264 	add.w	r2, r3, #100	; 0x64
 8005040:	9b01      	ldr	r3, [sp, #4]
 8005042:	651a      	str	r2, [r3, #80]	; 0x50
 8005044:	9b01      	ldr	r3, [sp, #4]
 8005046:	2202      	movs	r2, #2
 8005048:	655a      	str	r2, [r3, #84]	; 0x54
 800504a:	9b01      	ldr	r3, [sp, #4]
 800504c:	2200      	movs	r2, #0
 800504e:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8005050:	2301      	movs	r3, #1
 8005052:	e193      	b.n	800537c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8005054:	9b01      	ldr	r3, [sp, #4]
 8005056:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800505a:	2b01      	cmp	r3, #1
 800505c:	d113      	bne.n	8005086 <default_handler+0xd6>
      usbp->status &= ~2U;
 800505e:	9b01      	ldr	r3, [sp, #4]
 8005060:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 8005064:	f023 0302 	bic.w	r3, r3, #2
 8005068:	b29a      	uxth	r2, r3
 800506a:	9b01      	ldr	r3, [sp, #4]
 800506c:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8005070:	9b01      	ldr	r3, [sp, #4]
 8005072:	2200      	movs	r2, #0
 8005074:	651a      	str	r2, [r3, #80]	; 0x50
 8005076:	9b01      	ldr	r3, [sp, #4]
 8005078:	2200      	movs	r2, #0
 800507a:	655a      	str	r2, [r3, #84]	; 0x54
 800507c:	9b01      	ldr	r3, [sp, #4]
 800507e:	2200      	movs	r2, #0
 8005080:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 8005082:	2301      	movs	r3, #1
 8005084:	e17a      	b.n	800537c <default_handler+0x3cc>
    }
    return false;
 8005086:	2300      	movs	r3, #0
 8005088:	e178      	b.n	800537c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800508a:	9b01      	ldr	r3, [sp, #4]
 800508c:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8005090:	2b01      	cmp	r3, #1
 8005092:	d113      	bne.n	80050bc <default_handler+0x10c>
      usbp->status |= 2U;
 8005094:	9b01      	ldr	r3, [sp, #4]
 8005096:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 800509a:	f043 0302 	orr.w	r3, r3, #2
 800509e:	b29a      	uxth	r2, r3
 80050a0:	9b01      	ldr	r3, [sp, #4]
 80050a2:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80050a6:	9b01      	ldr	r3, [sp, #4]
 80050a8:	2200      	movs	r2, #0
 80050aa:	651a      	str	r2, [r3, #80]	; 0x50
 80050ac:	9b01      	ldr	r3, [sp, #4]
 80050ae:	2200      	movs	r2, #0
 80050b0:	655a      	str	r2, [r3, #84]	; 0x54
 80050b2:	9b01      	ldr	r3, [sp, #4]
 80050b4:	2200      	movs	r2, #0
 80050b6:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 80050b8:	2301      	movs	r3, #1
 80050ba:	e15f      	b.n	800537c <default_handler+0x3cc>
    }
    return false;
 80050bc:	2300      	movs	r3, #0
 80050be:	e15d      	b.n	800537c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 80050c0:	9b01      	ldr	r3, [sp, #4]
 80050c2:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80050c6:	2b00      	cmp	r3, #0
 80050c8:	d107      	bne.n	80050da <default_handler+0x12a>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
 80050ca:	9b01      	ldr	r3, [sp, #4]
 80050cc:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 80050d0:	2b05      	cmp	r3, #5
 80050d2:	d102      	bne.n	80050da <default_handler+0x12a>
      set_address(usbp);
 80050d4:	9801      	ldr	r0, [sp, #4]
 80050d6:	f7ff ff4b 	bl	8004f70 <set_address>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80050da:	9b01      	ldr	r3, [sp, #4]
 80050dc:	2200      	movs	r2, #0
 80050de:	651a      	str	r2, [r3, #80]	; 0x50
 80050e0:	9b01      	ldr	r3, [sp, #4]
 80050e2:	2200      	movs	r2, #0
 80050e4:	655a      	str	r2, [r3, #84]	; 0x54
 80050e6:	9b01      	ldr	r3, [sp, #4]
 80050e8:	2200      	movs	r2, #0
 80050ea:	659a      	str	r2, [r3, #88]	; 0x58
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
 80050ec:	2301      	movs	r3, #1
 80050ee:	e145      	b.n	800537c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80050f0:	9b01      	ldr	r3, [sp, #4]
 80050f2:	685b      	ldr	r3, [r3, #4]
 80050f4:	685c      	ldr	r4, [r3, #4]
 80050f6:	9b01      	ldr	r3, [sp, #4]
 80050f8:	f893 505f 	ldrb.w	r5, [r3, #95]	; 0x5f
 80050fc:	9b01      	ldr	r3, [sp, #4]
 80050fe:	f893 605e 	ldrb.w	r6, [r3, #94]	; 0x5e
 8005102:	9b01      	ldr	r3, [sp, #4]
 8005104:	3360      	adds	r3, #96	; 0x60
 8005106:	4618      	mov	r0, r3
 8005108:	f7ff ff1a 	bl	8004f40 <get_hword>
 800510c:	4603      	mov	r3, r0
 800510e:	4632      	mov	r2, r6
 8005110:	4629      	mov	r1, r5
 8005112:	9801      	ldr	r0, [sp, #4]
 8005114:	47a0      	blx	r4
 8005116:	9003      	str	r0, [sp, #12]
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 8005118:	9b03      	ldr	r3, [sp, #12]
 800511a:	2b00      	cmp	r3, #0
 800511c:	d101      	bne.n	8005122 <default_handler+0x172>
      return false;
 800511e:	2300      	movs	r3, #0
 8005120:	e12c      	b.n	800537c <default_handler+0x3cc>
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8005122:	9b03      	ldr	r3, [sp, #12]
 8005124:	685a      	ldr	r2, [r3, #4]
 8005126:	9b01      	ldr	r3, [sp, #4]
 8005128:	651a      	str	r2, [r3, #80]	; 0x50
 800512a:	9b03      	ldr	r3, [sp, #12]
 800512c:	681a      	ldr	r2, [r3, #0]
 800512e:	9b01      	ldr	r3, [sp, #4]
 8005130:	655a      	str	r2, [r3, #84]	; 0x54
 8005132:	9b01      	ldr	r3, [sp, #4]
 8005134:	2200      	movs	r2, #0
 8005136:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 8005138:	2301      	movs	r3, #1
 800513a:	e11f      	b.n	800537c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 800513c:	9b01      	ldr	r3, [sp, #4]
 800513e:	f103 0267 	add.w	r2, r3, #103	; 0x67
 8005142:	9b01      	ldr	r3, [sp, #4]
 8005144:	651a      	str	r2, [r3, #80]	; 0x50
 8005146:	9b01      	ldr	r3, [sp, #4]
 8005148:	2201      	movs	r2, #1
 800514a:	655a      	str	r2, [r3, #84]	; 0x54
 800514c:	9b01      	ldr	r3, [sp, #4]
 800514e:	2200      	movs	r2, #0
 8005150:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8005152:	2301      	movs	r3, #1
 8005154:	e112      	b.n	800537c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host only if it is different
       from the current configuration.*/
    if (usbp->configuration != usbp->setup[2]) {
 8005156:	9b01      	ldr	r3, [sp, #4]
 8005158:	f893 2067 	ldrb.w	r2, [r3, #103]	; 0x67
 800515c:	9b01      	ldr	r3, [sp, #4]
 800515e:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8005162:	429a      	cmp	r2, r3
 8005164:	d035      	beq.n	80051d2 <default_handler+0x222>
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 8005166:	9b01      	ldr	r3, [sp, #4]
 8005168:	781b      	ldrb	r3, [r3, #0]
 800516a:	2b04      	cmp	r3, #4
 800516c:	d118      	bne.n	80051a0 <default_handler+0x1f0>
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
 800516e:	f7ff fec7 	bl	8004f00 <osalSysLockFromISR.lto_priv.141>
        usbDisableEndpointsI(usbp);
 8005172:	9801      	ldr	r0, [sp, #4]
 8005174:	f000 f9cc 	bl	8005510 <usbDisableEndpointsI>
        osalSysUnlockFromISR ();
 8005178:	f7ff feca 	bl	8004f10 <osalSysUnlockFromISR.lto_priv.133>
        usbp->configuration = 0U;
 800517c:	9b01      	ldr	r3, [sp, #4]
 800517e:	2200      	movs	r2, #0
 8005180:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_SELECTED;
 8005184:	9b01      	ldr	r3, [sp, #4]
 8005186:	2203      	movs	r2, #3
 8005188:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 800518a:	9b01      	ldr	r3, [sp, #4]
 800518c:	685b      	ldr	r3, [r3, #4]
 800518e:	681b      	ldr	r3, [r3, #0]
 8005190:	2b00      	cmp	r3, #0
 8005192:	d005      	beq.n	80051a0 <default_handler+0x1f0>
 8005194:	9b01      	ldr	r3, [sp, #4]
 8005196:	685b      	ldr	r3, [r3, #4]
 8005198:	681b      	ldr	r3, [r3, #0]
 800519a:	2103      	movs	r1, #3
 800519c:	9801      	ldr	r0, [sp, #4]
 800519e:	4798      	blx	r3
      }
      if (usbp->setup[2] != 0U) {
 80051a0:	9b01      	ldr	r3, [sp, #4]
 80051a2:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 80051a6:	2b00      	cmp	r3, #0
 80051a8:	d013      	beq.n	80051d2 <default_handler+0x222>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 80051aa:	9b01      	ldr	r3, [sp, #4]
 80051ac:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 80051b0:	9b01      	ldr	r3, [sp, #4]
 80051b2:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_ACTIVE;
 80051b6:	9b01      	ldr	r3, [sp, #4]
 80051b8:	2204      	movs	r2, #4
 80051ba:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 80051bc:	9b01      	ldr	r3, [sp, #4]
 80051be:	685b      	ldr	r3, [r3, #4]
 80051c0:	681b      	ldr	r3, [r3, #0]
 80051c2:	2b00      	cmp	r3, #0
 80051c4:	d005      	beq.n	80051d2 <default_handler+0x222>
 80051c6:	9b01      	ldr	r3, [sp, #4]
 80051c8:	685b      	ldr	r3, [r3, #4]
 80051ca:	681b      	ldr	r3, [r3, #0]
 80051cc:	2102      	movs	r1, #2
 80051ce:	9801      	ldr	r0, [sp, #4]
 80051d0:	4798      	blx	r3
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80051d2:	9b01      	ldr	r3, [sp, #4]
 80051d4:	2200      	movs	r2, #0
 80051d6:	651a      	str	r2, [r3, #80]	; 0x50
 80051d8:	9b01      	ldr	r3, [sp, #4]
 80051da:	2200      	movs	r2, #0
 80051dc:	655a      	str	r2, [r3, #84]	; 0x54
 80051de:	9b01      	ldr	r3, [sp, #4]
 80051e0:	2200      	movs	r2, #0
 80051e2:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 80051e4:	2301      	movs	r3, #1
 80051e6:	e0c9      	b.n	800537c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 80051e8:	9b01      	ldr	r3, [sp, #4]
 80051ea:	4a66      	ldr	r2, [pc, #408]	; (8005384 <default_handler+0x3d4>)
 80051ec:	651a      	str	r2, [r3, #80]	; 0x50
 80051ee:	9b01      	ldr	r3, [sp, #4]
 80051f0:	2202      	movs	r2, #2
 80051f2:	655a      	str	r2, [r3, #84]	; 0x54
 80051f4:	9b01      	ldr	r3, [sp, #4]
 80051f6:	2200      	movs	r2, #0
 80051f8:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 80051fa:	2301      	movs	r3, #1
 80051fc:	e0be      	b.n	800537c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 80051fe:	9b01      	ldr	r3, [sp, #4]
 8005200:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8005204:	b25b      	sxtb	r3, r3
 8005206:	2b00      	cmp	r3, #0
 8005208:	da27      	bge.n	800525a <default_handler+0x2aa>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800520a:	9b01      	ldr	r3, [sp, #4]
 800520c:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8005210:	f003 030f 	and.w	r3, r3, #15
 8005214:	b2db      	uxtb	r3, r3
 8005216:	4619      	mov	r1, r3
 8005218:	9801      	ldr	r0, [sp, #4]
 800521a:	f002 fde1 	bl	8007de0 <usb_lld_get_status_in>
 800521e:	4603      	mov	r3, r0
 8005220:	2b01      	cmp	r3, #1
 8005222:	d002      	beq.n	800522a <default_handler+0x27a>
 8005224:	2b02      	cmp	r3, #2
 8005226:	d00b      	beq.n	8005240 <default_handler+0x290>
 8005228:	e015      	b.n	8005256 <default_handler+0x2a6>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 800522a:	9b01      	ldr	r3, [sp, #4]
 800522c:	4a56      	ldr	r2, [pc, #344]	; (8005388 <default_handler+0x3d8>)
 800522e:	651a      	str	r2, [r3, #80]	; 0x50
 8005230:	9b01      	ldr	r3, [sp, #4]
 8005232:	2202      	movs	r2, #2
 8005234:	655a      	str	r2, [r3, #84]	; 0x54
 8005236:	9b01      	ldr	r3, [sp, #4]
 8005238:	2200      	movs	r2, #0
 800523a:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 800523c:	2301      	movs	r3, #1
 800523e:	e09d      	b.n	800537c <default_handler+0x3cc>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8005240:	9b01      	ldr	r3, [sp, #4]
 8005242:	4a52      	ldr	r2, [pc, #328]	; (800538c <default_handler+0x3dc>)
 8005244:	651a      	str	r2, [r3, #80]	; 0x50
 8005246:	9b01      	ldr	r3, [sp, #4]
 8005248:	2202      	movs	r2, #2
 800524a:	655a      	str	r2, [r3, #84]	; 0x54
 800524c:	9b01      	ldr	r3, [sp, #4]
 800524e:	2200      	movs	r2, #0
 8005250:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8005252:	2301      	movs	r3, #1
 8005254:	e092      	b.n	800537c <default_handler+0x3cc>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8005256:	2300      	movs	r3, #0
 8005258:	e090      	b.n	800537c <default_handler+0x3cc>
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 800525a:	9b01      	ldr	r3, [sp, #4]
 800525c:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8005260:	f003 030f 	and.w	r3, r3, #15
 8005264:	b2db      	uxtb	r3, r3
 8005266:	4619      	mov	r1, r3
 8005268:	9801      	ldr	r0, [sp, #4]
 800526a:	f002 fd99 	bl	8007da0 <usb_lld_get_status_out>
 800526e:	4603      	mov	r3, r0
 8005270:	2b01      	cmp	r3, #1
 8005272:	d002      	beq.n	800527a <default_handler+0x2ca>
 8005274:	2b02      	cmp	r3, #2
 8005276:	d00b      	beq.n	8005290 <default_handler+0x2e0>
 8005278:	e015      	b.n	80052a6 <default_handler+0x2f6>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 800527a:	9b01      	ldr	r3, [sp, #4]
 800527c:	4a42      	ldr	r2, [pc, #264]	; (8005388 <default_handler+0x3d8>)
 800527e:	651a      	str	r2, [r3, #80]	; 0x50
 8005280:	9b01      	ldr	r3, [sp, #4]
 8005282:	2202      	movs	r2, #2
 8005284:	655a      	str	r2, [r3, #84]	; 0x54
 8005286:	9b01      	ldr	r3, [sp, #4]
 8005288:	2200      	movs	r2, #0
 800528a:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 800528c:	2301      	movs	r3, #1
 800528e:	e075      	b.n	800537c <default_handler+0x3cc>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8005290:	9b01      	ldr	r3, [sp, #4]
 8005292:	4a3e      	ldr	r2, [pc, #248]	; (800538c <default_handler+0x3dc>)
 8005294:	651a      	str	r2, [r3, #80]	; 0x50
 8005296:	9b01      	ldr	r3, [sp, #4]
 8005298:	2202      	movs	r2, #2
 800529a:	655a      	str	r2, [r3, #84]	; 0x54
 800529c:	9b01      	ldr	r3, [sp, #4]
 800529e:	2200      	movs	r2, #0
 80052a0:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 80052a2:	2301      	movs	r3, #1
 80052a4:	e06a      	b.n	800537c <default_handler+0x3cc>
      case EP_STATUS_DISABLED:
      default:
        return false;
 80052a6:	2300      	movs	r3, #0
 80052a8:	e068      	b.n	800537c <default_handler+0x3cc>
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80052aa:	9b01      	ldr	r3, [sp, #4]
 80052ac:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 80052b0:	2b00      	cmp	r3, #0
 80052b2:	d001      	beq.n	80052b8 <default_handler+0x308>
      return false;
 80052b4:	2300      	movs	r3, #0
 80052b6:	e061      	b.n	800537c <default_handler+0x3cc>
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80052b8:	9b01      	ldr	r3, [sp, #4]
 80052ba:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80052be:	f003 030f 	and.w	r3, r3, #15
 80052c2:	2b00      	cmp	r3, #0
 80052c4:	d01a      	beq.n	80052fc <default_handler+0x34c>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80052c6:	9b01      	ldr	r3, [sp, #4]
 80052c8:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80052cc:	b25b      	sxtb	r3, r3
 80052ce:	2b00      	cmp	r3, #0
 80052d0:	da0a      	bge.n	80052e8 <default_handler+0x338>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 80052d2:	9b01      	ldr	r3, [sp, #4]
 80052d4:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80052d8:	f003 030f 	and.w	r3, r3, #15
 80052dc:	b2db      	uxtb	r3, r3
 80052de:	4619      	mov	r1, r3
 80052e0:	9801      	ldr	r0, [sp, #4]
 80052e2:	f002 ff65 	bl	80081b0 <usb_lld_clear_in>
 80052e6:	e009      	b.n	80052fc <default_handler+0x34c>
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 80052e8:	9b01      	ldr	r3, [sp, #4]
 80052ea:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80052ee:	f003 030f 	and.w	r3, r3, #15
 80052f2:	b2db      	uxtb	r3, r3
 80052f4:	4619      	mov	r1, r3
 80052f6:	9801      	ldr	r0, [sp, #4]
 80052f8:	f002 ff3a 	bl	8008170 <usb_lld_clear_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80052fc:	9b01      	ldr	r3, [sp, #4]
 80052fe:	2200      	movs	r2, #0
 8005300:	651a      	str	r2, [r3, #80]	; 0x50
 8005302:	9b01      	ldr	r3, [sp, #4]
 8005304:	2200      	movs	r2, #0
 8005306:	655a      	str	r2, [r3, #84]	; 0x54
 8005308:	9b01      	ldr	r3, [sp, #4]
 800530a:	2200      	movs	r2, #0
 800530c:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800530e:	2301      	movs	r3, #1
 8005310:	e034      	b.n	800537c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8005312:	9b01      	ldr	r3, [sp, #4]
 8005314:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8005318:	2b00      	cmp	r3, #0
 800531a:	d001      	beq.n	8005320 <default_handler+0x370>
      return false;
 800531c:	2300      	movs	r3, #0
 800531e:	e02d      	b.n	800537c <default_handler+0x3cc>
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8005320:	9b01      	ldr	r3, [sp, #4]
 8005322:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8005326:	f003 030f 	and.w	r3, r3, #15
 800532a:	2b00      	cmp	r3, #0
 800532c:	d01a      	beq.n	8005364 <default_handler+0x3b4>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800532e:	9b01      	ldr	r3, [sp, #4]
 8005330:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8005334:	b25b      	sxtb	r3, r3
 8005336:	2b00      	cmp	r3, #0
 8005338:	da0a      	bge.n	8005350 <default_handler+0x3a0>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800533a:	9b01      	ldr	r3, [sp, #4]
 800533c:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8005340:	f003 030f 	and.w	r3, r3, #15
 8005344:	b2db      	uxtb	r3, r3
 8005346:	4619      	mov	r1, r3
 8005348:	9801      	ldr	r0, [sp, #4]
 800534a:	f002 fef1 	bl	8008130 <usb_lld_stall_in>
 800534e:	e009      	b.n	8005364 <default_handler+0x3b4>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8005350:	9b01      	ldr	r3, [sp, #4]
 8005352:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8005356:	f003 030f 	and.w	r3, r3, #15
 800535a:	b2db      	uxtb	r3, r3
 800535c:	4619      	mov	r1, r3
 800535e:	9801      	ldr	r0, [sp, #4]
 8005360:	f002 fec6 	bl	80080f0 <usb_lld_stall_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8005364:	9b01      	ldr	r3, [sp, #4]
 8005366:	2200      	movs	r2, #0
 8005368:	651a      	str	r2, [r3, #80]	; 0x50
 800536a:	9b01      	ldr	r3, [sp, #4]
 800536c:	2200      	movs	r2, #0
 800536e:	655a      	str	r2, [r3, #84]	; 0x54
 8005370:	9b01      	ldr	r3, [sp, #4]
 8005372:	2200      	movs	r2, #0
 8005374:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8005376:	2301      	movs	r3, #1
 8005378:	e000      	b.n	800537c <default_handler+0x3cc>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_INTERFACE << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_SET_INTERFACE << 8):
    /* All the above requests are not handled here, if you need them then
       use the hook mechanism and provide handling.*/
  default:
    return false;
 800537a:	2300      	movs	r3, #0
  }
}
 800537c:	4618      	mov	r0, r3
 800537e:	b004      	add	sp, #16
 8005380:	bd70      	pop	{r4, r5, r6, pc}
 8005382:	bf00      	nop
 8005384:	0800a9c0 	.word	0x0800a9c0
 8005388:	0800a9e0 	.word	0x0800a9e0
 800538c:	0800a9d0 	.word	0x0800a9d0

08005390 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 8005390:	b508      	push	{r3, lr}

  usb_lld_init();
 8005392:	f002 fa4d 	bl	8007830 <usb_lld_init>
}
 8005396:	bd08      	pop	{r3, pc}
	...

080053a0 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 80053a0:	b084      	sub	sp, #16
 80053a2:	9001      	str	r0, [sp, #4]
  unsigned i;

  usbp->state        = USB_STOP;
 80053a4:	9b01      	ldr	r3, [sp, #4]
 80053a6:	2201      	movs	r2, #1
 80053a8:	701a      	strb	r2, [r3, #0]
  usbp->config       = NULL;
 80053aa:	9b01      	ldr	r3, [sp, #4]
 80053ac:	2200      	movs	r2, #0
 80053ae:	605a      	str	r2, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 80053b0:	2300      	movs	r3, #0
 80053b2:	9303      	str	r3, [sp, #12]
 80053b4:	e00f      	b.n	80053d6 <usbObjectInit+0x36>
    usbp->in_params[i]  = NULL;
 80053b6:	9a01      	ldr	r2, [sp, #4]
 80053b8:	9b03      	ldr	r3, [sp, #12]
 80053ba:	3308      	adds	r3, #8
 80053bc:	009b      	lsls	r3, r3, #2
 80053be:	4413      	add	r3, r2
 80053c0:	2200      	movs	r2, #0
 80053c2:	605a      	str	r2, [r3, #4]
    usbp->out_params[i] = NULL;
 80053c4:	9b01      	ldr	r3, [sp, #4]
 80053c6:	9a03      	ldr	r2, [sp, #12]
 80053c8:	320e      	adds	r2, #14
 80053ca:	2100      	movs	r1, #0
 80053cc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 80053d0:	9b03      	ldr	r3, [sp, #12]
 80053d2:	3301      	adds	r3, #1
 80053d4:	9303      	str	r3, [sp, #12]
 80053d6:	9b03      	ldr	r3, [sp, #12]
 80053d8:	2b04      	cmp	r3, #4
 80053da:	d9ec      	bls.n	80053b6 <usbObjectInit+0x16>
  }
  usbp->transmitting = 0;
 80053dc:	9b01      	ldr	r3, [sp, #4]
 80053de:	2200      	movs	r2, #0
 80053e0:	811a      	strh	r2, [r3, #8]
  usbp->receiving    = 0;
 80053e2:	9b01      	ldr	r3, [sp, #4]
 80053e4:	2200      	movs	r2, #0
 80053e6:	815a      	strh	r2, [r3, #10]
}
 80053e8:	b004      	add	sp, #16
 80053ea:	4770      	bx	lr
 80053ec:	0000      	movs	r0, r0
	...

080053f0 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 80053f0:	b500      	push	{lr}
 80053f2:	b085      	sub	sp, #20
 80053f4:	9001      	str	r0, [sp, #4]
 80053f6:	9100      	str	r1, [sp, #0]
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));
 80053f8:	9b01      	ldr	r3, [sp, #4]
 80053fa:	2b00      	cmp	r3, #0
 80053fc:	d002      	beq.n	8005404 <usbStart+0x14>
 80053fe:	9b00      	ldr	r3, [sp, #0]
 8005400:	2b00      	cmp	r3, #0
 8005402:	d102      	bne.n	800540a <usbStart+0x1a>
 8005404:	4816      	ldr	r0, [pc, #88]	; (8005460 <usbStart+0x70>)
 8005406:	f7fb fa03 	bl	8000810 <chSysHalt>

  osalSysLock();
 800540a:	f7ff fd69 	bl	8004ee0 <osalSysLock.lto_priv.233>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 800540e:	9b01      	ldr	r3, [sp, #4]
 8005410:	781b      	ldrb	r3, [r3, #0]
 8005412:	2b01      	cmp	r3, #1
 8005414:	d006      	beq.n	8005424 <usbStart+0x34>
 8005416:	9b01      	ldr	r3, [sp, #4]
 8005418:	781b      	ldrb	r3, [r3, #0]
 800541a:	2b02      	cmp	r3, #2
 800541c:	d002      	beq.n	8005424 <usbStart+0x34>
 800541e:	4810      	ldr	r0, [pc, #64]	; (8005460 <usbStart+0x70>)
 8005420:	f7fb f9f6 	bl	8000810 <chSysHalt>
                "invalid state");
  usbp->config = config;
 8005424:	9b01      	ldr	r3, [sp, #4]
 8005426:	9a00      	ldr	r2, [sp, #0]
 8005428:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800542a:	2300      	movs	r3, #0
 800542c:	9303      	str	r3, [sp, #12]
 800542e:	e009      	b.n	8005444 <usbStart+0x54>
    usbp->epc[i] = NULL;
 8005430:	9a01      	ldr	r2, [sp, #4]
 8005432:	9b03      	ldr	r3, [sp, #12]
 8005434:	3302      	adds	r3, #2
 8005436:	009b      	lsls	r3, r3, #2
 8005438:	4413      	add	r3, r2
 800543a:	2200      	movs	r2, #0
 800543c:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800543e:	9b03      	ldr	r3, [sp, #12]
 8005440:	3301      	adds	r3, #1
 8005442:	9303      	str	r3, [sp, #12]
 8005444:	9b03      	ldr	r3, [sp, #12]
 8005446:	2b05      	cmp	r3, #5
 8005448:	d9f2      	bls.n	8005430 <usbStart+0x40>
  }
  usb_lld_start(usbp);
 800544a:	9801      	ldr	r0, [sp, #4]
 800544c:	f002 fa20 	bl	8007890 <usb_lld_start>
  usbp->state = USB_READY;
 8005450:	9b01      	ldr	r3, [sp, #4]
 8005452:	2202      	movs	r2, #2
 8005454:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8005456:	f7ff fd4b 	bl	8004ef0 <osalSysUnlock.lto_priv.224>
}
 800545a:	b005      	add	sp, #20
 800545c:	f85d fb04 	ldr.w	pc, [sp], #4
 8005460:	0800a9f0 	.word	0x0800a9f0
	...

08005470 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8005470:	b500      	push	{lr}
 8005472:	b085      	sub	sp, #20
 8005474:	9003      	str	r0, [sp, #12]
 8005476:	460b      	mov	r3, r1
 8005478:	9201      	str	r2, [sp, #4]
 800547a:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheckClassI();
 800547e:	f7fb faef 	bl	8000a60 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 8005482:	9b03      	ldr	r3, [sp, #12]
 8005484:	2b00      	cmp	r3, #0
 8005486:	d002      	beq.n	800548e <usbInitEndpointI+0x1e>
 8005488:	9b01      	ldr	r3, [sp, #4]
 800548a:	2b00      	cmp	r3, #0
 800548c:	d102      	bne.n	8005494 <usbInitEndpointI+0x24>
 800548e:	481e      	ldr	r0, [pc, #120]	; (8005508 <usbInitEndpointI+0x98>)
 8005490:	f7fb f9be 	bl	8000810 <chSysHalt>
  osalDbgAssert(usbp->state == USB_ACTIVE,
 8005494:	9b03      	ldr	r3, [sp, #12]
 8005496:	781b      	ldrb	r3, [r3, #0]
 8005498:	2b04      	cmp	r3, #4
 800549a:	d002      	beq.n	80054a2 <usbInitEndpointI+0x32>
 800549c:	481a      	ldr	r0, [pc, #104]	; (8005508 <usbInitEndpointI+0x98>)
 800549e:	f7fb f9b7 	bl	8000810 <chSysHalt>
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 80054a2:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80054a6:	9a03      	ldr	r2, [sp, #12]
 80054a8:	3302      	adds	r3, #2
 80054aa:	009b      	lsls	r3, r3, #2
 80054ac:	4413      	add	r3, r2
 80054ae:	685b      	ldr	r3, [r3, #4]
 80054b0:	2b00      	cmp	r3, #0
 80054b2:	d002      	beq.n	80054ba <usbInitEndpointI+0x4a>
 80054b4:	4814      	ldr	r0, [pc, #80]	; (8005508 <usbInitEndpointI+0x98>)
 80054b6:	f7fb f9ab 	bl	8000810 <chSysHalt>

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 80054ba:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80054be:	9a03      	ldr	r2, [sp, #12]
 80054c0:	3302      	adds	r3, #2
 80054c2:	009b      	lsls	r3, r3, #2
 80054c4:	4413      	add	r3, r2
 80054c6:	9a01      	ldr	r2, [sp, #4]
 80054c8:	605a      	str	r2, [r3, #4]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 80054ca:	9b01      	ldr	r3, [sp, #4]
 80054cc:	695b      	ldr	r3, [r3, #20]
 80054ce:	2b00      	cmp	r3, #0
 80054d0:	d006      	beq.n	80054e0 <usbInitEndpointI+0x70>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 80054d2:	9b01      	ldr	r3, [sp, #4]
 80054d4:	695b      	ldr	r3, [r3, #20]
 80054d6:	2214      	movs	r2, #20
 80054d8:	2100      	movs	r1, #0
 80054da:	4618      	mov	r0, r3
 80054dc:	f004 fef8 	bl	800a2d0 <memset>
  }
  if (epcp->out_state != NULL) {
 80054e0:	9b01      	ldr	r3, [sp, #4]
 80054e2:	699b      	ldr	r3, [r3, #24]
 80054e4:	2b00      	cmp	r3, #0
 80054e6:	d006      	beq.n	80054f6 <usbInitEndpointI+0x86>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 80054e8:	9b01      	ldr	r3, [sp, #4]
 80054ea:	699b      	ldr	r3, [r3, #24]
 80054ec:	2214      	movs	r2, #20
 80054ee:	2100      	movs	r1, #0
 80054f0:	4618      	mov	r0, r3
 80054f2:	f004 feed 	bl	800a2d0 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 80054f6:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80054fa:	4619      	mov	r1, r3
 80054fc:	9803      	ldr	r0, [sp, #12]
 80054fe:	f002 fb17 	bl	8007b30 <usb_lld_init_endpoint>
}
 8005502:	b005      	add	sp, #20
 8005504:	f85d fb04 	ldr.w	pc, [sp], #4
 8005508:	0800aa10 	.word	0x0800aa10
 800550c:	00000000 	.word	0x00000000

08005510 <usbDisableEndpointsI>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @iclass
 */
void usbDisableEndpointsI(USBDriver *usbp) {
 8005510:	b500      	push	{lr}
 8005512:	b085      	sub	sp, #20
 8005514:	9001      	str	r0, [sp, #4]
  unsigned i;

  osalDbgCheckClassI();
 8005516:	f7fb faa3 	bl	8000a60 <chDbgCheckClassI>
  osalDbgCheck(usbp != NULL);
 800551a:	9b01      	ldr	r3, [sp, #4]
 800551c:	2b00      	cmp	r3, #0
 800551e:	d102      	bne.n	8005526 <usbDisableEndpointsI+0x16>
 8005520:	4830      	ldr	r0, [pc, #192]	; (80055e4 <usbDisableEndpointsI+0xd4>)
 8005522:	f7fb f975 	bl	8000810 <chSysHalt>
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 8005526:	9b01      	ldr	r3, [sp, #4]
 8005528:	781b      	ldrb	r3, [r3, #0]
 800552a:	2b04      	cmp	r3, #4
 800552c:	d002      	beq.n	8005534 <usbDisableEndpointsI+0x24>
 800552e:	482d      	ldr	r0, [pc, #180]	; (80055e4 <usbDisableEndpointsI+0xd4>)
 8005530:	f7fb f96e 	bl	8000810 <chSysHalt>

  usbp->transmitting &= 1U;
 8005534:	9b01      	ldr	r3, [sp, #4]
 8005536:	891b      	ldrh	r3, [r3, #8]
 8005538:	f003 0301 	and.w	r3, r3, #1
 800553c:	b29a      	uxth	r2, r3
 800553e:	9b01      	ldr	r3, [sp, #4]
 8005540:	811a      	strh	r2, [r3, #8]
  usbp->receiving    &= 1U;
 8005542:	9b01      	ldr	r3, [sp, #4]
 8005544:	895b      	ldrh	r3, [r3, #10]
 8005546:	f003 0301 	and.w	r3, r3, #1
 800554a:	b29a      	uxth	r2, r3
 800554c:	9b01      	ldr	r3, [sp, #4]
 800554e:	815a      	strh	r2, [r3, #10]

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8005550:	2301      	movs	r3, #1
 8005552:	9303      	str	r3, [sp, #12]
 8005554:	e03d      	b.n	80055d2 <usbDisableEndpointsI+0xc2>
#if USB_USE_WAIT == TRUE
    /* Signaling the event to threads waiting on endpoints.*/
    if (usbp->epc[i] != NULL) {
 8005556:	9a01      	ldr	r2, [sp, #4]
 8005558:	9b03      	ldr	r3, [sp, #12]
 800555a:	3302      	adds	r3, #2
 800555c:	009b      	lsls	r3, r3, #2
 800555e:	4413      	add	r3, r2
 8005560:	685b      	ldr	r3, [r3, #4]
 8005562:	2b00      	cmp	r3, #0
 8005564:	d02b      	beq.n	80055be <usbDisableEndpointsI+0xae>
      if (usbp->epc[i]->in_state != NULL) {
 8005566:	9a01      	ldr	r2, [sp, #4]
 8005568:	9b03      	ldr	r3, [sp, #12]
 800556a:	3302      	adds	r3, #2
 800556c:	009b      	lsls	r3, r3, #2
 800556e:	4413      	add	r3, r2
 8005570:	685b      	ldr	r3, [r3, #4]
 8005572:	695b      	ldr	r3, [r3, #20]
 8005574:	2b00      	cmp	r3, #0
 8005576:	d00c      	beq.n	8005592 <usbDisableEndpointsI+0x82>
        osalThreadResumeI(&usbp->epc[i]->in_state->thread, MSG_RESET);
 8005578:	9a01      	ldr	r2, [sp, #4]
 800557a:	9b03      	ldr	r3, [sp, #12]
 800557c:	3302      	adds	r3, #2
 800557e:	009b      	lsls	r3, r3, #2
 8005580:	4413      	add	r3, r2
 8005582:	685b      	ldr	r3, [r3, #4]
 8005584:	695b      	ldr	r3, [r3, #20]
 8005586:	330c      	adds	r3, #12
 8005588:	f06f 0101 	mvn.w	r1, #1
 800558c:	4618      	mov	r0, r3
 800558e:	f7ff fcc7 	bl	8004f20 <osalThreadResumeI.lto_priv.210>
      }
      if (usbp->epc[i]->out_state != NULL) {
 8005592:	9a01      	ldr	r2, [sp, #4]
 8005594:	9b03      	ldr	r3, [sp, #12]
 8005596:	3302      	adds	r3, #2
 8005598:	009b      	lsls	r3, r3, #2
 800559a:	4413      	add	r3, r2
 800559c:	685b      	ldr	r3, [r3, #4]
 800559e:	699b      	ldr	r3, [r3, #24]
 80055a0:	2b00      	cmp	r3, #0
 80055a2:	d00c      	beq.n	80055be <usbDisableEndpointsI+0xae>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
 80055a4:	9a01      	ldr	r2, [sp, #4]
 80055a6:	9b03      	ldr	r3, [sp, #12]
 80055a8:	3302      	adds	r3, #2
 80055aa:	009b      	lsls	r3, r3, #2
 80055ac:	4413      	add	r3, r2
 80055ae:	685b      	ldr	r3, [r3, #4]
 80055b0:	699b      	ldr	r3, [r3, #24]
 80055b2:	330c      	adds	r3, #12
 80055b4:	f06f 0101 	mvn.w	r1, #1
 80055b8:	4618      	mov	r0, r3
 80055ba:	f7ff fcb1 	bl	8004f20 <osalThreadResumeI.lto_priv.210>
      }
    }
#endif
    usbp->epc[i] = NULL;
 80055be:	9a01      	ldr	r2, [sp, #4]
 80055c0:	9b03      	ldr	r3, [sp, #12]
 80055c2:	3302      	adds	r3, #2
 80055c4:	009b      	lsls	r3, r3, #2
 80055c6:	4413      	add	r3, r2
 80055c8:	2200      	movs	r2, #0
 80055ca:	605a      	str	r2, [r3, #4]
  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80055cc:	9b03      	ldr	r3, [sp, #12]
 80055ce:	3301      	adds	r3, #1
 80055d0:	9303      	str	r3, [sp, #12]
 80055d2:	9b03      	ldr	r3, [sp, #12]
 80055d4:	2b05      	cmp	r3, #5
 80055d6:	d9be      	bls.n	8005556 <usbDisableEndpointsI+0x46>
  }

  /* Low level endpoints deactivation.*/
  usb_lld_disable_endpoints(usbp);
 80055d8:	9801      	ldr	r0, [sp, #4]
 80055da:	f002 fbd1 	bl	8007d80 <usb_lld_disable_endpoints>
}
 80055de:	b005      	add	sp, #20
 80055e0:	f85d fb04 	ldr.w	pc, [sp], #4
 80055e4:	0800aa30 	.word	0x0800aa30
	...

080055f0 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 80055f0:	b500      	push	{lr}
 80055f2:	b087      	sub	sp, #28
 80055f4:	9003      	str	r0, [sp, #12]
 80055f6:	9201      	str	r2, [sp, #4]
 80055f8:	9300      	str	r3, [sp, #0]
 80055fa:	460b      	mov	r3, r1
 80055fc:	f88d 300b 	strb.w	r3, [sp, #11]
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
 8005600:	f7fb fa2e 	bl	8000a60 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8005604:	9b03      	ldr	r3, [sp, #12]
 8005606:	2b00      	cmp	r3, #0
 8005608:	d003      	beq.n	8005612 <usbStartReceiveI+0x22>
 800560a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800560e:	2b05      	cmp	r3, #5
 8005610:	d902      	bls.n	8005618 <usbStartReceiveI+0x28>
 8005612:	481e      	ldr	r0, [pc, #120]	; (800568c <usbStartReceiveI+0x9c>)
 8005614:	f7fb f8fc 	bl	8000810 <chSysHalt>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 8005618:	9b03      	ldr	r3, [sp, #12]
 800561a:	895a      	ldrh	r2, [r3, #10]
 800561c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8005620:	2101      	movs	r1, #1
 8005622:	fa01 f303 	lsl.w	r3, r1, r3
 8005626:	b29b      	uxth	r3, r3
 8005628:	4013      	ands	r3, r2
 800562a:	b29b      	uxth	r3, r3
 800562c:	2b00      	cmp	r3, #0
 800562e:	d002      	beq.n	8005636 <usbStartReceiveI+0x46>
 8005630:	4816      	ldr	r0, [pc, #88]	; (800568c <usbStartReceiveI+0x9c>)
 8005632:	f7fb f8ed 	bl	8000810 <chSysHalt>

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8005636:	9b03      	ldr	r3, [sp, #12]
 8005638:	895a      	ldrh	r2, [r3, #10]
 800563a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800563e:	2101      	movs	r1, #1
 8005640:	fa01 f303 	lsl.w	r3, r1, r3
 8005644:	b29b      	uxth	r3, r3
 8005646:	4313      	orrs	r3, r2
 8005648:	b29a      	uxth	r2, r3
 800564a:	9b03      	ldr	r3, [sp, #12]
 800564c:	815a      	strh	r2, [r3, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 800564e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8005652:	9a03      	ldr	r2, [sp, #12]
 8005654:	3302      	adds	r3, #2
 8005656:	009b      	lsls	r3, r3, #2
 8005658:	4413      	add	r3, r2
 800565a:	685b      	ldr	r3, [r3, #4]
 800565c:	699b      	ldr	r3, [r3, #24]
 800565e:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  osp->rxbuf  = buf;
 8005660:	9b05      	ldr	r3, [sp, #20]
 8005662:	9a01      	ldr	r2, [sp, #4]
 8005664:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 8005666:	9b05      	ldr	r3, [sp, #20]
 8005668:	9a00      	ldr	r2, [sp, #0]
 800566a:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 800566c:	9b05      	ldr	r3, [sp, #20]
 800566e:	2200      	movs	r2, #0
 8005670:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
 8005672:	9b05      	ldr	r3, [sp, #20]
 8005674:	2200      	movs	r2, #0
 8005676:	60da      	str	r2, [r3, #12]
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8005678:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800567c:	4619      	mov	r1, r3
 800567e:	9803      	ldr	r0, [sp, #12]
 8005680:	f002 fbe6 	bl	8007e50 <usb_lld_start_out>
}
 8005684:	b007      	add	sp, #28
 8005686:	f85d fb04 	ldr.w	pc, [sp], #4
 800568a:	bf00      	nop
 800568c:	0800aa50 	.word	0x0800aa50

08005690 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8005690:	b500      	push	{lr}
 8005692:	b087      	sub	sp, #28
 8005694:	9003      	str	r0, [sp, #12]
 8005696:	9201      	str	r2, [sp, #4]
 8005698:	9300      	str	r3, [sp, #0]
 800569a:	460b      	mov	r3, r1
 800569c:	f88d 300b 	strb.w	r3, [sp, #11]
  USBInEndpointState *isp;

  osalDbgCheckClassI();
 80056a0:	f7fb f9de 	bl	8000a60 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 80056a4:	9b03      	ldr	r3, [sp, #12]
 80056a6:	2b00      	cmp	r3, #0
 80056a8:	d003      	beq.n	80056b2 <usbStartTransmitI+0x22>
 80056aa:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80056ae:	2b05      	cmp	r3, #5
 80056b0:	d902      	bls.n	80056b8 <usbStartTransmitI+0x28>
 80056b2:	481e      	ldr	r0, [pc, #120]	; (800572c <usbStartTransmitI+0x9c>)
 80056b4:	f7fb f8ac 	bl	8000810 <chSysHalt>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 80056b8:	9b03      	ldr	r3, [sp, #12]
 80056ba:	891a      	ldrh	r2, [r3, #8]
 80056bc:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80056c0:	2101      	movs	r1, #1
 80056c2:	fa01 f303 	lsl.w	r3, r1, r3
 80056c6:	b29b      	uxth	r3, r3
 80056c8:	4013      	ands	r3, r2
 80056ca:	b29b      	uxth	r3, r3
 80056cc:	2b00      	cmp	r3, #0
 80056ce:	d002      	beq.n	80056d6 <usbStartTransmitI+0x46>
 80056d0:	4816      	ldr	r0, [pc, #88]	; (800572c <usbStartTransmitI+0x9c>)
 80056d2:	f7fb f89d 	bl	8000810 <chSysHalt>

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80056d6:	9b03      	ldr	r3, [sp, #12]
 80056d8:	891a      	ldrh	r2, [r3, #8]
 80056da:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80056de:	2101      	movs	r1, #1
 80056e0:	fa01 f303 	lsl.w	r3, r1, r3
 80056e4:	b29b      	uxth	r3, r3
 80056e6:	4313      	orrs	r3, r2
 80056e8:	b29a      	uxth	r2, r3
 80056ea:	9b03      	ldr	r3, [sp, #12]
 80056ec:	811a      	strh	r2, [r3, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 80056ee:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80056f2:	9a03      	ldr	r2, [sp, #12]
 80056f4:	3302      	adds	r3, #2
 80056f6:	009b      	lsls	r3, r3, #2
 80056f8:	4413      	add	r3, r2
 80056fa:	685b      	ldr	r3, [r3, #4]
 80056fc:	695b      	ldr	r3, [r3, #20]
 80056fe:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 8005700:	9b05      	ldr	r3, [sp, #20]
 8005702:	9a01      	ldr	r2, [sp, #4]
 8005704:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 8005706:	9b05      	ldr	r3, [sp, #20]
 8005708:	9a00      	ldr	r2, [sp, #0]
 800570a:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 800570c:	9b05      	ldr	r3, [sp, #20]
 800570e:	2200      	movs	r2, #0
 8005710:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
 8005712:	9b05      	ldr	r3, [sp, #20]
 8005714:	2200      	movs	r2, #0
 8005716:	60da      	str	r2, [r3, #12]
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8005718:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800571c:	4619      	mov	r1, r3
 800571e:	9803      	ldr	r0, [sp, #12]
 8005720:	f002 fc36 	bl	8007f90 <usb_lld_start_in>
}
 8005724:	b007      	add	sp, #28
 8005726:	f85d fb04 	ldr.w	pc, [sp], #4
 800572a:	bf00      	nop
 800572c:	0800aa70 	.word	0x0800aa70

08005730 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8005730:	b500      	push	{lr}
 8005732:	b085      	sub	sp, #20
 8005734:	9001      	str	r0, [sp, #4]
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8005736:	9b01      	ldr	r3, [sp, #4]
 8005738:	2202      	movs	r2, #2
 800573a:	701a      	strb	r2, [r3, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 800573c:	9b01      	ldr	r3, [sp, #4]
 800573e:	2200      	movs	r2, #0
 8005740:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
  usbp->address       = 0;
 8005744:	9b01      	ldr	r3, [sp, #4]
 8005746:	2200      	movs	r2, #0
 8005748:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usbp->configuration = 0;
 800574c:	9b01      	ldr	r3, [sp, #4]
 800574e:	2200      	movs	r2, #0
 8005750:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
  usbp->transmitting  = 0;
 8005754:	9b01      	ldr	r3, [sp, #4]
 8005756:	2200      	movs	r2, #0
 8005758:	811a      	strh	r2, [r3, #8]
  usbp->receiving     = 0;
 800575a:	9b01      	ldr	r3, [sp, #4]
 800575c:	2200      	movs	r2, #0
 800575e:	815a      	strh	r2, [r3, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8005760:	2300      	movs	r3, #0
 8005762:	9303      	str	r3, [sp, #12]
 8005764:	e041      	b.n	80057ea <_usb_reset+0xba>
#if USB_USE_WAIT == TRUE
    /* Signaling the event to threads waiting on endpoints.*/
    if (usbp->epc[i] != NULL) {
 8005766:	9a01      	ldr	r2, [sp, #4]
 8005768:	9b03      	ldr	r3, [sp, #12]
 800576a:	3302      	adds	r3, #2
 800576c:	009b      	lsls	r3, r3, #2
 800576e:	4413      	add	r3, r2
 8005770:	685b      	ldr	r3, [r3, #4]
 8005772:	2b00      	cmp	r3, #0
 8005774:	d02f      	beq.n	80057d6 <_usb_reset+0xa6>
      osalSysLockFromISR();
 8005776:	f7ff fbc3 	bl	8004f00 <osalSysLockFromISR.lto_priv.141>
      if (usbp->epc[i]->in_state != NULL) {
 800577a:	9a01      	ldr	r2, [sp, #4]
 800577c:	9b03      	ldr	r3, [sp, #12]
 800577e:	3302      	adds	r3, #2
 8005780:	009b      	lsls	r3, r3, #2
 8005782:	4413      	add	r3, r2
 8005784:	685b      	ldr	r3, [r3, #4]
 8005786:	695b      	ldr	r3, [r3, #20]
 8005788:	2b00      	cmp	r3, #0
 800578a:	d00c      	beq.n	80057a6 <_usb_reset+0x76>
        osalThreadResumeI(&usbp->epc[i]->in_state->thread, MSG_RESET);
 800578c:	9a01      	ldr	r2, [sp, #4]
 800578e:	9b03      	ldr	r3, [sp, #12]
 8005790:	3302      	adds	r3, #2
 8005792:	009b      	lsls	r3, r3, #2
 8005794:	4413      	add	r3, r2
 8005796:	685b      	ldr	r3, [r3, #4]
 8005798:	695b      	ldr	r3, [r3, #20]
 800579a:	330c      	adds	r3, #12
 800579c:	f06f 0101 	mvn.w	r1, #1
 80057a0:	4618      	mov	r0, r3
 80057a2:	f7ff fbbd 	bl	8004f20 <osalThreadResumeI.lto_priv.210>
      }
      if (usbp->epc[i]->out_state != NULL) {
 80057a6:	9a01      	ldr	r2, [sp, #4]
 80057a8:	9b03      	ldr	r3, [sp, #12]
 80057aa:	3302      	adds	r3, #2
 80057ac:	009b      	lsls	r3, r3, #2
 80057ae:	4413      	add	r3, r2
 80057b0:	685b      	ldr	r3, [r3, #4]
 80057b2:	699b      	ldr	r3, [r3, #24]
 80057b4:	2b00      	cmp	r3, #0
 80057b6:	d00c      	beq.n	80057d2 <_usb_reset+0xa2>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
 80057b8:	9a01      	ldr	r2, [sp, #4]
 80057ba:	9b03      	ldr	r3, [sp, #12]
 80057bc:	3302      	adds	r3, #2
 80057be:	009b      	lsls	r3, r3, #2
 80057c0:	4413      	add	r3, r2
 80057c2:	685b      	ldr	r3, [r3, #4]
 80057c4:	699b      	ldr	r3, [r3, #24]
 80057c6:	330c      	adds	r3, #12
 80057c8:	f06f 0101 	mvn.w	r1, #1
 80057cc:	4618      	mov	r0, r3
 80057ce:	f7ff fba7 	bl	8004f20 <osalThreadResumeI.lto_priv.210>
      }
      osalSysUnlockFromISR();
 80057d2:	f7ff fb9d 	bl	8004f10 <osalSysUnlockFromISR.lto_priv.133>
    }
#endif
    usbp->epc[i] = NULL;
 80057d6:	9a01      	ldr	r2, [sp, #4]
 80057d8:	9b03      	ldr	r3, [sp, #12]
 80057da:	3302      	adds	r3, #2
 80057dc:	009b      	lsls	r3, r3, #2
 80057de:	4413      	add	r3, r2
 80057e0:	2200      	movs	r2, #0
 80057e2:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80057e4:	9b03      	ldr	r3, [sp, #12]
 80057e6:	3301      	adds	r3, #1
 80057e8:	9303      	str	r3, [sp, #12]
 80057ea:	9b03      	ldr	r3, [sp, #12]
 80057ec:	2b05      	cmp	r3, #5
 80057ee:	d9ba      	bls.n	8005766 <_usb_reset+0x36>
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_STP_WAITING;
 80057f0:	9b01      	ldr	r3, [sp, #4]
 80057f2:	2200      	movs	r2, #0
 80057f4:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

  /* Low level reset.*/
  usb_lld_reset(usbp);
 80057f8:	9801      	ldr	r0, [sp, #4]
 80057fa:	f002 f8e9 	bl	80079d0 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80057fe:	9b01      	ldr	r3, [sp, #4]
 8005800:	685b      	ldr	r3, [r3, #4]
 8005802:	681b      	ldr	r3, [r3, #0]
 8005804:	2b00      	cmp	r3, #0
 8005806:	d005      	beq.n	8005814 <_usb_reset+0xe4>
 8005808:	9b01      	ldr	r3, [sp, #4]
 800580a:	685b      	ldr	r3, [r3, #4]
 800580c:	681b      	ldr	r3, [r3, #0]
 800580e:	2100      	movs	r1, #0
 8005810:	9801      	ldr	r0, [sp, #4]
 8005812:	4798      	blx	r3
}
 8005814:	b005      	add	sp, #20
 8005816:	f85d fb04 	ldr.w	pc, [sp], #4
 800581a:	bf00      	nop
 800581c:	0000      	movs	r0, r0
	...

08005820 <_usb_suspend>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 8005820:	b500      	push	{lr}
 8005822:	b085      	sub	sp, #20
 8005824:	9001      	str	r0, [sp, #4]
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8005826:	9b01      	ldr	r3, [sp, #4]
 8005828:	781a      	ldrb	r2, [r3, #0]
 800582a:	9b01      	ldr	r3, [sp, #4]
 800582c:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  usbp->state       = USB_SUSPENDED;
 8005830:	9b01      	ldr	r3, [sp, #4]
 8005832:	2205      	movs	r2, #5
 8005834:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8005836:	9b01      	ldr	r3, [sp, #4]
 8005838:	685b      	ldr	r3, [r3, #4]
 800583a:	681b      	ldr	r3, [r3, #0]
 800583c:	2b00      	cmp	r3, #0
 800583e:	d005      	beq.n	800584c <_usb_suspend+0x2c>
 8005840:	9b01      	ldr	r3, [sp, #4]
 8005842:	685b      	ldr	r3, [r3, #4]
 8005844:	681b      	ldr	r3, [r3, #0]
 8005846:	2104      	movs	r1, #4
 8005848:	9801      	ldr	r0, [sp, #4]
 800584a:	4798      	blx	r3
  /* Signaling the event to threads waiting on endpoints.*/
#if USB_USE_WAIT == TRUE
  {
    unsigned i;

    for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800584c:	2300      	movs	r3, #0
 800584e:	9303      	str	r3, [sp, #12]
 8005850:	e03a      	b.n	80058c8 <_usb_suspend+0xa8>
      if (usbp->epc[i] != NULL) {
 8005852:	9a01      	ldr	r2, [sp, #4]
 8005854:	9b03      	ldr	r3, [sp, #12]
 8005856:	3302      	adds	r3, #2
 8005858:	009b      	lsls	r3, r3, #2
 800585a:	4413      	add	r3, r2
 800585c:	685b      	ldr	r3, [r3, #4]
 800585e:	2b00      	cmp	r3, #0
 8005860:	d02f      	beq.n	80058c2 <_usb_suspend+0xa2>
        osalSysLockFromISR();
 8005862:	f7ff fb4d 	bl	8004f00 <osalSysLockFromISR.lto_priv.141>
        if (usbp->epc[i]->in_state != NULL) {
 8005866:	9a01      	ldr	r2, [sp, #4]
 8005868:	9b03      	ldr	r3, [sp, #12]
 800586a:	3302      	adds	r3, #2
 800586c:	009b      	lsls	r3, r3, #2
 800586e:	4413      	add	r3, r2
 8005870:	685b      	ldr	r3, [r3, #4]
 8005872:	695b      	ldr	r3, [r3, #20]
 8005874:	2b00      	cmp	r3, #0
 8005876:	d00c      	beq.n	8005892 <_usb_suspend+0x72>
          osalThreadResumeI(&usbp->epc[i]->in_state->thread, MSG_RESET);
 8005878:	9a01      	ldr	r2, [sp, #4]
 800587a:	9b03      	ldr	r3, [sp, #12]
 800587c:	3302      	adds	r3, #2
 800587e:	009b      	lsls	r3, r3, #2
 8005880:	4413      	add	r3, r2
 8005882:	685b      	ldr	r3, [r3, #4]
 8005884:	695b      	ldr	r3, [r3, #20]
 8005886:	330c      	adds	r3, #12
 8005888:	f06f 0101 	mvn.w	r1, #1
 800588c:	4618      	mov	r0, r3
 800588e:	f7ff fb47 	bl	8004f20 <osalThreadResumeI.lto_priv.210>
        }
        if (usbp->epc[i]->out_state != NULL) {
 8005892:	9a01      	ldr	r2, [sp, #4]
 8005894:	9b03      	ldr	r3, [sp, #12]
 8005896:	3302      	adds	r3, #2
 8005898:	009b      	lsls	r3, r3, #2
 800589a:	4413      	add	r3, r2
 800589c:	685b      	ldr	r3, [r3, #4]
 800589e:	699b      	ldr	r3, [r3, #24]
 80058a0:	2b00      	cmp	r3, #0
 80058a2:	d00c      	beq.n	80058be <_usb_suspend+0x9e>
          osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
 80058a4:	9a01      	ldr	r2, [sp, #4]
 80058a6:	9b03      	ldr	r3, [sp, #12]
 80058a8:	3302      	adds	r3, #2
 80058aa:	009b      	lsls	r3, r3, #2
 80058ac:	4413      	add	r3, r2
 80058ae:	685b      	ldr	r3, [r3, #4]
 80058b0:	699b      	ldr	r3, [r3, #24]
 80058b2:	330c      	adds	r3, #12
 80058b4:	f06f 0101 	mvn.w	r1, #1
 80058b8:	4618      	mov	r0, r3
 80058ba:	f7ff fb31 	bl	8004f20 <osalThreadResumeI.lto_priv.210>
        }
        osalSysUnlockFromISR();
 80058be:	f7ff fb27 	bl	8004f10 <osalSysUnlockFromISR.lto_priv.133>
    for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80058c2:	9b03      	ldr	r3, [sp, #12]
 80058c4:	3301      	adds	r3, #1
 80058c6:	9303      	str	r3, [sp, #12]
 80058c8:	9b03      	ldr	r3, [sp, #12]
 80058ca:	2b05      	cmp	r3, #5
 80058cc:	d9c1      	bls.n	8005852 <_usb_suspend+0x32>
      }
    }
  }
#endif
}
 80058ce:	b005      	add	sp, #20
 80058d0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080058e0 <_usb_wakeup>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {
 80058e0:	b500      	push	{lr}
 80058e2:	b083      	sub	sp, #12
 80058e4:	9001      	str	r0, [sp, #4]

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 80058e6:	9b01      	ldr	r3, [sp, #4]
 80058e8:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
 80058ec:	9b01      	ldr	r3, [sp, #4]
 80058ee:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80058f0:	9b01      	ldr	r3, [sp, #4]
 80058f2:	685b      	ldr	r3, [r3, #4]
 80058f4:	681b      	ldr	r3, [r3, #0]
 80058f6:	2b00      	cmp	r3, #0
 80058f8:	d005      	beq.n	8005906 <_usb_wakeup+0x26>
 80058fa:	9b01      	ldr	r3, [sp, #4]
 80058fc:	685b      	ldr	r3, [r3, #4]
 80058fe:	681b      	ldr	r3, [r3, #0]
 8005900:	2105      	movs	r1, #5
 8005902:	9801      	ldr	r0, [sp, #4]
 8005904:	4798      	blx	r3
}
 8005906:	b003      	add	sp, #12
 8005908:	f85d fb04 	ldr.w	pc, [sp], #4
 800590c:	0000      	movs	r0, r0
	...

08005910 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8005910:	b500      	push	{lr}
 8005912:	b085      	sub	sp, #20
 8005914:	9001      	str	r0, [sp, #4]
 8005916:	460b      	mov	r3, r1
 8005918:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  /* Is the EP0 state machine in the correct state for handling setup
     packets?*/
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 800591c:	9b01      	ldr	r3, [sp, #4]
 800591e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8005922:	2b00      	cmp	r3, #0
 8005924:	d003      	beq.n	800592e <_usb_ep0setup+0x1e>
    /* This is unexpected could require handling with a warning event.*/
    /* TODO: handling here.*/

    /* Resetting the EP0 state machine and going ahead.*/
    usbp->ep0state = USB_EP0_STP_WAITING;
 8005926:	9b01      	ldr	r3, [sp, #4]
 8005928:	2200      	movs	r2, #0
 800592a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  }

  /* Reading the setup data into the driver buffer.*/
  usbReadSetup(usbp, ep, usbp->setup);
 800592e:	9b01      	ldr	r3, [sp, #4]
 8005930:	f103 025c 	add.w	r2, r3, #92	; 0x5c
 8005934:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005938:	4619      	mov	r1, r3
 800593a:	9801      	ldr	r0, [sp, #4]
 800593c:	f002 fa70 	bl	8007e20 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8005940:	9b01      	ldr	r3, [sp, #4]
 8005942:	685b      	ldr	r3, [r3, #4]
 8005944:	689b      	ldr	r3, [r3, #8]
 8005946:	2b00      	cmp	r3, #0
 8005948:	d00a      	beq.n	8005960 <_usb_ep0setup+0x50>
      !(usbp->config->requests_hook_cb(usbp))) {
 800594a:	9b01      	ldr	r3, [sp, #4]
 800594c:	685b      	ldr	r3, [r3, #4]
 800594e:	689b      	ldr	r3, [r3, #8]
 8005950:	9801      	ldr	r0, [sp, #4]
 8005952:	4798      	blx	r3
 8005954:	4603      	mov	r3, r0
 8005956:	f083 0301 	eor.w	r3, r3, #1
 800595a:	b2db      	uxtb	r3, r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 800595c:	2b00      	cmp	r3, #0
 800595e:	d027      	beq.n	80059b0 <_usb_ep0setup+0xa0>
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8005960:	9b01      	ldr	r3, [sp, #4]
 8005962:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8005966:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800596a:	2b00      	cmp	r3, #0
 800596c:	d108      	bne.n	8005980 <_usb_ep0setup+0x70>
        !default_handler(usbp)) {
 800596e:	9801      	ldr	r0, [sp, #4]
 8005970:	f7ff fb1e 	bl	8004fb0 <default_handler>
 8005974:	4603      	mov	r3, r0
 8005976:	f083 0301 	eor.w	r3, r3, #1
 800597a:	b2db      	uxtb	r3, r3
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 800597c:	2b00      	cmp	r3, #0
 800597e:	d017      	beq.n	80059b0 <_usb_ep0setup+0xa0>
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 8005980:	2100      	movs	r1, #0
 8005982:	9801      	ldr	r0, [sp, #4]
 8005984:	f002 fbd4 	bl	8008130 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 8005988:	2100      	movs	r1, #0
 800598a:	9801      	ldr	r0, [sp, #4]
 800598c:	f002 fbb0 	bl	80080f0 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8005990:	9b01      	ldr	r3, [sp, #4]
 8005992:	685b      	ldr	r3, [r3, #4]
 8005994:	681b      	ldr	r3, [r3, #0]
 8005996:	2b00      	cmp	r3, #0
 8005998:	d005      	beq.n	80059a6 <_usb_ep0setup+0x96>
 800599a:	9b01      	ldr	r3, [sp, #4]
 800599c:	685b      	ldr	r3, [r3, #4]
 800599e:	681b      	ldr	r3, [r3, #0]
 80059a0:	2106      	movs	r1, #6
 80059a2:	9801      	ldr	r0, [sp, #4]
 80059a4:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 80059a6:	9b01      	ldr	r3, [sp, #4]
 80059a8:	2206      	movs	r2, #6
 80059aa:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 80059ae:	e05b      	b.n	8005a68 <_usb_ep0setup+0x158>
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 80059b0:	9b01      	ldr	r3, [sp, #4]
 80059b2:	3362      	adds	r3, #98	; 0x62
 80059b4:	4618      	mov	r0, r3
 80059b6:	f7ff fac3 	bl	8004f40 <get_hword>
 80059ba:	4603      	mov	r3, r0
 80059bc:	9303      	str	r3, [sp, #12]
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 80059be:	9b01      	ldr	r3, [sp, #4]
 80059c0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80059c2:	9a03      	ldr	r2, [sp, #12]
 80059c4:	429a      	cmp	r2, r3
 80059c6:	d202      	bcs.n	80059ce <_usb_ep0setup+0xbe>
    usbp->ep0n = max;
 80059c8:	9b01      	ldr	r3, [sp, #4]
 80059ca:	9a03      	ldr	r2, [sp, #12]
 80059cc:	655a      	str	r2, [r3, #84]	; 0x54
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80059ce:	9b01      	ldr	r3, [sp, #4]
 80059d0:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80059d4:	b25b      	sxtb	r3, r3
 80059d6:	2b00      	cmp	r3, #0
 80059d8:	da23      	bge.n	8005a22 <_usb_ep0setup+0x112>
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 80059da:	9b01      	ldr	r3, [sp, #4]
 80059dc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80059de:	2b00      	cmp	r3, #0
 80059e0:	d010      	beq.n	8005a04 <_usb_ep0setup+0xf4>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_IN_TX;
 80059e2:	9b01      	ldr	r3, [sp, #4]
 80059e4:	2209      	movs	r2, #9
 80059e6:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 80059ea:	f7ff fa89 	bl	8004f00 <osalSysLockFromISR.lto_priv.141>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80059ee:	9b01      	ldr	r3, [sp, #4]
 80059f0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80059f2:	9b01      	ldr	r3, [sp, #4]
 80059f4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80059f6:	2100      	movs	r1, #0
 80059f8:	9801      	ldr	r0, [sp, #4]
 80059fa:	f7ff fe49 	bl	8005690 <usbStartTransmitI>
      osalSysUnlockFromISR();
 80059fe:	f7ff fa87 	bl	8004f10 <osalSysUnlockFromISR.lto_priv.133>
         packet.*/
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, NULL, 0);
      osalSysUnlockFromISR();
 8005a02:	e031      	b.n	8005a68 <_usb_ep0setup+0x158>
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8005a04:	9b01      	ldr	r3, [sp, #4]
 8005a06:	2214      	movs	r2, #20
 8005a08:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 8005a0c:	f7ff fa78 	bl	8004f00 <osalSysLockFromISR.lto_priv.141>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8005a10:	2300      	movs	r3, #0
 8005a12:	2200      	movs	r2, #0
 8005a14:	2100      	movs	r1, #0
 8005a16:	9801      	ldr	r0, [sp, #4]
 8005a18:	f7ff fdea 	bl	80055f0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8005a1c:	f7ff fa78 	bl	8004f10 <osalSysUnlockFromISR.lto_priv.133>
 8005a20:	e022      	b.n	8005a68 <_usb_ep0setup+0x158>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8005a22:	9b01      	ldr	r3, [sp, #4]
 8005a24:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005a26:	2b00      	cmp	r3, #0
 8005a28:	d010      	beq.n	8005a4c <_usb_ep0setup+0x13c>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_OUT_RX;
 8005a2a:	9b01      	ldr	r3, [sp, #4]
 8005a2c:	2215      	movs	r2, #21
 8005a2e:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 8005a32:	f7ff fa65 	bl	8004f00 <osalSysLockFromISR.lto_priv.141>
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8005a36:	9b01      	ldr	r3, [sp, #4]
 8005a38:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8005a3a:	9b01      	ldr	r3, [sp, #4]
 8005a3c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005a3e:	2100      	movs	r1, #0
 8005a40:	9801      	ldr	r0, [sp, #4]
 8005a42:	f7ff fdd5 	bl	80055f0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8005a46:	f7ff fa63 	bl	8004f10 <osalSysUnlockFromISR.lto_priv.133>
 8005a4a:	e00d      	b.n	8005a68 <_usb_ep0setup+0x158>
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8005a4c:	9b01      	ldr	r3, [sp, #4]
 8005a4e:	220b      	movs	r2, #11
 8005a50:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 8005a54:	f7ff fa54 	bl	8004f00 <osalSysLockFromISR.lto_priv.141>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8005a58:	2300      	movs	r3, #0
 8005a5a:	2200      	movs	r2, #0
 8005a5c:	2100      	movs	r1, #0
 8005a5e:	9801      	ldr	r0, [sp, #4]
 8005a60:	f7ff fe16 	bl	8005690 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8005a64:	f7ff fa54 	bl	8004f10 <osalSysUnlockFromISR.lto_priv.133>
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 8005a68:	b005      	add	sp, #20
 8005a6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a6e:	bf00      	nop

08005a70 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8005a70:	b500      	push	{lr}
 8005a72:	b085      	sub	sp, #20
 8005a74:	9001      	str	r0, [sp, #4]
 8005a76:	460b      	mov	r3, r1
 8005a78:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8005a7c:	9b01      	ldr	r3, [sp, #4]
 8005a7e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8005a82:	2b15      	cmp	r3, #21
 8005a84:	f200 808e 	bhi.w	8005ba4 <_usb_ep0in+0x134>
 8005a88:	a201      	add	r2, pc, #4	; (adr r2, 8005a90 <_usb_ep0in+0x20>)
 8005a8a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005a8e:	bf00      	nop
 8005a90:	08005b6f 	.word	0x08005b6f
 8005a94:	08005ba5 	.word	0x08005ba5
 8005a98:	08005ba5 	.word	0x08005ba5
 8005a9c:	08005ba5 	.word	0x08005ba5
 8005aa0:	08005ba5 	.word	0x08005ba5
 8005aa4:	08005ba5 	.word	0x08005ba5
 8005aa8:	08005b75 	.word	0x08005b75
 8005aac:	08005ba5 	.word	0x08005ba5
 8005ab0:	08005ba5 	.word	0x08005ba5
 8005ab4:	08005ae9 	.word	0x08005ae9
 8005ab8:	08005b37 	.word	0x08005b37
 8005abc:	08005b55 	.word	0x08005b55
 8005ac0:	08005ba5 	.word	0x08005ba5
 8005ac4:	08005ba5 	.word	0x08005ba5
 8005ac8:	08005ba5 	.word	0x08005ba5
 8005acc:	08005ba5 	.word	0x08005ba5
 8005ad0:	08005ba5 	.word	0x08005ba5
 8005ad4:	08005ba5 	.word	0x08005ba5
 8005ad8:	08005ba5 	.word	0x08005ba5
 8005adc:	08005ba5 	.word	0x08005ba5
 8005ae0:	08005b6f 	.word	0x08005b6f
 8005ae4:	08005b6f 	.word	0x08005b6f
  case USB_EP0_IN_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 8005ae8:	9b01      	ldr	r3, [sp, #4]
 8005aea:	3362      	adds	r3, #98	; 0x62
 8005aec:	4618      	mov	r0, r3
 8005aee:	f7ff fa27 	bl	8004f40 <get_hword>
 8005af2:	4603      	mov	r3, r0
 8005af4:	9303      	str	r3, [sp, #12]
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8005af6:	9b01      	ldr	r3, [sp, #4]
 8005af8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005afa:	9a03      	ldr	r2, [sp, #12]
 8005afc:	429a      	cmp	r2, r3
 8005afe:	d91a      	bls.n	8005b36 <_usb_ep0in+0xc6>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8005b00:	9b01      	ldr	r3, [sp, #4]
 8005b02:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005b04:	9a01      	ldr	r2, [sp, #4]
 8005b06:	68d2      	ldr	r2, [r2, #12]
 8005b08:	8a12      	ldrh	r2, [r2, #16]
 8005b0a:	fbb3 f1f2 	udiv	r1, r3, r2
 8005b0e:	fb02 f201 	mul.w	r2, r2, r1
 8005b12:	1a9b      	subs	r3, r3, r2
    if ((usbp->ep0n < max) &&
 8005b14:	2b00      	cmp	r3, #0
 8005b16:	d10e      	bne.n	8005b36 <_usb_ep0in+0xc6>
      osalSysLockFromISR();
 8005b18:	f7ff f9f2 	bl	8004f00 <osalSysLockFromISR.lto_priv.141>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8005b1c:	2300      	movs	r3, #0
 8005b1e:	2200      	movs	r2, #0
 8005b20:	2100      	movs	r1, #0
 8005b22:	9801      	ldr	r0, [sp, #4]
 8005b24:	f7ff fdb4 	bl	8005690 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8005b28:	f7ff f9f2 	bl	8004f10 <osalSysUnlockFromISR.lto_priv.133>
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 8005b2c:	9b01      	ldr	r3, [sp, #4]
 8005b2e:	220a      	movs	r2, #10
 8005b30:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8005b34:	e039      	b.n	8005baa <_usb_ep0in+0x13a>
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_IN_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8005b36:	9b01      	ldr	r3, [sp, #4]
 8005b38:	2214      	movs	r2, #20
 8005b3a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 8005b3e:	f7ff f9df 	bl	8004f00 <osalSysLockFromISR.lto_priv.141>
    usbStartReceiveI(usbp, 0, NULL, 0);
 8005b42:	2300      	movs	r3, #0
 8005b44:	2200      	movs	r2, #0
 8005b46:	2100      	movs	r1, #0
 8005b48:	9801      	ldr	r0, [sp, #4]
 8005b4a:	f7ff fd51 	bl	80055f0 <usbStartReceiveI>
    osalSysUnlockFromISR();
 8005b4e:	f7ff f9df 	bl	8004f10 <osalSysUnlockFromISR.lto_priv.133>
 8005b52:	e02a      	b.n	8005baa <_usb_ep0in+0x13a>
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_IN_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8005b54:	9b01      	ldr	r3, [sp, #4]
 8005b56:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005b58:	2b00      	cmp	r3, #0
 8005b5a:	d003      	beq.n	8005b64 <_usb_ep0in+0xf4>
      usbp->ep0endcb(usbp);
 8005b5c:	9b01      	ldr	r3, [sp, #4]
 8005b5e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005b60:	9801      	ldr	r0, [sp, #4]
 8005b62:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 8005b64:	9b01      	ldr	r3, [sp, #4]
 8005b66:	2200      	movs	r2, #0
 8005b68:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8005b6c:	e01d      	b.n	8005baa <_usb_ep0in+0x13a>
    return;
  case USB_EP0_STP_WAITING:
  case USB_EP0_OUT_WAITING_STS:
  case USB_EP0_OUT_RX:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 8005b6e:	4810      	ldr	r0, [pc, #64]	; (8005bb0 <_usb_ep0in+0x140>)
 8005b70:	f7fa fe4e 	bl	8000810 <chSysHalt>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8005b74:	2100      	movs	r1, #0
 8005b76:	9801      	ldr	r0, [sp, #4]
 8005b78:	f002 fada 	bl	8008130 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8005b7c:	2100      	movs	r1, #0
 8005b7e:	9801      	ldr	r0, [sp, #4]
 8005b80:	f002 fab6 	bl	80080f0 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8005b84:	9b01      	ldr	r3, [sp, #4]
 8005b86:	685b      	ldr	r3, [r3, #4]
 8005b88:	681b      	ldr	r3, [r3, #0]
 8005b8a:	2b00      	cmp	r3, #0
 8005b8c:	d005      	beq.n	8005b9a <_usb_ep0in+0x12a>
 8005b8e:	9b01      	ldr	r3, [sp, #4]
 8005b90:	685b      	ldr	r3, [r3, #4]
 8005b92:	681b      	ldr	r3, [r3, #0]
 8005b94:	2106      	movs	r1, #6
 8005b96:	9801      	ldr	r0, [sp, #4]
 8005b98:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8005b9a:	9b01      	ldr	r3, [sp, #4]
 8005b9c:	2206      	movs	r2, #6
 8005b9e:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8005ba2:	e002      	b.n	8005baa <_usb_ep0in+0x13a>
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 8005ba4:	4802      	ldr	r0, [pc, #8]	; (8005bb0 <_usb_ep0in+0x140>)
 8005ba6:	f7fa fe33 	bl	8000810 <chSysHalt>
  }
}
 8005baa:	b005      	add	sp, #20
 8005bac:	f85d fb04 	ldr.w	pc, [sp], #4
 8005bb0:	0800aa90 	.word	0x0800aa90
	...

08005bc0 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8005bc0:	b500      	push	{lr}
 8005bc2:	b083      	sub	sp, #12
 8005bc4:	9001      	str	r0, [sp, #4]
 8005bc6:	460b      	mov	r3, r1
 8005bc8:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)ep;
  switch (usbp->ep0state) {
 8005bcc:	9b01      	ldr	r3, [sp, #4]
 8005bce:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8005bd2:	2b15      	cmp	r3, #21
 8005bd4:	d86b      	bhi.n	8005cae <_usb_ep0out+0xee>
 8005bd6:	a201      	add	r2, pc, #4	; (adr r2, 8005bdc <_usb_ep0out+0x1c>)
 8005bd8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005bdc:	08005c79 	.word	0x08005c79
 8005be0:	08005caf 	.word	0x08005caf
 8005be4:	08005caf 	.word	0x08005caf
 8005be8:	08005caf 	.word	0x08005caf
 8005bec:	08005caf 	.word	0x08005caf
 8005bf0:	08005caf 	.word	0x08005caf
 8005bf4:	08005c7f 	.word	0x08005c7f
 8005bf8:	08005caf 	.word	0x08005caf
 8005bfc:	08005caf 	.word	0x08005caf
 8005c00:	08005c79 	.word	0x08005c79
 8005c04:	08005c79 	.word	0x08005c79
 8005c08:	08005c79 	.word	0x08005c79
 8005c0c:	08005caf 	.word	0x08005caf
 8005c10:	08005caf 	.word	0x08005caf
 8005c14:	08005caf 	.word	0x08005caf
 8005c18:	08005caf 	.word	0x08005caf
 8005c1c:	08005caf 	.word	0x08005caf
 8005c20:	08005caf 	.word	0x08005caf
 8005c24:	08005caf 	.word	0x08005caf
 8005c28:	08005caf 	.word	0x08005caf
 8005c2c:	08005c53 	.word	0x08005c53
 8005c30:	08005c35 	.word	0x08005c35
  case USB_EP0_OUT_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8005c34:	9b01      	ldr	r3, [sp, #4]
 8005c36:	220b      	movs	r2, #11
 8005c38:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 8005c3c:	f7ff f960 	bl	8004f00 <osalSysLockFromISR.lto_priv.141>
    usbStartTransmitI(usbp, 0, NULL, 0);
 8005c40:	2300      	movs	r3, #0
 8005c42:	2200      	movs	r2, #0
 8005c44:	2100      	movs	r1, #0
 8005c46:	9801      	ldr	r0, [sp, #4]
 8005c48:	f7ff fd22 	bl	8005690 <usbStartTransmitI>
    osalSysUnlockFromISR();
 8005c4c:	f7ff f960 	bl	8004f10 <osalSysUnlockFromISR.lto_priv.133>
 8005c50:	e030      	b.n	8005cb4 <_usb_ep0out+0xf4>
    return;
  case USB_EP0_OUT_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8005c52:	9b01      	ldr	r3, [sp, #4]
 8005c54:	68db      	ldr	r3, [r3, #12]
 8005c56:	699b      	ldr	r3, [r3, #24]
 8005c58:	685b      	ldr	r3, [r3, #4]
 8005c5a:	2b00      	cmp	r3, #0
 8005c5c:	d12a      	bne.n	8005cb4 <_usb_ep0out+0xf4>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 8005c5e:	9b01      	ldr	r3, [sp, #4]
 8005c60:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005c62:	2b00      	cmp	r3, #0
 8005c64:	d003      	beq.n	8005c6e <_usb_ep0out+0xae>
      usbp->ep0endcb(usbp);
 8005c66:	9b01      	ldr	r3, [sp, #4]
 8005c68:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005c6a:	9801      	ldr	r0, [sp, #4]
 8005c6c:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 8005c6e:	9b01      	ldr	r3, [sp, #4]
 8005c70:	2200      	movs	r2, #0
 8005c72:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8005c76:	e01d      	b.n	8005cb4 <_usb_ep0out+0xf4>
  case USB_EP0_STP_WAITING:
  case USB_EP0_IN_TX:
  case USB_EP0_IN_WAITING_TX0:
  case USB_EP0_IN_SENDING_STS:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 8005c78:	4810      	ldr	r0, [pc, #64]	; (8005cbc <_usb_ep0out+0xfc>)
 8005c7a:	f7fa fdc9 	bl	8000810 <chSysHalt>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8005c7e:	2100      	movs	r1, #0
 8005c80:	9801      	ldr	r0, [sp, #4]
 8005c82:	f002 fa55 	bl	8008130 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8005c86:	2100      	movs	r1, #0
 8005c88:	9801      	ldr	r0, [sp, #4]
 8005c8a:	f002 fa31 	bl	80080f0 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8005c8e:	9b01      	ldr	r3, [sp, #4]
 8005c90:	685b      	ldr	r3, [r3, #4]
 8005c92:	681b      	ldr	r3, [r3, #0]
 8005c94:	2b00      	cmp	r3, #0
 8005c96:	d005      	beq.n	8005ca4 <_usb_ep0out+0xe4>
 8005c98:	9b01      	ldr	r3, [sp, #4]
 8005c9a:	685b      	ldr	r3, [r3, #4]
 8005c9c:	681b      	ldr	r3, [r3, #0]
 8005c9e:	2106      	movs	r1, #6
 8005ca0:	9801      	ldr	r0, [sp, #4]
 8005ca2:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8005ca4:	9b01      	ldr	r3, [sp, #4]
 8005ca6:	2206      	movs	r2, #6
 8005ca8:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8005cac:	e002      	b.n	8005cb4 <_usb_ep0out+0xf4>
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 8005cae:	4803      	ldr	r0, [pc, #12]	; (8005cbc <_usb_ep0out+0xfc>)
 8005cb0:	f7fa fdae 	bl	8000810 <chSysHalt>
  }
}
 8005cb4:	b003      	add	sp, #12
 8005cb6:	f85d fb04 	ldr.w	pc, [sp], #4
 8005cba:	bf00      	nop
 8005cbc:	0800aaa0 	.word	0x0800aaa0

08005cc0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8005cc0:	b082      	sub	sp, #8
 8005cc2:	9001      	str	r0, [sp, #4]
 8005cc4:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8005cc6:	9b00      	ldr	r3, [sp, #0]
 8005cc8:	b2db      	uxtb	r3, r3
 8005cca:	4a11      	ldr	r2, [pc, #68]	; (8005d10 <nvicEnableVector+0x50>)
 8005ccc:	011b      	lsls	r3, r3, #4
 8005cce:	b2d9      	uxtb	r1, r3
 8005cd0:	9b01      	ldr	r3, [sp, #4]
 8005cd2:	4413      	add	r3, r2
 8005cd4:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8005cd8:	460a      	mov	r2, r1
 8005cda:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005cdc:	9b01      	ldr	r3, [sp, #4]
 8005cde:	f003 021f 	and.w	r2, r3, #31
 8005ce2:	490b      	ldr	r1, [pc, #44]	; (8005d10 <nvicEnableVector+0x50>)
 8005ce4:	9b01      	ldr	r3, [sp, #4]
 8005ce6:	095b      	lsrs	r3, r3, #5
 8005ce8:	2001      	movs	r0, #1
 8005cea:	fa00 f202 	lsl.w	r2, r0, r2
 8005cee:	3360      	adds	r3, #96	; 0x60
 8005cf0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8005cf4:	9b01      	ldr	r3, [sp, #4]
 8005cf6:	f003 021f 	and.w	r2, r3, #31
 8005cfa:	4905      	ldr	r1, [pc, #20]	; (8005d10 <nvicEnableVector+0x50>)
 8005cfc:	9b01      	ldr	r3, [sp, #4]
 8005cfe:	095b      	lsrs	r3, r3, #5
 8005d00:	2001      	movs	r0, #1
 8005d02:	fa00 f202 	lsl.w	r2, r0, r2
 8005d06:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8005d0a:	b002      	add	sp, #8
 8005d0c:	4770      	bx	lr
 8005d0e:	bf00      	nop
 8005d10:	e000e100 	.word	0xe000e100
	...

08005d20 <nvicSetSystemHandlerPriority>:
 * @brief   Changes the priority of a system handler.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8005d20:	b500      	push	{lr}
 8005d22:	b083      	sub	sp, #12
 8005d24:	9001      	str	r0, [sp, #4]
 8005d26:	9100      	str	r1, [sp, #0]

  osalDbgCheck(handler < 12U);
 8005d28:	9b01      	ldr	r3, [sp, #4]
 8005d2a:	2b0b      	cmp	r3, #11
 8005d2c:	d902      	bls.n	8005d34 <nvicSetSystemHandlerPriority+0x14>
 8005d2e:	4808      	ldr	r0, [pc, #32]	; (8005d50 <nvicSetSystemHandlerPriority+0x30>)
 8005d30:	f7fa fd6e 	bl	8000810 <chSysHalt>
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 8005d34:	9b00      	ldr	r3, [sp, #0]
 8005d36:	b2db      	uxtb	r3, r3
 8005d38:	4a06      	ldr	r2, [pc, #24]	; (8005d54 <nvicSetSystemHandlerPriority+0x34>)
 8005d3a:	011b      	lsls	r3, r3, #4
 8005d3c:	b2d9      	uxtb	r1, r3
 8005d3e:	9b01      	ldr	r3, [sp, #4]
 8005d40:	4413      	add	r3, r2
 8005d42:	3318      	adds	r3, #24
 8005d44:	460a      	mov	r2, r1
 8005d46:	701a      	strb	r2, [r3, #0]
#endif
}
 8005d48:	b003      	add	sp, #12
 8005d4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d4e:	bf00      	nop
 8005d50:	0800aab0 	.word	0x0800aab0
 8005d54:	e000ed00 	.word	0xe000ed00
	...

08005d60 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8005d60:	4b0d      	ldr	r3, [pc, #52]	; (8005d98 <hal_lld_backup_domain_init+0x38>)
 8005d62:	681b      	ldr	r3, [r3, #0]
 8005d64:	4a0c      	ldr	r2, [pc, #48]	; (8005d98 <hal_lld_backup_domain_init+0x38>)
 8005d66:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005d6a:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8005d6c:	4b0b      	ldr	r3, [pc, #44]	; (8005d9c <hal_lld_backup_domain_init+0x3c>)
 8005d6e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005d70:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005d74:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005d78:	d006      	beq.n	8005d88 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8005d7a:	4b08      	ldr	r3, [pc, #32]	; (8005d9c <hal_lld_backup_domain_init+0x3c>)
 8005d7c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8005d80:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8005d82:	4b06      	ldr	r3, [pc, #24]	; (8005d9c <hal_lld_backup_domain_init+0x3c>)
 8005d84:	2200      	movs	r2, #0
 8005d86:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8005d88:	4b03      	ldr	r3, [pc, #12]	; (8005d98 <hal_lld_backup_domain_init+0x38>)
 8005d8a:	685b      	ldr	r3, [r3, #4]
 8005d8c:	4a02      	ldr	r2, [pc, #8]	; (8005d98 <hal_lld_backup_domain_init+0x38>)
 8005d8e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8005d92:	6053      	str	r3, [r2, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 8005d94:	4770      	bx	lr
 8005d96:	bf00      	nop
 8005d98:	40007000 	.word	0x40007000
 8005d9c:	40023800 	.word	0x40023800

08005da0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8005da0:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8005da2:	4b17      	ldr	r3, [pc, #92]	; (8005e00 <hal_lld_init+0x60>)
 8005da4:	691b      	ldr	r3, [r3, #16]
 8005da6:	4b16      	ldr	r3, [pc, #88]	; (8005e00 <hal_lld_init+0x60>)
 8005da8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005dac:	611a      	str	r2, [r3, #16]
 8005dae:	4b14      	ldr	r3, [pc, #80]	; (8005e00 <hal_lld_init+0x60>)
 8005db0:	2200      	movs	r2, #0
 8005db2:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8005db4:	4b12      	ldr	r3, [pc, #72]	; (8005e00 <hal_lld_init+0x60>)
 8005db6:	695b      	ldr	r3, [r3, #20]
 8005db8:	4b11      	ldr	r3, [pc, #68]	; (8005e00 <hal_lld_init+0x60>)
 8005dba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005dbe:	615a      	str	r2, [r3, #20]
 8005dc0:	4b0f      	ldr	r3, [pc, #60]	; (8005e00 <hal_lld_init+0x60>)
 8005dc2:	2200      	movs	r2, #0
 8005dc4:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8005dc6:	4b0e      	ldr	r3, [pc, #56]	; (8005e00 <hal_lld_init+0x60>)
 8005dc8:	6a1b      	ldr	r3, [r3, #32]
 8005dca:	4a0d      	ldr	r2, [pc, #52]	; (8005e00 <hal_lld_init+0x60>)
 8005dcc:	f063 5380 	orn	r3, r3, #268435456	; 0x10000000
 8005dd0:	6213      	str	r3, [r2, #32]
 8005dd2:	4b0b      	ldr	r3, [pc, #44]	; (8005e00 <hal_lld_init+0x60>)
 8005dd4:	2200      	movs	r2, #0
 8005dd6:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8005dd8:	4b09      	ldr	r3, [pc, #36]	; (8005e00 <hal_lld_init+0x60>)
 8005dda:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005ddc:	4b08      	ldr	r3, [pc, #32]	; (8005e00 <hal_lld_init+0x60>)
 8005dde:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005de2:	625a      	str	r2, [r3, #36]	; 0x24
 8005de4:	4b06      	ldr	r3, [pc, #24]	; (8005e00 <hal_lld_init+0x60>)
 8005de6:	2200      	movs	r2, #0
 8005de8:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8005dea:	4b05      	ldr	r3, [pc, #20]	; (8005e00 <hal_lld_init+0x60>)
 8005dec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005dee:	4a04      	ldr	r2, [pc, #16]	; (8005e00 <hal_lld_init+0x60>)
 8005df0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005df4:	6413      	str	r3, [r2, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8005df6:	f7ff ffb3 	bl	8005d60 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8005dfa:	f000 fb01 	bl	8006400 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 8005dfe:	bd08      	pop	{r3, pc}
 8005e00:	40023800 	.word	0x40023800
	...

08005e10 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8005e10:	4b36      	ldr	r3, [pc, #216]	; (8005eec <stm32_clock_init+0xdc>)
 8005e12:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005e16:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8005e18:	4b35      	ldr	r3, [pc, #212]	; (8005ef0 <stm32_clock_init+0xe0>)
 8005e1a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8005e1e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8005e20:	4b32      	ldr	r3, [pc, #200]	; (8005eec <stm32_clock_init+0xdc>)
 8005e22:	681b      	ldr	r3, [r3, #0]
 8005e24:	4a31      	ldr	r2, [pc, #196]	; (8005eec <stm32_clock_init+0xdc>)
 8005e26:	f043 0301 	orr.w	r3, r3, #1
 8005e2a:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8005e2c:	4b2f      	ldr	r3, [pc, #188]	; (8005eec <stm32_clock_init+0xdc>)
 8005e2e:	681b      	ldr	r3, [r3, #0]
 8005e30:	f003 0302 	and.w	r3, r3, #2
 8005e34:	2b00      	cmp	r3, #0
 8005e36:	d0f9      	beq.n	8005e2c <stm32_clock_init+0x1c>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8005e38:	4b2c      	ldr	r3, [pc, #176]	; (8005eec <stm32_clock_init+0xdc>)
 8005e3a:	689b      	ldr	r3, [r3, #8]
 8005e3c:	4a2b      	ldr	r2, [pc, #172]	; (8005eec <stm32_clock_init+0xdc>)
 8005e3e:	f023 0303 	bic.w	r3, r3, #3
 8005e42:	6093      	str	r3, [r2, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8005e44:	4b29      	ldr	r3, [pc, #164]	; (8005eec <stm32_clock_init+0xdc>)
 8005e46:	4a29      	ldr	r2, [pc, #164]	; (8005eec <stm32_clock_init+0xdc>)
 8005e48:	689b      	ldr	r3, [r3, #8]
 8005e4a:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8005e4c:	4b27      	ldr	r3, [pc, #156]	; (8005eec <stm32_clock_init+0xdc>)
 8005e4e:	689b      	ldr	r3, [r3, #8]
 8005e50:	f003 030c 	and.w	r3, r3, #12
 8005e54:	2b00      	cmp	r3, #0
 8005e56:	d1f9      	bne.n	8005e4c <stm32_clock_init+0x3c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8005e58:	4b24      	ldr	r3, [pc, #144]	; (8005eec <stm32_clock_init+0xdc>)
 8005e5a:	681b      	ldr	r3, [r3, #0]
 8005e5c:	4a23      	ldr	r2, [pc, #140]	; (8005eec <stm32_clock_init+0xdc>)
 8005e5e:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 8005e62:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8005e64:	4b21      	ldr	r3, [pc, #132]	; (8005eec <stm32_clock_init+0xdc>)
 8005e66:	2200      	movs	r2, #0
 8005e68:	609a      	str	r2, [r3, #8]
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8005e6a:	4b20      	ldr	r3, [pc, #128]	; (8005eec <stm32_clock_init+0xdc>)
 8005e6c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8005e6e:	4a1f      	ldr	r2, [pc, #124]	; (8005eec <stm32_clock_init+0xdc>)
 8005e70:	f043 0301 	orr.w	r3, r3, #1
 8005e74:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8005e76:	4b1d      	ldr	r3, [pc, #116]	; (8005eec <stm32_clock_init+0xdc>)
 8005e78:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8005e7a:	f003 0302 	and.w	r3, r3, #2
 8005e7e:	2b00      	cmp	r3, #0
 8005e80:	d0f9      	beq.n	8005e76 <stm32_clock_init+0x66>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8005e82:	4b1a      	ldr	r3, [pc, #104]	; (8005eec <stm32_clock_init+0xdc>)
 8005e84:	4a1b      	ldr	r2, [pc, #108]	; (8005ef4 <stm32_clock_init+0xe4>)
 8005e86:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8005e88:	4b18      	ldr	r3, [pc, #96]	; (8005eec <stm32_clock_init+0xdc>)
 8005e8a:	681b      	ldr	r3, [r3, #0]
 8005e8c:	4a17      	ldr	r2, [pc, #92]	; (8005eec <stm32_clock_init+0xdc>)
 8005e8e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8005e92:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8005e94:	4b16      	ldr	r3, [pc, #88]	; (8005ef0 <stm32_clock_init+0xe0>)
 8005e96:	685b      	ldr	r3, [r3, #4]
 8005e98:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8005e9c:	2b00      	cmp	r3, #0
 8005e9e:	d0f9      	beq.n	8005e94 <stm32_clock_init+0x84>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8005ea0:	4b12      	ldr	r3, [pc, #72]	; (8005eec <stm32_clock_init+0xdc>)
 8005ea2:	681b      	ldr	r3, [r3, #0]
 8005ea4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8005ea8:	2b00      	cmp	r3, #0
 8005eaa:	d0f9      	beq.n	8005ea0 <stm32_clock_init+0x90>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8005eac:	4b0f      	ldr	r3, [pc, #60]	; (8005eec <stm32_clock_init+0xdc>)
 8005eae:	4a12      	ldr	r2, [pc, #72]	; (8005ef8 <stm32_clock_init+0xe8>)
 8005eb0:	609a      	str	r2, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8005eb2:	4b12      	ldr	r3, [pc, #72]	; (8005efc <stm32_clock_init+0xec>)
 8005eb4:	f240 7205 	movw	r2, #1797	; 0x705
 8005eb8:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8005eba:	4b0c      	ldr	r3, [pc, #48]	; (8005eec <stm32_clock_init+0xdc>)
 8005ebc:	689b      	ldr	r3, [r3, #8]
 8005ebe:	4a0b      	ldr	r2, [pc, #44]	; (8005eec <stm32_clock_init+0xdc>)
 8005ec0:	f043 0302 	orr.w	r3, r3, #2
 8005ec4:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8005ec6:	4b09      	ldr	r3, [pc, #36]	; (8005eec <stm32_clock_init+0xdc>)
 8005ec8:	689b      	ldr	r3, [r3, #8]
 8005eca:	f003 030c 	and.w	r3, r3, #12
 8005ece:	2b08      	cmp	r3, #8
 8005ed0:	d1f9      	bne.n	8005ec6 <stm32_clock_init+0xb6>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8005ed2:	4b06      	ldr	r3, [pc, #24]	; (8005eec <stm32_clock_init+0xdc>)
 8005ed4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8005ed6:	4a05      	ldr	r2, [pc, #20]	; (8005eec <stm32_clock_init+0xdc>)
 8005ed8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005edc:	6453      	str	r3, [r2, #68]	; 0x44
 8005ede:	4b03      	ldr	r3, [pc, #12]	; (8005eec <stm32_clock_init+0xdc>)
 8005ee0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8005ee2:	4a02      	ldr	r2, [pc, #8]	; (8005eec <stm32_clock_init+0xdc>)
 8005ee4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005ee8:	6653      	str	r3, [r2, #100]	; 0x64
}
 8005eea:	4770      	bx	lr
 8005eec:	40023800 	.word	0x40023800
 8005ef0:	40007000 	.word	0x40007000
 8005ef4:	07002a08 	.word	0x07002a08
 8005ef8:	38889400 	.word	0x38889400
 8005efc:	40023c00 	.word	0x40023c00

08005f00 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8005f00:	b500      	push	{lr}
 8005f02:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8005f04:	f7fb fcbc 	bl	8001880 <_stats_increase_irq>
 8005f08:	f7fa fd6a 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8005f0c:	4b0c      	ldr	r3, [pc, #48]	; (8005f40 <Vector6C+0x40>)
 8005f0e:	681b      	ldr	r3, [r3, #0]
 8005f10:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005f14:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
 8005f16:	4a0a      	ldr	r2, [pc, #40]	; (8005f40 <Vector6C+0x40>)
 8005f18:	9b01      	ldr	r3, [sp, #4]
 8005f1a:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[0].dma_func)
 8005f1c:	4b09      	ldr	r3, [pc, #36]	; (8005f44 <Vector6C+0x44>)
 8005f1e:	681b      	ldr	r3, [r3, #0]
 8005f20:	2b00      	cmp	r3, #0
 8005f22:	d006      	beq.n	8005f32 <Vector6C+0x32>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8005f24:	4b07      	ldr	r3, [pc, #28]	; (8005f44 <Vector6C+0x44>)
 8005f26:	681b      	ldr	r3, [r3, #0]
 8005f28:	4a06      	ldr	r2, [pc, #24]	; (8005f44 <Vector6C+0x44>)
 8005f2a:	6852      	ldr	r2, [r2, #4]
 8005f2c:	9901      	ldr	r1, [sp, #4]
 8005f2e:	4610      	mov	r0, r2
 8005f30:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005f32:	f7fa fd75 	bl	8000a20 <_dbg_check_leave_isr>
 8005f36:	f7fc fd73 	bl	8002a20 <_port_irq_epilogue>
}
 8005f3a:	b003      	add	sp, #12
 8005f3c:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f40:	40026000 	.word	0x40026000
 8005f44:	200023ac 	.word	0x200023ac
	...

08005f50 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8005f50:	b500      	push	{lr}
 8005f52:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8005f54:	f7fb fc94 	bl	8001880 <_stats_increase_irq>
 8005f58:	f7fa fd42 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8005f5c:	4b0d      	ldr	r3, [pc, #52]	; (8005f94 <Vector70+0x44>)
 8005f5e:	681b      	ldr	r3, [r3, #0]
 8005f60:	099b      	lsrs	r3, r3, #6
 8005f62:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005f66:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
 8005f68:	4a0a      	ldr	r2, [pc, #40]	; (8005f94 <Vector70+0x44>)
 8005f6a:	9b01      	ldr	r3, [sp, #4]
 8005f6c:	019b      	lsls	r3, r3, #6
 8005f6e:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[1].dma_func)
 8005f70:	4b09      	ldr	r3, [pc, #36]	; (8005f98 <Vector70+0x48>)
 8005f72:	689b      	ldr	r3, [r3, #8]
 8005f74:	2b00      	cmp	r3, #0
 8005f76:	d006      	beq.n	8005f86 <Vector70+0x36>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8005f78:	4b07      	ldr	r3, [pc, #28]	; (8005f98 <Vector70+0x48>)
 8005f7a:	689b      	ldr	r3, [r3, #8]
 8005f7c:	4a06      	ldr	r2, [pc, #24]	; (8005f98 <Vector70+0x48>)
 8005f7e:	68d2      	ldr	r2, [r2, #12]
 8005f80:	9901      	ldr	r1, [sp, #4]
 8005f82:	4610      	mov	r0, r2
 8005f84:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005f86:	f7fa fd4b 	bl	8000a20 <_dbg_check_leave_isr>
 8005f8a:	f7fc fd49 	bl	8002a20 <_port_irq_epilogue>
}
 8005f8e:	b003      	add	sp, #12
 8005f90:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f94:	40026000 	.word	0x40026000
 8005f98:	200023ac 	.word	0x200023ac
 8005f9c:	00000000 	.word	0x00000000

08005fa0 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8005fa0:	b500      	push	{lr}
 8005fa2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8005fa4:	f7fb fc6c 	bl	8001880 <_stats_increase_irq>
 8005fa8:	f7fa fd1a 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8005fac:	4b0d      	ldr	r3, [pc, #52]	; (8005fe4 <Vector74+0x44>)
 8005fae:	681b      	ldr	r3, [r3, #0]
 8005fb0:	0c1b      	lsrs	r3, r3, #16
 8005fb2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8005fb6:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
 8005fb8:	4a0a      	ldr	r2, [pc, #40]	; (8005fe4 <Vector74+0x44>)
 8005fba:	9b01      	ldr	r3, [sp, #4]
 8005fbc:	041b      	lsls	r3, r3, #16
 8005fbe:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[2].dma_func)
 8005fc0:	4b09      	ldr	r3, [pc, #36]	; (8005fe8 <Vector74+0x48>)
 8005fc2:	691b      	ldr	r3, [r3, #16]
 8005fc4:	2b00      	cmp	r3, #0
 8005fc6:	d006      	beq.n	8005fd6 <Vector74+0x36>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8005fc8:	4b07      	ldr	r3, [pc, #28]	; (8005fe8 <Vector74+0x48>)
 8005fca:	691b      	ldr	r3, [r3, #16]
 8005fcc:	4a06      	ldr	r2, [pc, #24]	; (8005fe8 <Vector74+0x48>)
 8005fce:	6952      	ldr	r2, [r2, #20]
 8005fd0:	9901      	ldr	r1, [sp, #4]
 8005fd2:	4610      	mov	r0, r2
 8005fd4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005fd6:	f7fa fd23 	bl	8000a20 <_dbg_check_leave_isr>
 8005fda:	f7fc fd21 	bl	8002a20 <_port_irq_epilogue>
}
 8005fde:	b003      	add	sp, #12
 8005fe0:	f85d fb04 	ldr.w	pc, [sp], #4
 8005fe4:	40026000 	.word	0x40026000
 8005fe8:	200023ac 	.word	0x200023ac
 8005fec:	00000000 	.word	0x00000000

08005ff0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8005ff0:	b500      	push	{lr}
 8005ff2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8005ff4:	f7fb fc44 	bl	8001880 <_stats_increase_irq>
 8005ff8:	f7fa fcf2 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8005ffc:	4b0d      	ldr	r3, [pc, #52]	; (8006034 <Vector78+0x44>)
 8005ffe:	681b      	ldr	r3, [r3, #0]
 8006000:	0d9b      	lsrs	r3, r3, #22
 8006002:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8006006:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
 8006008:	4a0a      	ldr	r2, [pc, #40]	; (8006034 <Vector78+0x44>)
 800600a:	9b01      	ldr	r3, [sp, #4]
 800600c:	059b      	lsls	r3, r3, #22
 800600e:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[3].dma_func)
 8006010:	4b09      	ldr	r3, [pc, #36]	; (8006038 <Vector78+0x48>)
 8006012:	699b      	ldr	r3, [r3, #24]
 8006014:	2b00      	cmp	r3, #0
 8006016:	d006      	beq.n	8006026 <Vector78+0x36>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8006018:	4b07      	ldr	r3, [pc, #28]	; (8006038 <Vector78+0x48>)
 800601a:	699b      	ldr	r3, [r3, #24]
 800601c:	4a06      	ldr	r2, [pc, #24]	; (8006038 <Vector78+0x48>)
 800601e:	69d2      	ldr	r2, [r2, #28]
 8006020:	9901      	ldr	r1, [sp, #4]
 8006022:	4610      	mov	r0, r2
 8006024:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006026:	f7fa fcfb 	bl	8000a20 <_dbg_check_leave_isr>
 800602a:	f7fc fcf9 	bl	8002a20 <_port_irq_epilogue>
}
 800602e:	b003      	add	sp, #12
 8006030:	f85d fb04 	ldr.w	pc, [sp], #4
 8006034:	40026000 	.word	0x40026000
 8006038:	200023ac 	.word	0x200023ac
 800603c:	00000000 	.word	0x00000000

08006040 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8006040:	b500      	push	{lr}
 8006042:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006044:	f7fb fc1c 	bl	8001880 <_stats_increase_irq>
 8006048:	f7fa fcca 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800604c:	4b0c      	ldr	r3, [pc, #48]	; (8006080 <Vector7C+0x40>)
 800604e:	685b      	ldr	r3, [r3, #4]
 8006050:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8006054:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
 8006056:	4a0a      	ldr	r2, [pc, #40]	; (8006080 <Vector7C+0x40>)
 8006058:	9b01      	ldr	r3, [sp, #4]
 800605a:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[4].dma_func)
 800605c:	4b09      	ldr	r3, [pc, #36]	; (8006084 <Vector7C+0x44>)
 800605e:	6a1b      	ldr	r3, [r3, #32]
 8006060:	2b00      	cmp	r3, #0
 8006062:	d006      	beq.n	8006072 <Vector7C+0x32>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8006064:	4b07      	ldr	r3, [pc, #28]	; (8006084 <Vector7C+0x44>)
 8006066:	6a1b      	ldr	r3, [r3, #32]
 8006068:	4a06      	ldr	r2, [pc, #24]	; (8006084 <Vector7C+0x44>)
 800606a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800606c:	9901      	ldr	r1, [sp, #4]
 800606e:	4610      	mov	r0, r2
 8006070:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006072:	f7fa fcd5 	bl	8000a20 <_dbg_check_leave_isr>
 8006076:	f7fc fcd3 	bl	8002a20 <_port_irq_epilogue>
}
 800607a:	b003      	add	sp, #12
 800607c:	f85d fb04 	ldr.w	pc, [sp], #4
 8006080:	40026000 	.word	0x40026000
 8006084:	200023ac 	.word	0x200023ac
	...

08006090 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8006090:	b500      	push	{lr}
 8006092:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006094:	f7fb fbf4 	bl	8001880 <_stats_increase_irq>
 8006098:	f7fa fca2 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800609c:	4b0d      	ldr	r3, [pc, #52]	; (80060d4 <Vector80+0x44>)
 800609e:	685b      	ldr	r3, [r3, #4]
 80060a0:	099b      	lsrs	r3, r3, #6
 80060a2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80060a6:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
 80060a8:	4a0a      	ldr	r2, [pc, #40]	; (80060d4 <Vector80+0x44>)
 80060aa:	9b01      	ldr	r3, [sp, #4]
 80060ac:	019b      	lsls	r3, r3, #6
 80060ae:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[5].dma_func)
 80060b0:	4b09      	ldr	r3, [pc, #36]	; (80060d8 <Vector80+0x48>)
 80060b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80060b4:	2b00      	cmp	r3, #0
 80060b6:	d006      	beq.n	80060c6 <Vector80+0x36>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 80060b8:	4b07      	ldr	r3, [pc, #28]	; (80060d8 <Vector80+0x48>)
 80060ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80060bc:	4a06      	ldr	r2, [pc, #24]	; (80060d8 <Vector80+0x48>)
 80060be:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80060c0:	9901      	ldr	r1, [sp, #4]
 80060c2:	4610      	mov	r0, r2
 80060c4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80060c6:	f7fa fcab 	bl	8000a20 <_dbg_check_leave_isr>
 80060ca:	f7fc fca9 	bl	8002a20 <_port_irq_epilogue>
}
 80060ce:	b003      	add	sp, #12
 80060d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80060d4:	40026000 	.word	0x40026000
 80060d8:	200023ac 	.word	0x200023ac
 80060dc:	00000000 	.word	0x00000000

080060e0 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 80060e0:	b500      	push	{lr}
 80060e2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80060e4:	f7fb fbcc 	bl	8001880 <_stats_increase_irq>
 80060e8:	f7fa fc7a 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80060ec:	4b0d      	ldr	r3, [pc, #52]	; (8006124 <Vector84+0x44>)
 80060ee:	685b      	ldr	r3, [r3, #4]
 80060f0:	0c1b      	lsrs	r3, r3, #16
 80060f2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80060f6:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
 80060f8:	4a0a      	ldr	r2, [pc, #40]	; (8006124 <Vector84+0x44>)
 80060fa:	9b01      	ldr	r3, [sp, #4]
 80060fc:	041b      	lsls	r3, r3, #16
 80060fe:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[6].dma_func)
 8006100:	4b09      	ldr	r3, [pc, #36]	; (8006128 <Vector84+0x48>)
 8006102:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006104:	2b00      	cmp	r3, #0
 8006106:	d006      	beq.n	8006116 <Vector84+0x36>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8006108:	4b07      	ldr	r3, [pc, #28]	; (8006128 <Vector84+0x48>)
 800610a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800610c:	4a06      	ldr	r2, [pc, #24]	; (8006128 <Vector84+0x48>)
 800610e:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8006110:	9901      	ldr	r1, [sp, #4]
 8006112:	4610      	mov	r0, r2
 8006114:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006116:	f7fa fc83 	bl	8000a20 <_dbg_check_leave_isr>
 800611a:	f7fc fc81 	bl	8002a20 <_port_irq_epilogue>
}
 800611e:	b003      	add	sp, #12
 8006120:	f85d fb04 	ldr.w	pc, [sp], #4
 8006124:	40026000 	.word	0x40026000
 8006128:	200023ac 	.word	0x200023ac
 800612c:	00000000 	.word	0x00000000

08006130 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8006130:	b500      	push	{lr}
 8006132:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006134:	f7fb fba4 	bl	8001880 <_stats_increase_irq>
 8006138:	f7fa fc52 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800613c:	4b0d      	ldr	r3, [pc, #52]	; (8006174 <VectorFC+0x44>)
 800613e:	685b      	ldr	r3, [r3, #4]
 8006140:	0d9b      	lsrs	r3, r3, #22
 8006142:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8006146:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
 8006148:	4a0a      	ldr	r2, [pc, #40]	; (8006174 <VectorFC+0x44>)
 800614a:	9b01      	ldr	r3, [sp, #4]
 800614c:	059b      	lsls	r3, r3, #22
 800614e:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[7].dma_func)
 8006150:	4b09      	ldr	r3, [pc, #36]	; (8006178 <VectorFC+0x48>)
 8006152:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8006154:	2b00      	cmp	r3, #0
 8006156:	d006      	beq.n	8006166 <VectorFC+0x36>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 8006158:	4b07      	ldr	r3, [pc, #28]	; (8006178 <VectorFC+0x48>)
 800615a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800615c:	4a06      	ldr	r2, [pc, #24]	; (8006178 <VectorFC+0x48>)
 800615e:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8006160:	9901      	ldr	r1, [sp, #4]
 8006162:	4610      	mov	r0, r2
 8006164:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006166:	f7fa fc5b 	bl	8000a20 <_dbg_check_leave_isr>
 800616a:	f7fc fc59 	bl	8002a20 <_port_irq_epilogue>
}
 800616e:	b003      	add	sp, #12
 8006170:	f85d fb04 	ldr.w	pc, [sp], #4
 8006174:	40026000 	.word	0x40026000
 8006178:	200023ac 	.word	0x200023ac
 800617c:	00000000 	.word	0x00000000

08006180 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8006180:	b500      	push	{lr}
 8006182:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006184:	f7fb fb7c 	bl	8001880 <_stats_increase_irq>
 8006188:	f7fa fc2a 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800618c:	4b0c      	ldr	r3, [pc, #48]	; (80061c0 <Vector120+0x40>)
 800618e:	681b      	ldr	r3, [r3, #0]
 8006190:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8006194:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
 8006196:	4a0a      	ldr	r2, [pc, #40]	; (80061c0 <Vector120+0x40>)
 8006198:	9b01      	ldr	r3, [sp, #4]
 800619a:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[8].dma_func)
 800619c:	4b09      	ldr	r3, [pc, #36]	; (80061c4 <Vector120+0x44>)
 800619e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80061a0:	2b00      	cmp	r3, #0
 80061a2:	d006      	beq.n	80061b2 <Vector120+0x32>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 80061a4:	4b07      	ldr	r3, [pc, #28]	; (80061c4 <Vector120+0x44>)
 80061a6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80061a8:	4a06      	ldr	r2, [pc, #24]	; (80061c4 <Vector120+0x44>)
 80061aa:	6c52      	ldr	r2, [r2, #68]	; 0x44
 80061ac:	9901      	ldr	r1, [sp, #4]
 80061ae:	4610      	mov	r0, r2
 80061b0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80061b2:	f7fa fc35 	bl	8000a20 <_dbg_check_leave_isr>
 80061b6:	f7fc fc33 	bl	8002a20 <_port_irq_epilogue>
}
 80061ba:	b003      	add	sp, #12
 80061bc:	f85d fb04 	ldr.w	pc, [sp], #4
 80061c0:	40026400 	.word	0x40026400
 80061c4:	200023ac 	.word	0x200023ac
	...

080061d0 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 80061d0:	b500      	push	{lr}
 80061d2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80061d4:	f7fb fb54 	bl	8001880 <_stats_increase_irq>
 80061d8:	f7fa fc02 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80061dc:	4b0d      	ldr	r3, [pc, #52]	; (8006214 <Vector124+0x44>)
 80061de:	681b      	ldr	r3, [r3, #0]
 80061e0:	099b      	lsrs	r3, r3, #6
 80061e2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80061e6:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
 80061e8:	4a0a      	ldr	r2, [pc, #40]	; (8006214 <Vector124+0x44>)
 80061ea:	9b01      	ldr	r3, [sp, #4]
 80061ec:	019b      	lsls	r3, r3, #6
 80061ee:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[9].dma_func)
 80061f0:	4b09      	ldr	r3, [pc, #36]	; (8006218 <Vector124+0x48>)
 80061f2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80061f4:	2b00      	cmp	r3, #0
 80061f6:	d006      	beq.n	8006206 <Vector124+0x36>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 80061f8:	4b07      	ldr	r3, [pc, #28]	; (8006218 <Vector124+0x48>)
 80061fa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80061fc:	4a06      	ldr	r2, [pc, #24]	; (8006218 <Vector124+0x48>)
 80061fe:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8006200:	9901      	ldr	r1, [sp, #4]
 8006202:	4610      	mov	r0, r2
 8006204:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006206:	f7fa fc0b 	bl	8000a20 <_dbg_check_leave_isr>
 800620a:	f7fc fc09 	bl	8002a20 <_port_irq_epilogue>
}
 800620e:	b003      	add	sp, #12
 8006210:	f85d fb04 	ldr.w	pc, [sp], #4
 8006214:	40026400 	.word	0x40026400
 8006218:	200023ac 	.word	0x200023ac
 800621c:	00000000 	.word	0x00000000

08006220 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8006220:	b500      	push	{lr}
 8006222:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006224:	f7fb fb2c 	bl	8001880 <_stats_increase_irq>
 8006228:	f7fa fbda 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800622c:	4b0d      	ldr	r3, [pc, #52]	; (8006264 <Vector128+0x44>)
 800622e:	681b      	ldr	r3, [r3, #0]
 8006230:	0c1b      	lsrs	r3, r3, #16
 8006232:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8006236:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
 8006238:	4a0a      	ldr	r2, [pc, #40]	; (8006264 <Vector128+0x44>)
 800623a:	9b01      	ldr	r3, [sp, #4]
 800623c:	041b      	lsls	r3, r3, #16
 800623e:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[10].dma_func)
 8006240:	4b09      	ldr	r3, [pc, #36]	; (8006268 <Vector128+0x48>)
 8006242:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8006244:	2b00      	cmp	r3, #0
 8006246:	d006      	beq.n	8006256 <Vector128+0x36>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8006248:	4b07      	ldr	r3, [pc, #28]	; (8006268 <Vector128+0x48>)
 800624a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800624c:	4a06      	ldr	r2, [pc, #24]	; (8006268 <Vector128+0x48>)
 800624e:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8006250:	9901      	ldr	r1, [sp, #4]
 8006252:	4610      	mov	r0, r2
 8006254:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006256:	f7fa fbe3 	bl	8000a20 <_dbg_check_leave_isr>
 800625a:	f7fc fbe1 	bl	8002a20 <_port_irq_epilogue>
}
 800625e:	b003      	add	sp, #12
 8006260:	f85d fb04 	ldr.w	pc, [sp], #4
 8006264:	40026400 	.word	0x40026400
 8006268:	200023ac 	.word	0x200023ac
 800626c:	00000000 	.word	0x00000000

08006270 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8006270:	b500      	push	{lr}
 8006272:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006274:	f7fb fb04 	bl	8001880 <_stats_increase_irq>
 8006278:	f7fa fbb2 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800627c:	4b0d      	ldr	r3, [pc, #52]	; (80062b4 <Vector12C+0x44>)
 800627e:	681b      	ldr	r3, [r3, #0]
 8006280:	0d9b      	lsrs	r3, r3, #22
 8006282:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8006286:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
 8006288:	4a0a      	ldr	r2, [pc, #40]	; (80062b4 <Vector12C+0x44>)
 800628a:	9b01      	ldr	r3, [sp, #4]
 800628c:	059b      	lsls	r3, r3, #22
 800628e:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[11].dma_func)
 8006290:	4b09      	ldr	r3, [pc, #36]	; (80062b8 <Vector12C+0x48>)
 8006292:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8006294:	2b00      	cmp	r3, #0
 8006296:	d006      	beq.n	80062a6 <Vector12C+0x36>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8006298:	4b07      	ldr	r3, [pc, #28]	; (80062b8 <Vector12C+0x48>)
 800629a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800629c:	4a06      	ldr	r2, [pc, #24]	; (80062b8 <Vector12C+0x48>)
 800629e:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 80062a0:	9901      	ldr	r1, [sp, #4]
 80062a2:	4610      	mov	r0, r2
 80062a4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80062a6:	f7fa fbbb 	bl	8000a20 <_dbg_check_leave_isr>
 80062aa:	f7fc fbb9 	bl	8002a20 <_port_irq_epilogue>
}
 80062ae:	b003      	add	sp, #12
 80062b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80062b4:	40026400 	.word	0x40026400
 80062b8:	200023ac 	.word	0x200023ac
 80062bc:	00000000 	.word	0x00000000

080062c0 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 80062c0:	b500      	push	{lr}
 80062c2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80062c4:	f7fb fadc 	bl	8001880 <_stats_increase_irq>
 80062c8:	f7fa fb8a 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80062cc:	4b0c      	ldr	r3, [pc, #48]	; (8006300 <Vector130+0x40>)
 80062ce:	685b      	ldr	r3, [r3, #4]
 80062d0:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80062d4:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
 80062d6:	4a0a      	ldr	r2, [pc, #40]	; (8006300 <Vector130+0x40>)
 80062d8:	9b01      	ldr	r3, [sp, #4]
 80062da:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[12].dma_func)
 80062dc:	4b09      	ldr	r3, [pc, #36]	; (8006304 <Vector130+0x44>)
 80062de:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80062e0:	2b00      	cmp	r3, #0
 80062e2:	d006      	beq.n	80062f2 <Vector130+0x32>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 80062e4:	4b07      	ldr	r3, [pc, #28]	; (8006304 <Vector130+0x44>)
 80062e6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80062e8:	4a06      	ldr	r2, [pc, #24]	; (8006304 <Vector130+0x44>)
 80062ea:	6e52      	ldr	r2, [r2, #100]	; 0x64
 80062ec:	9901      	ldr	r1, [sp, #4]
 80062ee:	4610      	mov	r0, r2
 80062f0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80062f2:	f7fa fb95 	bl	8000a20 <_dbg_check_leave_isr>
 80062f6:	f7fc fb93 	bl	8002a20 <_port_irq_epilogue>
}
 80062fa:	b003      	add	sp, #12
 80062fc:	f85d fb04 	ldr.w	pc, [sp], #4
 8006300:	40026400 	.word	0x40026400
 8006304:	200023ac 	.word	0x200023ac
	...

08006310 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8006310:	b500      	push	{lr}
 8006312:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006314:	f7fb fab4 	bl	8001880 <_stats_increase_irq>
 8006318:	f7fa fb62 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800631c:	4b0d      	ldr	r3, [pc, #52]	; (8006354 <Vector150+0x44>)
 800631e:	685b      	ldr	r3, [r3, #4]
 8006320:	099b      	lsrs	r3, r3, #6
 8006322:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8006326:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
 8006328:	4a0a      	ldr	r2, [pc, #40]	; (8006354 <Vector150+0x44>)
 800632a:	9b01      	ldr	r3, [sp, #4]
 800632c:	019b      	lsls	r3, r3, #6
 800632e:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[13].dma_func)
 8006330:	4b09      	ldr	r3, [pc, #36]	; (8006358 <Vector150+0x48>)
 8006332:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8006334:	2b00      	cmp	r3, #0
 8006336:	d006      	beq.n	8006346 <Vector150+0x36>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8006338:	4b07      	ldr	r3, [pc, #28]	; (8006358 <Vector150+0x48>)
 800633a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800633c:	4a06      	ldr	r2, [pc, #24]	; (8006358 <Vector150+0x48>)
 800633e:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
 8006340:	9901      	ldr	r1, [sp, #4]
 8006342:	4610      	mov	r0, r2
 8006344:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006346:	f7fa fb6b 	bl	8000a20 <_dbg_check_leave_isr>
 800634a:	f7fc fb69 	bl	8002a20 <_port_irq_epilogue>
}
 800634e:	b003      	add	sp, #12
 8006350:	f85d fb04 	ldr.w	pc, [sp], #4
 8006354:	40026400 	.word	0x40026400
 8006358:	200023ac 	.word	0x200023ac
 800635c:	00000000 	.word	0x00000000

08006360 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8006360:	b500      	push	{lr}
 8006362:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006364:	f7fb fa8c 	bl	8001880 <_stats_increase_irq>
 8006368:	f7fa fb3a 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800636c:	4b0d      	ldr	r3, [pc, #52]	; (80063a4 <Vector154+0x44>)
 800636e:	685b      	ldr	r3, [r3, #4]
 8006370:	0c1b      	lsrs	r3, r3, #16
 8006372:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8006376:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
 8006378:	4a0a      	ldr	r2, [pc, #40]	; (80063a4 <Vector154+0x44>)
 800637a:	9b01      	ldr	r3, [sp, #4]
 800637c:	041b      	lsls	r3, r3, #16
 800637e:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[14].dma_func)
 8006380:	4b09      	ldr	r3, [pc, #36]	; (80063a8 <Vector154+0x48>)
 8006382:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8006384:	2b00      	cmp	r3, #0
 8006386:	d006      	beq.n	8006396 <Vector154+0x36>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8006388:	4b07      	ldr	r3, [pc, #28]	; (80063a8 <Vector154+0x48>)
 800638a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800638c:	4a06      	ldr	r2, [pc, #24]	; (80063a8 <Vector154+0x48>)
 800638e:	6f52      	ldr	r2, [r2, #116]	; 0x74
 8006390:	9901      	ldr	r1, [sp, #4]
 8006392:	4610      	mov	r0, r2
 8006394:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006396:	f7fa fb43 	bl	8000a20 <_dbg_check_leave_isr>
 800639a:	f7fc fb41 	bl	8002a20 <_port_irq_epilogue>
}
 800639e:	b003      	add	sp, #12
 80063a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80063a4:	40026400 	.word	0x40026400
 80063a8:	200023ac 	.word	0x200023ac
 80063ac:	00000000 	.word	0x00000000

080063b0 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 80063b0:	b500      	push	{lr}
 80063b2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80063b4:	f7fb fa64 	bl	8001880 <_stats_increase_irq>
 80063b8:	f7fa fb12 	bl	80009e0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80063bc:	4b0d      	ldr	r3, [pc, #52]	; (80063f4 <Vector158+0x44>)
 80063be:	685b      	ldr	r3, [r3, #4]
 80063c0:	0d9b      	lsrs	r3, r3, #22
 80063c2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80063c6:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
 80063c8:	4a0a      	ldr	r2, [pc, #40]	; (80063f4 <Vector158+0x44>)
 80063ca:	9b01      	ldr	r3, [sp, #4]
 80063cc:	059b      	lsls	r3, r3, #22
 80063ce:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[15].dma_func)
 80063d0:	4b09      	ldr	r3, [pc, #36]	; (80063f8 <Vector158+0x48>)
 80063d2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80063d4:	2b00      	cmp	r3, #0
 80063d6:	d006      	beq.n	80063e6 <Vector158+0x36>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 80063d8:	4b07      	ldr	r3, [pc, #28]	; (80063f8 <Vector158+0x48>)
 80063da:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80063dc:	4a06      	ldr	r2, [pc, #24]	; (80063f8 <Vector158+0x48>)
 80063de:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
 80063e0:	9901      	ldr	r1, [sp, #4]
 80063e2:	4610      	mov	r0, r2
 80063e4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80063e6:	f7fa fb1b 	bl	8000a20 <_dbg_check_leave_isr>
 80063ea:	f7fc fb19 	bl	8002a20 <_port_irq_epilogue>
}
 80063ee:	b003      	add	sp, #12
 80063f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80063f4:	40026400 	.word	0x40026400
 80063f8:	200023ac 	.word	0x200023ac
 80063fc:	00000000 	.word	0x00000000

08006400 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8006400:	b082      	sub	sp, #8
  unsigned i;

  dma_streams_mask = 0U;
 8006402:	4b16      	ldr	r3, [pc, #88]	; (800645c <dmaInit+0x5c>)
 8006404:	2200      	movs	r2, #0
 8006406:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8006408:	2300      	movs	r3, #0
 800640a:	9301      	str	r3, [sp, #4]
 800640c:	e011      	b.n	8006432 <dmaInit+0x32>
    _stm32_dma_streams[i].stream->CR = 0U;
 800640e:	4914      	ldr	r1, [pc, #80]	; (8006460 <dmaInit+0x60>)
 8006410:	9a01      	ldr	r2, [sp, #4]
 8006412:	4613      	mov	r3, r2
 8006414:	005b      	lsls	r3, r3, #1
 8006416:	4413      	add	r3, r2
 8006418:	009b      	lsls	r3, r3, #2
 800641a:	440b      	add	r3, r1
 800641c:	681b      	ldr	r3, [r3, #0]
 800641e:	2200      	movs	r2, #0
 8006420:	601a      	str	r2, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
 8006422:	4a10      	ldr	r2, [pc, #64]	; (8006464 <dmaInit+0x64>)
 8006424:	9b01      	ldr	r3, [sp, #4]
 8006426:	2100      	movs	r1, #0
 8006428:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 800642c:	9b01      	ldr	r3, [sp, #4]
 800642e:	3301      	adds	r3, #1
 8006430:	9301      	str	r3, [sp, #4]
 8006432:	9b01      	ldr	r3, [sp, #4]
 8006434:	2b0f      	cmp	r3, #15
 8006436:	d9ea      	bls.n	800640e <dmaInit+0xe>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8006438:	4b0b      	ldr	r3, [pc, #44]	; (8006468 <dmaInit+0x68>)
 800643a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800643e:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 8006440:	4b09      	ldr	r3, [pc, #36]	; (8006468 <dmaInit+0x68>)
 8006442:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006446:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 8006448:	4b08      	ldr	r3, [pc, #32]	; (800646c <dmaInit+0x6c>)
 800644a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800644e:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 8006450:	4b06      	ldr	r3, [pc, #24]	; (800646c <dmaInit+0x6c>)
 8006452:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006456:	60da      	str	r2, [r3, #12]
}
 8006458:	b002      	add	sp, #8
 800645a:	4770      	bx	lr
 800645c:	200023a8 	.word	0x200023a8
 8006460:	0800aad0 	.word	0x0800aad0
 8006464:	200023ac 	.word	0x200023ac
 8006468:	40026000 	.word	0x40026000
 800646c:	40026400 	.word	0x40026400

08006470 <port_lock.lto_priv.125>:
static inline void port_lock(void) {
 8006470:	b082      	sub	sp, #8
 8006472:	2320      	movs	r3, #32
 8006474:	9301      	str	r3, [sp, #4]
 8006476:	9b01      	ldr	r3, [sp, #4]
 8006478:	f383 8811 	msr	BASEPRI, r3
}
 800647c:	b002      	add	sp, #8
 800647e:	4770      	bx	lr

08006480 <port_unlock.lto_priv.95>:
static inline void port_unlock(void) {
 8006480:	b082      	sub	sp, #8
 8006482:	2300      	movs	r3, #0
 8006484:	9301      	str	r3, [sp, #4]
 8006486:	9b01      	ldr	r3, [sp, #4]
 8006488:	f383 8811 	msr	BASEPRI, r3
}
 800648c:	b002      	add	sp, #8
 800648e:	4770      	bx	lr

08006490 <port_lock_from_isr.lto_priv.188>:
static inline void port_lock_from_isr(void) {
 8006490:	b508      	push	{r3, lr}
  port_lock();
 8006492:	f7ff ffed 	bl	8006470 <port_lock.lto_priv.125>
}
 8006496:	bd08      	pop	{r3, pc}
	...

080064a0 <port_unlock_from_isr.lto_priv.175>:
static inline void port_unlock_from_isr(void) {
 80064a0:	b508      	push	{r3, lr}
  port_unlock();
 80064a2:	f7ff ffed 	bl	8006480 <port_unlock.lto_priv.95>
}
 80064a6:	bd08      	pop	{r3, pc}
	...

080064b0 <chSysLockFromISR.lto_priv.162>:
static inline void chSysLockFromISR(void) {
 80064b0:	b508      	push	{r3, lr}
  port_lock_from_isr();
 80064b2:	f7ff ffed 	bl	8006490 <port_lock_from_isr.lto_priv.188>
  _stats_start_measure_crit_isr();
 80064b6:	f7fb fa23 	bl	8001900 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 80064ba:	f7fa fa61 	bl	8000980 <_dbg_check_lock_from_isr>
}
 80064be:	bd08      	pop	{r3, pc}

080064c0 <chSysUnlockFromISR.lto_priv.152>:
static inline void chSysUnlockFromISR(void) {
 80064c0:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 80064c2:	f7fa fa75 	bl	80009b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80064c6:	f7fb fa23 	bl	8001910 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 80064ca:	f7ff ffe9 	bl	80064a0 <port_unlock_from_isr.lto_priv.175>
}
 80064ce:	bd08      	pop	{r3, pc}

080064d0 <osalSysLockFromISR.lto_priv.142>:
static inline void osalSysLockFromISR(void) {
 80064d0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80064d2:	f7ff ffed 	bl	80064b0 <chSysLockFromISR.lto_priv.162>
}
 80064d6:	bd08      	pop	{r3, pc}
	...

080064e0 <osalSysUnlockFromISR.lto_priv.134>:
static inline void osalSysUnlockFromISR(void) {
 80064e0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 80064e2:	f7ff ffed 	bl	80064c0 <chSysUnlockFromISR.lto_priv.152>
}
 80064e6:	bd08      	pop	{r3, pc}
	...

080064f0 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 80064f0:	b508      	push	{r3, lr}
  chSysTimerHandlerI();
 80064f2:	f7fa f9a5 	bl	8000840 <chSysTimerHandlerI>
}
 80064f6:	bd08      	pop	{r3, pc}
	...

08006500 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 8006500:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8006502:	f7fb f9bd 	bl	8001880 <_stats_increase_irq>
 8006506:	f7fa fa6b 	bl	80009e0 <_dbg_check_enter_isr>

  osalSysLockFromISR();
 800650a:	f7ff ffe1 	bl	80064d0 <osalSysLockFromISR.lto_priv.142>
  osalOsTimerHandlerI();
 800650e:	f7ff ffef 	bl	80064f0 <osalOsTimerHandlerI>
  osalSysUnlockFromISR();
 8006512:	f7ff ffe5 	bl	80064e0 <osalSysUnlockFromISR.lto_priv.134>

  OSAL_IRQ_EPILOGUE();
 8006516:	f7fa fa83 	bl	8000a20 <_dbg_check_leave_isr>
 800651a:	f7fc fa81 	bl	8002a20 <_port_irq_epilogue>
}
 800651e:	bd08      	pop	{r3, pc}

08006520 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8006520:	b508      	push	{r3, lr}
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 8006522:	4b07      	ldr	r3, [pc, #28]	; (8006540 <st_lld_init+0x20>)
 8006524:	f244 129f 	movw	r2, #16799	; 0x419f
 8006528:	605a      	str	r2, [r3, #4]
  SysTick->VAL = 0;
 800652a:	4b05      	ldr	r3, [pc, #20]	; (8006540 <st_lld_init+0x20>)
 800652c:	2200      	movs	r2, #0
 800652e:	609a      	str	r2, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 8006530:	4b03      	ldr	r3, [pc, #12]	; (8006540 <st_lld_init+0x20>)
 8006532:	2207      	movs	r2, #7
 8006534:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 8006536:	2108      	movs	r1, #8
 8006538:	200b      	movs	r0, #11
 800653a:	f7ff fbf1 	bl	8005d20 <nvicSetSystemHandlerPriority>
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 800653e:	bd08      	pop	{r3, pc}
 8006540:	e000e010 	.word	0xe000e010
	...

08006550 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8006550:	b082      	sub	sp, #8
 8006552:	9001      	str	r0, [sp, #4]
 8006554:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8006556:	9b00      	ldr	r3, [sp, #0]
 8006558:	685a      	ldr	r2, [r3, #4]
 800655a:	9b01      	ldr	r3, [sp, #4]
 800655c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800655e:	9b00      	ldr	r3, [sp, #0]
 8006560:	689a      	ldr	r2, [r3, #8]
 8006562:	9b01      	ldr	r3, [sp, #4]
 8006564:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8006566:	9b00      	ldr	r3, [sp, #0]
 8006568:	68da      	ldr	r2, [r3, #12]
 800656a:	9b01      	ldr	r3, [sp, #4]
 800656c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800656e:	9b00      	ldr	r3, [sp, #0]
 8006570:	691a      	ldr	r2, [r3, #16]
 8006572:	9b01      	ldr	r3, [sp, #4]
 8006574:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8006576:	9b00      	ldr	r3, [sp, #0]
 8006578:	695a      	ldr	r2, [r3, #20]
 800657a:	9b01      	ldr	r3, [sp, #4]
 800657c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800657e:	9b00      	ldr	r3, [sp, #0]
 8006580:	699a      	ldr	r2, [r3, #24]
 8006582:	9b01      	ldr	r3, [sp, #4]
 8006584:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8006586:	9b00      	ldr	r3, [sp, #0]
 8006588:	681a      	ldr	r2, [r3, #0]
 800658a:	9b01      	ldr	r3, [sp, #4]
 800658c:	601a      	str	r2, [r3, #0]
}
 800658e:	b002      	add	sp, #8
 8006590:	4770      	bx	lr
 8006592:	bf00      	nop
	...

080065a0 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 80065a0:	b500      	push	{lr}
 80065a2:	b083      	sub	sp, #12
 80065a4:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80065a6:	4b24      	ldr	r3, [pc, #144]	; (8006638 <_pal_lld_init+0x98>)
 80065a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80065aa:	4a23      	ldr	r2, [pc, #140]	; (8006638 <_pal_lld_init+0x98>)
 80065ac:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 80065b0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 80065b4:	6313      	str	r3, [r2, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 80065b6:	4b20      	ldr	r3, [pc, #128]	; (8006638 <_pal_lld_init+0x98>)
 80065b8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80065ba:	4a1f      	ldr	r2, [pc, #124]	; (8006638 <_pal_lld_init+0x98>)
 80065bc:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 80065c0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 80065c4:	6513      	str	r3, [r2, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 80065c6:	9b01      	ldr	r3, [sp, #4]
 80065c8:	4619      	mov	r1, r3
 80065ca:	481c      	ldr	r0, [pc, #112]	; (800663c <_pal_lld_init+0x9c>)
 80065cc:	f7ff ffc0 	bl	8006550 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 80065d0:	9b01      	ldr	r3, [sp, #4]
 80065d2:	331c      	adds	r3, #28
 80065d4:	4619      	mov	r1, r3
 80065d6:	481a      	ldr	r0, [pc, #104]	; (8006640 <_pal_lld_init+0xa0>)
 80065d8:	f7ff ffba 	bl	8006550 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 80065dc:	9b01      	ldr	r3, [sp, #4]
 80065de:	3338      	adds	r3, #56	; 0x38
 80065e0:	4619      	mov	r1, r3
 80065e2:	4818      	ldr	r0, [pc, #96]	; (8006644 <_pal_lld_init+0xa4>)
 80065e4:	f7ff ffb4 	bl	8006550 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 80065e8:	9b01      	ldr	r3, [sp, #4]
 80065ea:	3354      	adds	r3, #84	; 0x54
 80065ec:	4619      	mov	r1, r3
 80065ee:	4816      	ldr	r0, [pc, #88]	; (8006648 <_pal_lld_init+0xa8>)
 80065f0:	f7ff ffae 	bl	8006550 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 80065f4:	9b01      	ldr	r3, [sp, #4]
 80065f6:	3370      	adds	r3, #112	; 0x70
 80065f8:	4619      	mov	r1, r3
 80065fa:	4814      	ldr	r0, [pc, #80]	; (800664c <_pal_lld_init+0xac>)
 80065fc:	f7ff ffa8 	bl	8006550 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 8006600:	9b01      	ldr	r3, [sp, #4]
 8006602:	338c      	adds	r3, #140	; 0x8c
 8006604:	4619      	mov	r1, r3
 8006606:	4812      	ldr	r0, [pc, #72]	; (8006650 <_pal_lld_init+0xb0>)
 8006608:	f7ff ffa2 	bl	8006550 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
 800660c:	9b01      	ldr	r3, [sp, #4]
 800660e:	33a8      	adds	r3, #168	; 0xa8
 8006610:	4619      	mov	r1, r3
 8006612:	4810      	ldr	r0, [pc, #64]	; (8006654 <_pal_lld_init+0xb4>)
 8006614:	f7ff ff9c 	bl	8006550 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
 8006618:	9b01      	ldr	r3, [sp, #4]
 800661a:	33c4      	adds	r3, #196	; 0xc4
 800661c:	4619      	mov	r1, r3
 800661e:	480e      	ldr	r0, [pc, #56]	; (8006658 <_pal_lld_init+0xb8>)
 8006620:	f7ff ff96 	bl	8006550 <initgpio>
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
 8006624:	9b01      	ldr	r3, [sp, #4]
 8006626:	33e0      	adds	r3, #224	; 0xe0
 8006628:	4619      	mov	r1, r3
 800662a:	480c      	ldr	r0, [pc, #48]	; (800665c <_pal_lld_init+0xbc>)
 800662c:	f7ff ff90 	bl	8006550 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 8006630:	b003      	add	sp, #12
 8006632:	f85d fb04 	ldr.w	pc, [sp], #4
 8006636:	bf00      	nop
 8006638:	40023800 	.word	0x40023800
 800663c:	40020000 	.word	0x40020000
 8006640:	40020400 	.word	0x40020400
 8006644:	40020800 	.word	0x40020800
 8006648:	40020c00 	.word	0x40020c00
 800664c:	40021000 	.word	0x40021000
 8006650:	40021400 	.word	0x40021400
 8006654:	40021800 	.word	0x40021800
 8006658:	40021c00 	.word	0x40021c00
 800665c:	40022000 	.word	0x40022000

08006660 <port_lock.lto_priv.126>:
static inline void port_lock(void) {
 8006660:	b082      	sub	sp, #8
 8006662:	2320      	movs	r3, #32
 8006664:	9301      	str	r3, [sp, #4]
 8006666:	9b01      	ldr	r3, [sp, #4]
 8006668:	f383 8811 	msr	BASEPRI, r3
}
 800666c:	b002      	add	sp, #8
 800666e:	4770      	bx	lr

08006670 <port_unlock.lto_priv.96>:
static inline void port_unlock(void) {
 8006670:	b082      	sub	sp, #8
 8006672:	2300      	movs	r3, #0
 8006674:	9301      	str	r3, [sp, #4]
 8006676:	9b01      	ldr	r3, [sp, #4]
 8006678:	f383 8811 	msr	BASEPRI, r3
}
 800667c:	b002      	add	sp, #8
 800667e:	4770      	bx	lr

08006680 <port_lock_from_isr.lto_priv.189>:
static inline void port_lock_from_isr(void) {
 8006680:	b508      	push	{r3, lr}
  port_lock();
 8006682:	f7ff ffed 	bl	8006660 <port_lock.lto_priv.126>
}
 8006686:	bd08      	pop	{r3, pc}
	...

08006690 <port_unlock_from_isr.lto_priv.176>:
static inline void port_unlock_from_isr(void) {
 8006690:	b508      	push	{r3, lr}
  port_unlock();
 8006692:	f7ff ffed 	bl	8006670 <port_unlock.lto_priv.96>
}
 8006696:	bd08      	pop	{r3, pc}
	...

080066a0 <chSysLockFromISR.lto_priv.163>:
static inline void chSysLockFromISR(void) {
 80066a0:	b508      	push	{r3, lr}
  port_lock_from_isr();
 80066a2:	f7ff ffed 	bl	8006680 <port_lock_from_isr.lto_priv.189>
  _stats_start_measure_crit_isr();
 80066a6:	f7fb f92b 	bl	8001900 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 80066aa:	f7fa f969 	bl	8000980 <_dbg_check_lock_from_isr>
}
 80066ae:	bd08      	pop	{r3, pc}

080066b0 <chSysUnlockFromISR.lto_priv.153>:
static inline void chSysUnlockFromISR(void) {
 80066b0:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 80066b2:	f7fa f97d 	bl	80009b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80066b6:	f7fb f92b 	bl	8001910 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 80066ba:	f7ff ffe9 	bl	8006690 <port_unlock_from_isr.lto_priv.176>
}
 80066be:	bd08      	pop	{r3, pc}

080066c0 <osalSysLockFromISR.lto_priv.143>:
static inline void osalSysLockFromISR(void) {
 80066c0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80066c2:	f7ff ffed 	bl	80066a0 <chSysLockFromISR.lto_priv.163>
}
 80066c6:	bd08      	pop	{r3, pc}
	...

080066d0 <osalSysUnlockFromISR.lto_priv.135>:
static inline void osalSysUnlockFromISR(void) {
 80066d0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 80066d2:	f7ff ffed 	bl	80066b0 <chSysUnlockFromISR.lto_priv.153>
}
 80066d6:	bd08      	pop	{r3, pc}
	...

080066e0 <osalThreadResumeI.lto_priv.211>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 80066e0:	b500      	push	{lr}
 80066e2:	b083      	sub	sp, #12
 80066e4:	9001      	str	r0, [sp, #4]
 80066e6:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 80066e8:	9900      	ldr	r1, [sp, #0]
 80066ea:	9801      	ldr	r0, [sp, #4]
 80066ec:	f7fa ff50 	bl	8001590 <chThdResumeI>
}
 80066f0:	b003      	add	sp, #12
 80066f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80066f6:	bf00      	nop
	...

08006700 <i2c_lld_serve_event_interrupt>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
 8006700:	b500      	push	{lr}
 8006702:	b087      	sub	sp, #28
 8006704:	9001      	str	r0, [sp, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 8006706:	9b01      	ldr	r3, [sp, #4]
 8006708:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800670a:	9305      	str	r3, [sp, #20]
  uint32_t regSR2 = dp->SR2;
 800670c:	9b05      	ldr	r3, [sp, #20]
 800670e:	699b      	ldr	r3, [r3, #24]
 8006710:	9304      	str	r3, [sp, #16]
  uint32_t event = dp->SR1;
 8006712:	9b05      	ldr	r3, [sp, #20]
 8006714:	695b      	ldr	r3, [r3, #20]
 8006716:	9303      	str	r3, [sp, #12]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8006718:	9b04      	ldr	r3, [sp, #16]
 800671a:	041a      	lsls	r2, r3, #16
 800671c:	9b03      	ldr	r3, [sp, #12]
 800671e:	4313      	orrs	r3, r2
 8006720:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8006724:	4a53      	ldr	r2, [pc, #332]	; (8006874 <i2c_lld_serve_event_interrupt+0x174>)
 8006726:	4293      	cmp	r3, r2
 8006728:	d031      	beq.n	800678e <i2c_lld_serve_event_interrupt+0x8e>
 800672a:	4a52      	ldr	r2, [pc, #328]	; (8006874 <i2c_lld_serve_event_interrupt+0x174>)
 800672c:	4293      	cmp	r3, r2
 800672e:	d806      	bhi.n	800673e <i2c_lld_serve_event_interrupt+0x3e>
 8006730:	4a51      	ldr	r2, [pc, #324]	; (8006878 <i2c_lld_serve_event_interrupt+0x178>)
 8006732:	4293      	cmp	r3, r2
 8006734:	d00a      	beq.n	800674c <i2c_lld_serve_event_interrupt+0x4c>
 8006736:	4a51      	ldr	r2, [pc, #324]	; (800687c <i2c_lld_serve_event_interrupt+0x17c>)
 8006738:	4293      	cmp	r3, r2
 800673a:	d030      	beq.n	800679e <i2c_lld_serve_event_interrupt+0x9e>
 800673c:	e08f      	b.n	800685e <i2c_lld_serve_event_interrupt+0x15e>
 800673e:	4a50      	ldr	r2, [pc, #320]	; (8006880 <i2c_lld_serve_event_interrupt+0x180>)
 8006740:	4293      	cmp	r3, r2
 8006742:	d04f      	beq.n	80067e4 <i2c_lld_serve_event_interrupt+0xe4>
 8006744:	4a4f      	ldr	r2, [pc, #316]	; (8006884 <i2c_lld_serve_event_interrupt+0x184>)
 8006746:	4293      	cmp	r3, r2
 8006748:	d05d      	beq.n	8006806 <i2c_lld_serve_event_interrupt+0x106>
 800674a:	e088      	b.n	800685e <i2c_lld_serve_event_interrupt+0x15e>
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 800674c:	9b01      	ldr	r3, [sp, #4]
 800674e:	8c1b      	ldrh	r3, [r3, #32]
 8006750:	0a1b      	lsrs	r3, r3, #8
 8006752:	b29b      	uxth	r3, r3
 8006754:	2b00      	cmp	r3, #0
 8006756:	d014      	beq.n	8006782 <i2c_lld_serve_event_interrupt+0x82>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 8006758:	9b01      	ldr	r3, [sp, #4]
 800675a:	8c1b      	ldrh	r3, [r3, #32]
 800675c:	0a1b      	lsrs	r3, r3, #8
 800675e:	b29b      	uxth	r3, r3
 8006760:	f003 0306 	and.w	r3, r3, #6
 8006764:	b29a      	uxth	r2, r3
 8006766:	9b01      	ldr	r3, [sp, #4]
 8006768:	8c1b      	ldrh	r3, [r3, #32]
 800676a:	f003 0301 	and.w	r3, r3, #1
 800676e:	b29b      	uxth	r3, r3
 8006770:	4313      	orrs	r3, r2
 8006772:	b29b      	uxth	r3, r3
 8006774:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8006778:	b29b      	uxth	r3, r3
 800677a:	461a      	mov	r2, r3
 800677c:	9b05      	ldr	r3, [sp, #20]
 800677e:	611a      	str	r2, [r3, #16]
    } else {
      dp->DR = i2cp->addr;
 8006780:	e06d      	b.n	800685e <i2c_lld_serve_event_interrupt+0x15e>
 8006782:	9b01      	ldr	r3, [sp, #4]
 8006784:	8c1b      	ldrh	r3, [r3, #32]
 8006786:	461a      	mov	r2, r3
 8006788:	9b05      	ldr	r3, [sp, #20]
 800678a:	611a      	str	r2, [r3, #16]
 800678c:	e067      	b.n	800685e <i2c_lld_serve_event_interrupt+0x15e>
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 800678e:	9b01      	ldr	r3, [sp, #4]
 8006790:	8c1b      	ldrh	r3, [r3, #32]
 8006792:	085b      	lsrs	r3, r3, #1
 8006794:	b29b      	uxth	r3, r3
 8006796:	b2da      	uxtb	r2, r3
 8006798:	9b05      	ldr	r3, [sp, #20]
 800679a:	611a      	str	r2, [r3, #16]
 800679c:	e05f      	b.n	800685e <i2c_lld_serve_event_interrupt+0x15e>
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800679e:	9b05      	ldr	r3, [sp, #20]
 80067a0:	685b      	ldr	r3, [r3, #4]
 80067a2:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 80067a6:	9b05      	ldr	r3, [sp, #20]
 80067a8:	605a      	str	r2, [r3, #4]
    dmaStreamEnable(i2cp->dmarx);
 80067aa:	9b01      	ldr	r3, [sp, #4]
 80067ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80067ae:	681b      	ldr	r3, [r3, #0]
 80067b0:	681a      	ldr	r2, [r3, #0]
 80067b2:	9b01      	ldr	r3, [sp, #4]
 80067b4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80067b6:	681b      	ldr	r3, [r3, #0]
 80067b8:	f042 0201 	orr.w	r2, r2, #1
 80067bc:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 80067be:	9b05      	ldr	r3, [sp, #20]
 80067c0:	685b      	ldr	r3, [r3, #4]
 80067c2:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
 80067c6:	9b05      	ldr	r3, [sp, #20]
 80067c8:	605a      	str	r2, [r3, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 80067ca:	9b01      	ldr	r3, [sp, #4]
 80067cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80067ce:	681b      	ldr	r3, [r3, #0]
 80067d0:	685b      	ldr	r3, [r3, #4]
 80067d2:	2b01      	cmp	r3, #1
 80067d4:	d842      	bhi.n	800685c <i2c_lld_serve_event_interrupt+0x15c>
      dp->CR1 &= ~I2C_CR1_ACK;
 80067d6:	9b05      	ldr	r3, [sp, #20]
 80067d8:	681b      	ldr	r3, [r3, #0]
 80067da:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 80067de:	9b05      	ldr	r3, [sp, #20]
 80067e0:	601a      	str	r2, [r3, #0]
 80067e2:	e03c      	b.n	800685e <i2c_lld_serve_event_interrupt+0x15e>
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80067e4:	9b05      	ldr	r3, [sp, #20]
 80067e6:	685b      	ldr	r3, [r3, #4]
 80067e8:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 80067ec:	9b05      	ldr	r3, [sp, #20]
 80067ee:	605a      	str	r2, [r3, #4]
    dmaStreamEnable(i2cp->dmatx);
 80067f0:	9b01      	ldr	r3, [sp, #4]
 80067f2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80067f4:	681b      	ldr	r3, [r3, #0]
 80067f6:	681a      	ldr	r2, [r3, #0]
 80067f8:	9b01      	ldr	r3, [sp, #4]
 80067fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80067fc:	681b      	ldr	r3, [r3, #0]
 80067fe:	f042 0201 	orr.w	r2, r2, #1
 8006802:	601a      	str	r2, [r3, #0]
 8006804:	e02b      	b.n	800685e <i2c_lld_serve_event_interrupt+0x15e>
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 8006806:	9b01      	ldr	r3, [sp, #4]
 8006808:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800680a:	681b      	ldr	r3, [r3, #0]
 800680c:	685b      	ldr	r3, [r3, #4]
 800680e:	2b00      	cmp	r3, #0
 8006810:	d00d      	beq.n	800682e <i2c_lld_serve_event_interrupt+0x12e>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8006812:	9b01      	ldr	r3, [sp, #4]
 8006814:	8c1b      	ldrh	r3, [r3, #32]
 8006816:	f043 0301 	orr.w	r3, r3, #1
 800681a:	b29a      	uxth	r2, r3
 800681c:	9b01      	ldr	r3, [sp, #4]
 800681e:	841a      	strh	r2, [r3, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8006820:	9b05      	ldr	r3, [sp, #20]
 8006822:	681b      	ldr	r3, [r3, #0]
 8006824:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
 8006828:	9b05      	ldr	r3, [sp, #20]
 800682a:	601a      	str	r2, [r3, #0]
 800682c:	e01e      	b.n	800686c <i2c_lld_serve_event_interrupt+0x16c>
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800682e:	9b05      	ldr	r3, [sp, #20]
 8006830:	685b      	ldr	r3, [r3, #4]
 8006832:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 8006836:	9b05      	ldr	r3, [sp, #20]
 8006838:	605a      	str	r2, [r3, #4]
    dp->CR1 |= I2C_CR1_STOP;
 800683a:	9b05      	ldr	r3, [sp, #20]
 800683c:	681b      	ldr	r3, [r3, #0]
 800683e:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8006842:	9b05      	ldr	r3, [sp, #20]
 8006844:	601a      	str	r2, [r3, #0]
    _i2c_wakeup_isr(i2cp);
 8006846:	f7ff ff3b 	bl	80066c0 <osalSysLockFromISR.lto_priv.143>
 800684a:	9b01      	ldr	r3, [sp, #4]
 800684c:	331c      	adds	r3, #28
 800684e:	2100      	movs	r1, #0
 8006850:	4618      	mov	r0, r3
 8006852:	f7ff ff45 	bl	80066e0 <osalThreadResumeI.lto_priv.211>
 8006856:	f7ff ff3b 	bl	80066d0 <osalSysUnlockFromISR.lto_priv.135>
 800685a:	e000      	b.n	800685e <i2c_lld_serve_event_interrupt+0x15e>
      dp->CR1 &= ~I2C_CR1_ACK;
 800685c:	bf00      	nop
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 800685e:	9b03      	ldr	r3, [sp, #12]
 8006860:	f003 030a 	and.w	r3, r3, #10
 8006864:	2b00      	cmp	r3, #0
 8006866:	d001      	beq.n	800686c <i2c_lld_serve_event_interrupt+0x16c>
    (void)dp->SR2;
 8006868:	9b05      	ldr	r3, [sp, #20]
 800686a:	699b      	ldr	r3, [r3, #24]
}
 800686c:	b007      	add	sp, #28
 800686e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006872:	bf00      	nop
 8006874:	00030008 	.word	0x00030008
 8006878:	00030001 	.word	0x00030001
 800687c:	00030002 	.word	0x00030002
 8006880:	00070082 	.word	0x00070082
 8006884:	00070084 	.word	0x00070084
	...

08006890 <i2c_lld_serve_error_interrupt>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in]  sr       content of the SR1 register to be decoded
 *
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {
 8006890:	b500      	push	{lr}
 8006892:	b083      	sub	sp, #12
 8006894:	9001      	str	r0, [sp, #4]
 8006896:	460b      	mov	r3, r1
 8006898:	f8ad 3002 	strh.w	r3, [sp, #2]

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800689c:	9b01      	ldr	r3, [sp, #4]
 800689e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80068a0:	681b      	ldr	r3, [r3, #0]
 80068a2:	681a      	ldr	r2, [r3, #0]
 80068a4:	9b01      	ldr	r3, [sp, #4]
 80068a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80068a8:	681b      	ldr	r3, [r3, #0]
 80068aa:	f022 021f 	bic.w	r2, r2, #31
 80068ae:	601a      	str	r2, [r3, #0]
 80068b0:	9b01      	ldr	r3, [sp, #4]
 80068b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80068b4:	681b      	ldr	r3, [r3, #0]
 80068b6:	681b      	ldr	r3, [r3, #0]
 80068b8:	f003 0301 	and.w	r3, r3, #1
 80068bc:	2b00      	cmp	r3, #0
 80068be:	d1f7      	bne.n	80068b0 <i2c_lld_serve_error_interrupt+0x20>
 80068c0:	9b01      	ldr	r3, [sp, #4]
 80068c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80068c4:	7a1b      	ldrb	r3, [r3, #8]
 80068c6:	4619      	mov	r1, r3
 80068c8:	9b01      	ldr	r3, [sp, #4]
 80068ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80068cc:	685b      	ldr	r3, [r3, #4]
 80068ce:	223d      	movs	r2, #61	; 0x3d
 80068d0:	408a      	lsls	r2, r1
 80068d2:	601a      	str	r2, [r3, #0]
  dmaStreamDisable(i2cp->dmarx);
 80068d4:	9b01      	ldr	r3, [sp, #4]
 80068d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80068d8:	681b      	ldr	r3, [r3, #0]
 80068da:	681a      	ldr	r2, [r3, #0]
 80068dc:	9b01      	ldr	r3, [sp, #4]
 80068de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80068e0:	681b      	ldr	r3, [r3, #0]
 80068e2:	f022 021f 	bic.w	r2, r2, #31
 80068e6:	601a      	str	r2, [r3, #0]
 80068e8:	9b01      	ldr	r3, [sp, #4]
 80068ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80068ec:	681b      	ldr	r3, [r3, #0]
 80068ee:	681b      	ldr	r3, [r3, #0]
 80068f0:	f003 0301 	and.w	r3, r3, #1
 80068f4:	2b00      	cmp	r3, #0
 80068f6:	d1f7      	bne.n	80068e8 <i2c_lld_serve_error_interrupt+0x58>
 80068f8:	9b01      	ldr	r3, [sp, #4]
 80068fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80068fc:	7a1b      	ldrb	r3, [r3, #8]
 80068fe:	4619      	mov	r1, r3
 8006900:	9b01      	ldr	r3, [sp, #4]
 8006902:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006904:	685b      	ldr	r3, [r3, #4]
 8006906:	223d      	movs	r2, #61	; 0x3d
 8006908:	408a      	lsls	r2, r1
 800690a:	601a      	str	r2, [r3, #0]

  i2cp->errors = I2C_NO_ERROR;
 800690c:	9b01      	ldr	r3, [sp, #4]
 800690e:	2200      	movs	r2, #0
 8006910:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8006912:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006916:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800691a:	2b00      	cmp	r3, #0
 800691c:	d005      	beq.n	800692a <i2c_lld_serve_error_interrupt+0x9a>
    i2cp->errors |= I2C_BUS_ERROR;
 800691e:	9b01      	ldr	r3, [sp, #4]
 8006920:	689b      	ldr	r3, [r3, #8]
 8006922:	f043 0201 	orr.w	r2, r3, #1
 8006926:	9b01      	ldr	r3, [sp, #4]
 8006928:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 800692a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800692e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8006932:	2b00      	cmp	r3, #0
 8006934:	d005      	beq.n	8006942 <i2c_lld_serve_error_interrupt+0xb2>
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8006936:	9b01      	ldr	r3, [sp, #4]
 8006938:	689b      	ldr	r3, [r3, #8]
 800693a:	f043 0202 	orr.w	r2, r3, #2
 800693e:	9b01      	ldr	r3, [sp, #4]
 8006940:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8006942:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006946:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800694a:	2b00      	cmp	r3, #0
 800694c:	d015      	beq.n	800697a <i2c_lld_serve_error_interrupt+0xea>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 800694e:	9b01      	ldr	r3, [sp, #4]
 8006950:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006952:	685a      	ldr	r2, [r3, #4]
 8006954:	9b01      	ldr	r3, [sp, #4]
 8006956:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006958:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800695c:	605a      	str	r2, [r3, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 800695e:	9b01      	ldr	r3, [sp, #4]
 8006960:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006962:	681a      	ldr	r2, [r3, #0]
 8006964:	9b01      	ldr	r3, [sp, #4]
 8006966:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006968:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800696c:	601a      	str	r2, [r3, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 800696e:	9b01      	ldr	r3, [sp, #4]
 8006970:	689b      	ldr	r3, [r3, #8]
 8006972:	f043 0204 	orr.w	r2, r3, #4
 8006976:	9b01      	ldr	r3, [sp, #4]
 8006978:	609a      	str	r2, [r3, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 800697a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800697e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8006982:	2b00      	cmp	r3, #0
 8006984:	d005      	beq.n	8006992 <i2c_lld_serve_error_interrupt+0x102>
    i2cp->errors |= I2C_OVERRUN;
 8006986:	9b01      	ldr	r3, [sp, #4]
 8006988:	689b      	ldr	r3, [r3, #8]
 800698a:	f043 0208 	orr.w	r2, r3, #8
 800698e:	9b01      	ldr	r3, [sp, #4]
 8006990:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8006992:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006996:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800699a:	2b00      	cmp	r3, #0
 800699c:	d005      	beq.n	80069aa <i2c_lld_serve_error_interrupt+0x11a>
    i2cp->errors |= I2C_TIMEOUT;
 800699e:	9b01      	ldr	r3, [sp, #4]
 80069a0:	689b      	ldr	r3, [r3, #8]
 80069a2:	f043 0220 	orr.w	r2, r3, #32
 80069a6:	9b01      	ldr	r3, [sp, #4]
 80069a8:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 80069aa:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80069ae:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80069b2:	2b00      	cmp	r3, #0
 80069b4:	d005      	beq.n	80069c2 <i2c_lld_serve_error_interrupt+0x132>
    i2cp->errors |= I2C_PEC_ERROR;
 80069b6:	9b01      	ldr	r3, [sp, #4]
 80069b8:	689b      	ldr	r3, [r3, #8]
 80069ba:	f043 0210 	orr.w	r2, r3, #16
 80069be:	9b01      	ldr	r3, [sp, #4]
 80069c0:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 80069c2:	f9bd 3002 	ldrsh.w	r3, [sp, #2]
 80069c6:	2b00      	cmp	r3, #0
 80069c8:	da05      	bge.n	80069d6 <i2c_lld_serve_error_interrupt+0x146>
    i2cp->errors |= I2C_SMB_ALERT;
 80069ca:	9b01      	ldr	r3, [sp, #4]
 80069cc:	689b      	ldr	r3, [r3, #8]
 80069ce:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 80069d2:	9b01      	ldr	r3, [sp, #4]
 80069d4:	609a      	str	r2, [r3, #8]

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 80069d6:	9b01      	ldr	r3, [sp, #4]
 80069d8:	689b      	ldr	r3, [r3, #8]
 80069da:	2b00      	cmp	r3, #0
 80069dc:	d00a      	beq.n	80069f4 <i2c_lld_serve_error_interrupt+0x164>
    _i2c_wakeup_error_isr(i2cp);
 80069de:	f7ff fe6f 	bl	80066c0 <osalSysLockFromISR.lto_priv.143>
 80069e2:	9b01      	ldr	r3, [sp, #4]
 80069e4:	331c      	adds	r3, #28
 80069e6:	f06f 0101 	mvn.w	r1, #1
 80069ea:	4618      	mov	r0, r3
 80069ec:	f7ff fe78 	bl	80066e0 <osalThreadResumeI.lto_priv.211>
 80069f0:	f7ff fe6e 	bl	80066d0 <osalSysUnlockFromISR.lto_priv.135>
}
 80069f4:	b003      	add	sp, #12
 80069f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80069fa:	bf00      	nop
 80069fc:	0000      	movs	r0, r0
	...

08006a00 <VectorBC>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 8006a00:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8006a02:	f7fa ff3d 	bl	8001880 <_stats_increase_irq>
 8006a06:	f7f9 ffeb 	bl	80009e0 <_dbg_check_enter_isr>

  i2c_lld_serve_event_interrupt(&I2CD1);
 8006a0a:	4804      	ldr	r0, [pc, #16]	; (8006a1c <VectorBC+0x1c>)
 8006a0c:	f7ff fe78 	bl	8006700 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
 8006a10:	f7fa f806 	bl	8000a20 <_dbg_check_leave_isr>
 8006a14:	f7fc f804 	bl	8002a20 <_port_irq_epilogue>
}
 8006a18:	bd08      	pop	{r3, pc}
 8006a1a:	bf00      	nop
 8006a1c:	2000242c 	.word	0x2000242c

08006a20 <VectorC0>:

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 8006a20:	b500      	push	{lr}
 8006a22:	b083      	sub	sp, #12
  uint16_t sr = I2CD1.i2c->SR1;
 8006a24:	4b0e      	ldr	r3, [pc, #56]	; (8006a60 <VectorC0+0x40>)
 8006a26:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006a28:	695b      	ldr	r3, [r3, #20]
 8006a2a:	f8ad 3006 	strh.w	r3, [sp, #6]

  OSAL_IRQ_PROLOGUE();
 8006a2e:	f7fa ff27 	bl	8001880 <_stats_increase_irq>
 8006a32:	f7f9 ffd5 	bl	80009e0 <_dbg_check_enter_isr>

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8006a36:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8006a3a:	f403 435f 	and.w	r3, r3, #57088	; 0xdf00
 8006a3e:	43da      	mvns	r2, r3
 8006a40:	4b07      	ldr	r3, [pc, #28]	; (8006a60 <VectorC0+0x40>)
 8006a42:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006a44:	615a      	str	r2, [r3, #20]
  i2c_lld_serve_error_interrupt(&I2CD1, sr);
 8006a46:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8006a4a:	4619      	mov	r1, r3
 8006a4c:	4804      	ldr	r0, [pc, #16]	; (8006a60 <VectorC0+0x40>)
 8006a4e:	f7ff ff1f 	bl	8006890 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
 8006a52:	f7f9 ffe5 	bl	8000a20 <_dbg_check_leave_isr>
 8006a56:	f7fb ffe3 	bl	8002a20 <_port_irq_epilogue>
}
 8006a5a:	b003      	add	sp, #12
 8006a5c:	f85d fb04 	ldr.w	pc, [sp], #4
 8006a60:	2000242c 	.word	0x2000242c
	...

08006a70 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 8006a70:	b508      	push	{r3, lr}

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
 8006a72:	4808      	ldr	r0, [pc, #32]	; (8006a94 <i2c_lld_init+0x24>)
 8006a74:	f7fc fe3c 	bl	80036f0 <i2cObjectInit>
  I2CD1.thread = NULL;
 8006a78:	4b06      	ldr	r3, [pc, #24]	; (8006a94 <i2c_lld_init+0x24>)
 8006a7a:	2200      	movs	r2, #0
 8006a7c:	61da      	str	r2, [r3, #28]
  I2CD1.i2c    = I2C1;
 8006a7e:	4b05      	ldr	r3, [pc, #20]	; (8006a94 <i2c_lld_init+0x24>)
 8006a80:	4a05      	ldr	r2, [pc, #20]	; (8006a98 <i2c_lld_init+0x28>)
 8006a82:	635a      	str	r2, [r3, #52]	; 0x34
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8006a84:	4b03      	ldr	r3, [pc, #12]	; (8006a94 <i2c_lld_init+0x24>)
 8006a86:	4a05      	ldr	r2, [pc, #20]	; (8006a9c <i2c_lld_init+0x2c>)
 8006a88:	62da      	str	r2, [r3, #44]	; 0x2c
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8006a8a:	4b02      	ldr	r3, [pc, #8]	; (8006a94 <i2c_lld_init+0x24>)
 8006a8c:	4a04      	ldr	r2, [pc, #16]	; (8006aa0 <i2c_lld_init+0x30>)
 8006a8e:	631a      	str	r2, [r3, #48]	; 0x30
  I2CD3.thread = NULL;
  I2CD3.i2c    = I2C3;
  I2CD3.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C3_RX_DMA_STREAM);
  I2CD3.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C3_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C3 */
}
 8006a90:	bd08      	pop	{r3, pc}
 8006a92:	bf00      	nop
 8006a94:	2000242c 	.word	0x2000242c
 8006a98:	40005400 	.word	0x40005400
 8006a9c:	0800aad0 	.word	0x0800aad0
 8006aa0:	0800ab24 	.word	0x0800ab24
	...

08006ab0 <port_lock.lto_priv.127>:
static inline void port_lock(void) {
 8006ab0:	b082      	sub	sp, #8
 8006ab2:	2320      	movs	r3, #32
 8006ab4:	9301      	str	r3, [sp, #4]
 8006ab6:	9b01      	ldr	r3, [sp, #4]
 8006ab8:	f383 8811 	msr	BASEPRI, r3
}
 8006abc:	b002      	add	sp, #8
 8006abe:	4770      	bx	lr

08006ac0 <port_unlock.lto_priv.97>:
static inline void port_unlock(void) {
 8006ac0:	b082      	sub	sp, #8
 8006ac2:	2300      	movs	r3, #0
 8006ac4:	9301      	str	r3, [sp, #4]
 8006ac6:	9b01      	ldr	r3, [sp, #4]
 8006ac8:	f383 8811 	msr	BASEPRI, r3
}
 8006acc:	b002      	add	sp, #8
 8006ace:	4770      	bx	lr

08006ad0 <port_lock_from_isr.lto_priv.190>:
static inline void port_lock_from_isr(void) {
 8006ad0:	b508      	push	{r3, lr}
  port_lock();
 8006ad2:	f7ff ffed 	bl	8006ab0 <port_lock.lto_priv.127>
}
 8006ad6:	bd08      	pop	{r3, pc}
	...

08006ae0 <port_unlock_from_isr.lto_priv.177>:
static inline void port_unlock_from_isr(void) {
 8006ae0:	b508      	push	{r3, lr}
  port_unlock();
 8006ae2:	f7ff ffed 	bl	8006ac0 <port_unlock.lto_priv.97>
}
 8006ae6:	bd08      	pop	{r3, pc}
	...

08006af0 <chSysLock.lto_priv.69>:
static inline void chSysLock(void) {
 8006af0:	b508      	push	{r3, lr}
  port_lock();
 8006af2:	f7ff ffdd 	bl	8006ab0 <port_lock.lto_priv.127>
  _stats_start_measure_crit_thd();
 8006af6:	f7fa fef3 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8006afa:	f7f9 ff11 	bl	8000920 <_dbg_check_lock>
}
 8006afe:	bd08      	pop	{r3, pc}

08006b00 <chSysUnlock.lto_priv.28>:
static inline void chSysUnlock(void) {
 8006b00:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8006b02:	f7f9 ff25 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8006b06:	f7fa fef3 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006b0a:	4b09      	ldr	r3, [pc, #36]	; (8006b30 <chSysUnlock.lto_priv.28+0x30>)
 8006b0c:	681b      	ldr	r3, [r3, #0]
 8006b0e:	4a08      	ldr	r2, [pc, #32]	; (8006b30 <chSysUnlock.lto_priv.28+0x30>)
 8006b10:	4293      	cmp	r3, r2
 8006b12:	d00a      	beq.n	8006b2a <chSysUnlock.lto_priv.28+0x2a>
 8006b14:	4b06      	ldr	r3, [pc, #24]	; (8006b30 <chSysUnlock.lto_priv.28+0x30>)
 8006b16:	699b      	ldr	r3, [r3, #24]
 8006b18:	689a      	ldr	r2, [r3, #8]
 8006b1a:	4b05      	ldr	r3, [pc, #20]	; (8006b30 <chSysUnlock.lto_priv.28+0x30>)
 8006b1c:	681b      	ldr	r3, [r3, #0]
 8006b1e:	689b      	ldr	r3, [r3, #8]
 8006b20:	429a      	cmp	r2, r3
 8006b22:	d202      	bcs.n	8006b2a <chSysUnlock.lto_priv.28+0x2a>
 8006b24:	4803      	ldr	r0, [pc, #12]	; (8006b34 <chSysUnlock.lto_priv.28+0x34>)
 8006b26:	f7f9 fe73 	bl	8000810 <chSysHalt>
  port_unlock();
 8006b2a:	f7ff ffc9 	bl	8006ac0 <port_unlock.lto_priv.97>
}
 8006b2e:	bd08      	pop	{r3, pc}
 8006b30:	20002128 	.word	0x20002128
 8006b34:	0800ac20 	.word	0x0800ac20
	...

08006b40 <chSysLockFromISR.lto_priv.164>:
static inline void chSysLockFromISR(void) {
 8006b40:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8006b42:	f7ff ffc5 	bl	8006ad0 <port_lock_from_isr.lto_priv.190>
  _stats_start_measure_crit_isr();
 8006b46:	f7fa fedb 	bl	8001900 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8006b4a:	f7f9 ff19 	bl	8000980 <_dbg_check_lock_from_isr>
}
 8006b4e:	bd08      	pop	{r3, pc}

08006b50 <chSysUnlockFromISR.lto_priv.154>:
static inline void chSysUnlockFromISR(void) {
 8006b50:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 8006b52:	f7f9 ff2d 	bl	80009b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8006b56:	f7fa fedb 	bl	8001910 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 8006b5a:	f7ff ffc1 	bl	8006ae0 <port_unlock_from_isr.lto_priv.177>
}
 8006b5e:	bd08      	pop	{r3, pc}

08006b60 <chThdStartI.lto_priv.243>:
static inline thread_t *chThdStartI(thread_t *tp) {
 8006b60:	b500      	push	{lr}
 8006b62:	b083      	sub	sp, #12
 8006b64:	9001      	str	r0, [sp, #4]
  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");
 8006b66:	9b01      	ldr	r3, [sp, #4]
 8006b68:	f893 3020 	ldrb.w	r3, [r3, #32]
 8006b6c:	2b02      	cmp	r3, #2
 8006b6e:	d002      	beq.n	8006b76 <chThdStartI.lto_priv.243+0x16>
 8006b70:	4805      	ldr	r0, [pc, #20]	; (8006b88 <chThdStartI.lto_priv.243+0x28>)
 8006b72:	f7f9 fe4d 	bl	8000810 <chSysHalt>
  return chSchReadyI(tp);
 8006b76:	9801      	ldr	r0, [sp, #4]
 8006b78:	f7fa f8fa 	bl	8000d70 <chSchReadyI>
 8006b7c:	4603      	mov	r3, r0
}
 8006b7e:	4618      	mov	r0, r3
 8006b80:	b003      	add	sp, #12
 8006b82:	f85d fb04 	ldr.w	pc, [sp], #4
 8006b86:	bf00      	nop
 8006b88:	0800ac10 	.word	0x0800ac10
 8006b8c:	00000000 	.word	0x00000000

08006b90 <chRegSetThreadName.lto_priv.1>:
static inline void chRegSetThreadName(const char *name) {
 8006b90:	b082      	sub	sp, #8
 8006b92:	9001      	str	r0, [sp, #4]
  ch.rlist.r_current->p_name = name;
 8006b94:	4b02      	ldr	r3, [pc, #8]	; (8006ba0 <chRegSetThreadName.lto_priv.1+0x10>)
 8006b96:	699b      	ldr	r3, [r3, #24]
 8006b98:	9a01      	ldr	r2, [sp, #4]
 8006b9a:	619a      	str	r2, [r3, #24]
}
 8006b9c:	b002      	add	sp, #8
 8006b9e:	4770      	bx	lr
 8006ba0:	20002128 	.word	0x20002128
	...

08006bb0 <osalSysLock.lto_priv.235>:
static inline void osalSysLock(void) {
 8006bb0:	b508      	push	{r3, lr}
  chSysLock();
 8006bb2:	f7ff ff9d 	bl	8006af0 <chSysLock.lto_priv.69>
}
 8006bb6:	bd08      	pop	{r3, pc}
	...

08006bc0 <osalSysUnlock.lto_priv.226>:
static inline void osalSysUnlock(void) {
 8006bc0:	b508      	push	{r3, lr}
  chSysUnlock();
 8006bc2:	f7ff ff9d 	bl	8006b00 <chSysUnlock.lto_priv.28>
}
 8006bc6:	bd08      	pop	{r3, pc}
	...

08006bd0 <osalSysLockFromISR.lto_priv.144>:
static inline void osalSysLockFromISR(void) {
 8006bd0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8006bd2:	f7ff ffb5 	bl	8006b40 <chSysLockFromISR.lto_priv.164>
}
 8006bd6:	bd08      	pop	{r3, pc}
	...

08006be0 <osalSysUnlockFromISR.lto_priv.136>:
static inline void osalSysUnlockFromISR(void) {
 8006be0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8006be2:	f7ff ffb5 	bl	8006b50 <chSysUnlockFromISR.lto_priv.154>
}
 8006be6:	bd08      	pop	{r3, pc}
	...

08006bf0 <osalSysPolledDelayX>:
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8006bf0:	b500      	push	{lr}
 8006bf2:	b083      	sub	sp, #12
 8006bf4:	9001      	str	r0, [sp, #4]
  chSysPolledDelayX(cycles);
 8006bf6:	9801      	ldr	r0, [sp, #4]
 8006bf8:	f7f9 fe42 	bl	8000880 <chSysPolledDelayX>
}
 8006bfc:	b003      	add	sp, #12
 8006bfe:	f85d fb04 	ldr.w	pc, [sp], #4
 8006c02:	bf00      	nop
	...

08006c10 <osalThreadSuspendS.lto_priv.215>:
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8006c10:	b500      	push	{lr}
 8006c12:	b083      	sub	sp, #12
 8006c14:	9001      	str	r0, [sp, #4]
  return chThdSuspendS(trp);
 8006c16:	9801      	ldr	r0, [sp, #4]
 8006c18:	f7fa fc9a 	bl	8001550 <chThdSuspendS>
 8006c1c:	4603      	mov	r3, r0
}
 8006c1e:	4618      	mov	r0, r3
 8006c20:	b003      	add	sp, #12
 8006c22:	f85d fb04 	ldr.w	pc, [sp], #4
 8006c26:	bf00      	nop
	...

08006c30 <osalThreadResumeI.lto_priv.212>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8006c30:	b500      	push	{lr}
 8006c32:	b083      	sub	sp, #12
 8006c34:	9001      	str	r0, [sp, #4]
 8006c36:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 8006c38:	9900      	ldr	r1, [sp, #0]
 8006c3a:	9801      	ldr	r0, [sp, #4]
 8006c3c:	f7fa fca8 	bl	8001590 <chThdResumeI>
}
 8006c40:	b003      	add	sp, #12
 8006c42:	f85d fb04 	ldr.w	pc, [sp], #4
 8006c46:	bf00      	nop
	...

08006c50 <otg_core_reset>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void otg_core_reset(USBDriver *usbp) {
 8006c50:	b500      	push	{lr}
 8006c52:	b085      	sub	sp, #20
 8006c54:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8006c56:	9b01      	ldr	r3, [sp, #4]
 8006c58:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8006c5a:	9303      	str	r3, [sp, #12]

  osalSysPolledDelayX(32);
 8006c5c:	2020      	movs	r0, #32
 8006c5e:	f7ff ffc7 	bl	8006bf0 <osalSysPolledDelayX>

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 8006c62:	9b03      	ldr	r3, [sp, #12]
 8006c64:	2201      	movs	r2, #1
 8006c66:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 8006c68:	9b03      	ldr	r3, [sp, #12]
 8006c6a:	691b      	ldr	r3, [r3, #16]
 8006c6c:	f003 0301 	and.w	r3, r3, #1
 8006c70:	2b00      	cmp	r3, #0
 8006c72:	d1f9      	bne.n	8006c68 <otg_core_reset+0x18>
    ;

  osalSysPolledDelayX(18);
 8006c74:	2012      	movs	r0, #18
 8006c76:	f7ff ffbb 	bl	8006bf0 <osalSysPolledDelayX>

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8006c7a:	9b03      	ldr	r3, [sp, #12]
 8006c7c:	691b      	ldr	r3, [r3, #16]
 8006c7e:	2b00      	cmp	r3, #0
 8006c80:	dafb      	bge.n	8006c7a <otg_core_reset+0x2a>
    ;
}
 8006c82:	b005      	add	sp, #20
 8006c84:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08006c90 <otg_disable_ep>:

static void otg_disable_ep(USBDriver *usbp) {
 8006c90:	b084      	sub	sp, #16
 8006c92:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8006c94:	9b01      	ldr	r3, [sp, #4]
 8006c96:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8006c98:	9302      	str	r3, [sp, #8]
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8006c9a:	2300      	movs	r3, #0
 8006c9c:	9303      	str	r3, [sp, #12]
 8006c9e:	e032      	b.n	8006d06 <otg_disable_ep+0x76>
    otgp->ie[i].DIEPCTL = 0;
 8006ca0:	9a02      	ldr	r2, [sp, #8]
 8006ca2:	9b03      	ldr	r3, [sp, #12]
 8006ca4:	3348      	adds	r3, #72	; 0x48
 8006ca6:	015b      	lsls	r3, r3, #5
 8006ca8:	4413      	add	r3, r2
 8006caa:	2200      	movs	r2, #0
 8006cac:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPTSIZ = 0;
 8006cae:	9a02      	ldr	r2, [sp, #8]
 8006cb0:	9b03      	ldr	r3, [sp, #12]
 8006cb2:	015b      	lsls	r3, r3, #5
 8006cb4:	4413      	add	r3, r2
 8006cb6:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8006cba:	2200      	movs	r2, #0
 8006cbc:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8006cbe:	9a02      	ldr	r2, [sp, #8]
 8006cc0:	9b03      	ldr	r3, [sp, #12]
 8006cc2:	015b      	lsls	r3, r3, #5
 8006cc4:	4413      	add	r3, r2
 8006cc6:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8006cca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006cce:	601a      	str	r2, [r3, #0]

    otgp->oe[i].DOEPCTL = 0;
 8006cd0:	9a02      	ldr	r2, [sp, #8]
 8006cd2:	9b03      	ldr	r3, [sp, #12]
 8006cd4:	3358      	adds	r3, #88	; 0x58
 8006cd6:	015b      	lsls	r3, r3, #5
 8006cd8:	4413      	add	r3, r2
 8006cda:	2200      	movs	r2, #0
 8006cdc:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPTSIZ = 0;
 8006cde:	9a02      	ldr	r2, [sp, #8]
 8006ce0:	9b03      	ldr	r3, [sp, #12]
 8006ce2:	015b      	lsls	r3, r3, #5
 8006ce4:	4413      	add	r3, r2
 8006ce6:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8006cea:	2200      	movs	r2, #0
 8006cec:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8006cee:	9a02      	ldr	r2, [sp, #8]
 8006cf0:	9b03      	ldr	r3, [sp, #12]
 8006cf2:	015b      	lsls	r3, r3, #5
 8006cf4:	4413      	add	r3, r2
 8006cf6:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8006cfa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006cfe:	601a      	str	r2, [r3, #0]
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8006d00:	9b03      	ldr	r3, [sp, #12]
 8006d02:	3301      	adds	r3, #1
 8006d04:	9303      	str	r3, [sp, #12]
 8006d06:	9b01      	ldr	r3, [sp, #4]
 8006d08:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8006d0a:	689b      	ldr	r3, [r3, #8]
 8006d0c:	9a03      	ldr	r2, [sp, #12]
 8006d0e:	429a      	cmp	r2, r3
 8006d10:	d9c6      	bls.n	8006ca0 <otg_disable_ep+0x10>
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8006d12:	9b02      	ldr	r3, [sp, #8]
 8006d14:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8006d18:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
}
 8006d1c:	b004      	add	sp, #16
 8006d1e:	4770      	bx	lr

08006d20 <otg_rxfifo_flush>:

static void otg_rxfifo_flush(USBDriver *usbp) {
 8006d20:	b500      	push	{lr}
 8006d22:	b085      	sub	sp, #20
 8006d24:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8006d26:	9b01      	ldr	r3, [sp, #4]
 8006d28:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8006d2a:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8006d2c:	9b03      	ldr	r3, [sp, #12]
 8006d2e:	2210      	movs	r2, #16
 8006d30:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8006d32:	9b03      	ldr	r3, [sp, #12]
 8006d34:	691b      	ldr	r3, [r3, #16]
 8006d36:	f003 0310 	and.w	r3, r3, #16
 8006d3a:	2b00      	cmp	r3, #0
 8006d3c:	d1f9      	bne.n	8006d32 <otg_rxfifo_flush+0x12>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 8006d3e:	2012      	movs	r0, #18
 8006d40:	f7ff ff56 	bl	8006bf0 <osalSysPolledDelayX>
}
 8006d44:	b005      	add	sp, #20
 8006d46:	f85d fb04 	ldr.w	pc, [sp], #4
 8006d4a:	bf00      	nop
 8006d4c:	0000      	movs	r0, r0
	...

08006d50 <otg_txfifo_flush>:

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
 8006d50:	b500      	push	{lr}
 8006d52:	b085      	sub	sp, #20
 8006d54:	9001      	str	r0, [sp, #4]
 8006d56:	9100      	str	r1, [sp, #0]
  stm32_otg_t *otgp = usbp->otg;
 8006d58:	9b01      	ldr	r3, [sp, #4]
 8006d5a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8006d5c:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8006d5e:	9b00      	ldr	r3, [sp, #0]
 8006d60:	019b      	lsls	r3, r3, #6
 8006d62:	f043 0220 	orr.w	r2, r3, #32
 8006d66:	9b03      	ldr	r3, [sp, #12]
 8006d68:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8006d6a:	9b03      	ldr	r3, [sp, #12]
 8006d6c:	691b      	ldr	r3, [r3, #16]
 8006d6e:	f003 0320 	and.w	r3, r3, #32
 8006d72:	2b00      	cmp	r3, #0
 8006d74:	d1f9      	bne.n	8006d6a <otg_txfifo_flush+0x1a>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 8006d76:	2012      	movs	r0, #18
 8006d78:	f7ff ff3a 	bl	8006bf0 <osalSysPolledDelayX>
}
 8006d7c:	b005      	add	sp, #20
 8006d7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006d82:	bf00      	nop
	...

08006d90 <otg_ram_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {
 8006d90:	b082      	sub	sp, #8
 8006d92:	9001      	str	r0, [sp, #4]

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8006d94:	9b01      	ldr	r3, [sp, #4]
 8006d96:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8006d98:	681a      	ldr	r2, [r3, #0]
 8006d9a:	9b01      	ldr	r3, [sp, #4]
 8006d9c:	675a      	str	r2, [r3, #116]	; 0x74
}
 8006d9e:	b002      	add	sp, #8
 8006da0:	4770      	bx	lr
 8006da2:	bf00      	nop
	...

08006db0 <otg_ram_alloc>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] size      size of the packet buffer to allocate in words
 *
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
 8006db0:	b500      	push	{lr}
 8006db2:	b085      	sub	sp, #20
 8006db4:	9001      	str	r0, [sp, #4]
 8006db6:	9100      	str	r1, [sp, #0]
  uint32_t next;

  next = usbp->pmnext;
 8006db8:	9b01      	ldr	r3, [sp, #4]
 8006dba:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8006dbc:	9303      	str	r3, [sp, #12]
  usbp->pmnext += size;
 8006dbe:	9b01      	ldr	r3, [sp, #4]
 8006dc0:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8006dc2:	9b00      	ldr	r3, [sp, #0]
 8006dc4:	441a      	add	r2, r3
 8006dc6:	9b01      	ldr	r3, [sp, #4]
 8006dc8:	675a      	str	r2, [r3, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8006dca:	9b01      	ldr	r3, [sp, #4]
 8006dcc:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8006dce:	9b01      	ldr	r3, [sp, #4]
 8006dd0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8006dd2:	685b      	ldr	r3, [r3, #4]
 8006dd4:	429a      	cmp	r2, r3
 8006dd6:	d902      	bls.n	8006dde <otg_ram_alloc+0x2e>
 8006dd8:	4803      	ldr	r0, [pc, #12]	; (8006de8 <otg_ram_alloc+0x38>)
 8006dda:	f7f9 fd19 	bl	8000810 <chSysHalt>
                "OTG FIFO memory overflow");
  return next;
 8006dde:	9b03      	ldr	r3, [sp, #12]
}
 8006de0:	4618      	mov	r0, r3
 8006de2:	b005      	add	sp, #20
 8006de4:	f85d fb04 	ldr.w	pc, [sp], #4
 8006de8:	0800abe0 	.word	0x0800abe0
 8006dec:	00000000 	.word	0x00000000

08006df0 <otg_fifo_write_from_buffer>:
 *
 * @notapi
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {
 8006df0:	b500      	push	{lr}
 8006df2:	b085      	sub	sp, #20
 8006df4:	9003      	str	r0, [sp, #12]
 8006df6:	9102      	str	r1, [sp, #8]
 8006df8:	9201      	str	r2, [sp, #4]

  osalDbgAssert(n > 0, "is zero");
 8006dfa:	9b01      	ldr	r3, [sp, #4]
 8006dfc:	2b00      	cmp	r3, #0
 8006dfe:	d102      	bne.n	8006e06 <otg_fifo_write_from_buffer+0x16>
 8006e00:	4809      	ldr	r0, [pc, #36]	; (8006e28 <otg_fifo_write_from_buffer+0x38>)
 8006e02:	f7f9 fd05 	bl	8000810 <chSysHalt>

  while (true) {
    *fifop = *((uint32_t *)buf);
 8006e06:	9b02      	ldr	r3, [sp, #8]
 8006e08:	681a      	ldr	r2, [r3, #0]
 8006e0a:	9b03      	ldr	r3, [sp, #12]
 8006e0c:	601a      	str	r2, [r3, #0]
    if (n <= 4) {
 8006e0e:	9b01      	ldr	r3, [sp, #4]
 8006e10:	2b04      	cmp	r3, #4
 8006e12:	d906      	bls.n	8006e22 <otg_fifo_write_from_buffer+0x32>
      break;
    }
    n -= 4;
 8006e14:	9b01      	ldr	r3, [sp, #4]
 8006e16:	3b04      	subs	r3, #4
 8006e18:	9301      	str	r3, [sp, #4]
    buf += 4;
 8006e1a:	9b02      	ldr	r3, [sp, #8]
 8006e1c:	3304      	adds	r3, #4
 8006e1e:	9302      	str	r3, [sp, #8]
 8006e20:	e7f1      	b.n	8006e06 <otg_fifo_write_from_buffer+0x16>
  }
}
 8006e22:	b005      	add	sp, #20
 8006e24:	f85d fb04 	ldr.w	pc, [sp], #4
 8006e28:	0800abf0 	.word	0x0800abf0
 8006e2c:	00000000 	.word	0x00000000

08006e30 <otg_fifo_read_to_buffer>:
 * @notapi
 */
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {
 8006e30:	b086      	sub	sp, #24
 8006e32:	9003      	str	r0, [sp, #12]
 8006e34:	9102      	str	r1, [sp, #8]
 8006e36:	9201      	str	r2, [sp, #4]
 8006e38:	9300      	str	r3, [sp, #0]
  uint32_t w = 0;
 8006e3a:	2300      	movs	r3, #0
 8006e3c:	9305      	str	r3, [sp, #20]
  size_t i = 0;
 8006e3e:	2300      	movs	r3, #0
 8006e40:	9304      	str	r3, [sp, #16]
 8006e42:	e017      	b.n	8006e74 <otg_fifo_read_to_buffer+0x44>

  while (i < n) {
    if ((i & 3) == 0){
 8006e44:	9b04      	ldr	r3, [sp, #16]
 8006e46:	f003 0303 	and.w	r3, r3, #3
 8006e4a:	2b00      	cmp	r3, #0
 8006e4c:	d102      	bne.n	8006e54 <otg_fifo_read_to_buffer+0x24>
      w = *fifop;
 8006e4e:	9b03      	ldr	r3, [sp, #12]
 8006e50:	681b      	ldr	r3, [r3, #0]
 8006e52:	9305      	str	r3, [sp, #20]
    }
    if (i < max) {
 8006e54:	9a04      	ldr	r2, [sp, #16]
 8006e56:	9b00      	ldr	r3, [sp, #0]
 8006e58:	429a      	cmp	r2, r3
 8006e5a:	d208      	bcs.n	8006e6e <otg_fifo_read_to_buffer+0x3e>
      *buf++ = (uint8_t)w;
 8006e5c:	9b02      	ldr	r3, [sp, #8]
 8006e5e:	1c5a      	adds	r2, r3, #1
 8006e60:	9202      	str	r2, [sp, #8]
 8006e62:	9a05      	ldr	r2, [sp, #20]
 8006e64:	b2d2      	uxtb	r2, r2
 8006e66:	701a      	strb	r2, [r3, #0]
      w >>= 8;
 8006e68:	9b05      	ldr	r3, [sp, #20]
 8006e6a:	0a1b      	lsrs	r3, r3, #8
 8006e6c:	9305      	str	r3, [sp, #20]
    }
    i++;
 8006e6e:	9b04      	ldr	r3, [sp, #16]
 8006e70:	3301      	adds	r3, #1
 8006e72:	9304      	str	r3, [sp, #16]
  while (i < n) {
 8006e74:	9a04      	ldr	r2, [sp, #16]
 8006e76:	9b01      	ldr	r3, [sp, #4]
 8006e78:	429a      	cmp	r2, r3
 8006e7a:	d3e3      	bcc.n	8006e44 <otg_fifo_read_to_buffer+0x14>
  }
}
 8006e7c:	b006      	add	sp, #24
 8006e7e:	4770      	bx	lr

08006e80 <otg_rxfifo_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
 8006e80:	b510      	push	{r4, lr}
 8006e82:	b086      	sub	sp, #24
 8006e84:	9001      	str	r0, [sp, #4]
  uint32_t sts, cnt, ep;

  /* Popping the event word out of the RX FIFO.*/
  sts = usbp->otg->GRXSTSP;
 8006e86:	9b01      	ldr	r3, [sp, #4]
 8006e88:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8006e8a:	6a1b      	ldr	r3, [r3, #32]
 8006e8c:	9305      	str	r3, [sp, #20]

  /* Event details.*/
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8006e8e:	9b05      	ldr	r3, [sp, #20]
 8006e90:	091b      	lsrs	r3, r3, #4
 8006e92:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8006e96:	9304      	str	r3, [sp, #16]
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8006e98:	9b05      	ldr	r3, [sp, #20]
 8006e9a:	f003 030f 	and.w	r3, r3, #15
 8006e9e:	9303      	str	r3, [sp, #12]

  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8006ea0:	9b05      	ldr	r3, [sp, #20]
 8006ea2:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
 8006ea6:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
 8006eaa:	d065      	beq.n	8006f78 <otg_rxfifo_handler+0xf8>
 8006eac:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
 8006eb0:	d806      	bhi.n	8006ec0 <otg_rxfifo_handler+0x40>
 8006eb2:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8006eb6:	d061      	beq.n	8006f7c <otg_rxfifo_handler+0xfc>
 8006eb8:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8006ebc:	d016      	beq.n	8006eec <otg_rxfifo_handler+0x6c>
 8006ebe:	e060      	b.n	8006f82 <otg_rxfifo_handler+0x102>
 8006ec0:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8006ec4:	d05c      	beq.n	8006f80 <otg_rxfifo_handler+0x100>
 8006ec6:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 8006eca:	d15a      	bne.n	8006f82 <otg_rxfifo_handler+0x102>
  case GRXSTSP_SETUP_DATA:
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8006ecc:	9b01      	ldr	r3, [sp, #4]
 8006ece:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8006ed0:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
 8006ed4:	9a01      	ldr	r2, [sp, #4]
 8006ed6:	9b03      	ldr	r3, [sp, #12]
 8006ed8:	3302      	adds	r3, #2
 8006eda:	009b      	lsls	r3, r3, #2
 8006edc:	4413      	add	r3, r2
 8006ede:	685b      	ldr	r3, [r3, #4]
 8006ee0:	6a19      	ldr	r1, [r3, #32]
 8006ee2:	2308      	movs	r3, #8
 8006ee4:	9a04      	ldr	r2, [sp, #16]
 8006ee6:	f7ff ffa3 	bl	8006e30 <otg_fifo_read_to_buffer>
 8006eea:	e04a      	b.n	8006f82 <otg_rxfifo_handler+0x102>
                            cnt, 8);
    break;
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_OUT_DATA:
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8006eec:	9b01      	ldr	r3, [sp, #4]
 8006eee:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8006ef0:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
                            usbp->epc[ep]->out_state->rxbuf,
 8006ef4:	9a01      	ldr	r2, [sp, #4]
 8006ef6:	9b03      	ldr	r3, [sp, #12]
 8006ef8:	3302      	adds	r3, #2
 8006efa:	009b      	lsls	r3, r3, #2
 8006efc:	4413      	add	r3, r2
 8006efe:	685b      	ldr	r3, [r3, #4]
 8006f00:	699b      	ldr	r3, [r3, #24]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8006f02:	689c      	ldr	r4, [r3, #8]
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
 8006f04:	9a01      	ldr	r2, [sp, #4]
 8006f06:	9b03      	ldr	r3, [sp, #12]
 8006f08:	3302      	adds	r3, #2
 8006f0a:	009b      	lsls	r3, r3, #2
 8006f0c:	4413      	add	r3, r2
 8006f0e:	685b      	ldr	r3, [r3, #4]
 8006f10:	699b      	ldr	r3, [r3, #24]
 8006f12:	681a      	ldr	r2, [r3, #0]
                            usbp->epc[ep]->out_state->rxcnt);
 8006f14:	9901      	ldr	r1, [sp, #4]
 8006f16:	9b03      	ldr	r3, [sp, #12]
 8006f18:	3302      	adds	r3, #2
 8006f1a:	009b      	lsls	r3, r3, #2
 8006f1c:	440b      	add	r3, r1
 8006f1e:	685b      	ldr	r3, [r3, #4]
 8006f20:	699b      	ldr	r3, [r3, #24]
 8006f22:	685b      	ldr	r3, [r3, #4]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8006f24:	1ad3      	subs	r3, r2, r3
 8006f26:	9a04      	ldr	r2, [sp, #16]
 8006f28:	4621      	mov	r1, r4
 8006f2a:	f7ff ff81 	bl	8006e30 <otg_fifo_read_to_buffer>
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8006f2e:	9a01      	ldr	r2, [sp, #4]
 8006f30:	9b03      	ldr	r3, [sp, #12]
 8006f32:	3302      	adds	r3, #2
 8006f34:	009b      	lsls	r3, r3, #2
 8006f36:	4413      	add	r3, r2
 8006f38:	685b      	ldr	r3, [r3, #4]
 8006f3a:	699b      	ldr	r3, [r3, #24]
 8006f3c:	6899      	ldr	r1, [r3, #8]
 8006f3e:	9a01      	ldr	r2, [sp, #4]
 8006f40:	9b03      	ldr	r3, [sp, #12]
 8006f42:	3302      	adds	r3, #2
 8006f44:	009b      	lsls	r3, r3, #2
 8006f46:	4413      	add	r3, r2
 8006f48:	685b      	ldr	r3, [r3, #4]
 8006f4a:	699b      	ldr	r3, [r3, #24]
 8006f4c:	9a04      	ldr	r2, [sp, #16]
 8006f4e:	440a      	add	r2, r1
 8006f50:	609a      	str	r2, [r3, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 8006f52:	9a01      	ldr	r2, [sp, #4]
 8006f54:	9b03      	ldr	r3, [sp, #12]
 8006f56:	3302      	adds	r3, #2
 8006f58:	009b      	lsls	r3, r3, #2
 8006f5a:	4413      	add	r3, r2
 8006f5c:	685b      	ldr	r3, [r3, #4]
 8006f5e:	699b      	ldr	r3, [r3, #24]
 8006f60:	6859      	ldr	r1, [r3, #4]
 8006f62:	9a01      	ldr	r2, [sp, #4]
 8006f64:	9b03      	ldr	r3, [sp, #12]
 8006f66:	3302      	adds	r3, #2
 8006f68:	009b      	lsls	r3, r3, #2
 8006f6a:	4413      	add	r3, r2
 8006f6c:	685b      	ldr	r3, [r3, #4]
 8006f6e:	699b      	ldr	r3, [r3, #24]
 8006f70:	9a04      	ldr	r2, [sp, #16]
 8006f72:	440a      	add	r2, r1
 8006f74:	605a      	str	r2, [r3, #4]
 8006f76:	e004      	b.n	8006f82 <otg_rxfifo_handler+0x102>
    break;
  case GRXSTSP_OUT_COMP:
 8006f78:	bf00      	nop
 8006f7a:	e002      	b.n	8006f82 <otg_rxfifo_handler+0x102>
    break;
  case GRXSTSP_OUT_GLOBAL_NAK:
 8006f7c:	bf00      	nop
 8006f7e:	e000      	b.n	8006f82 <otg_rxfifo_handler+0x102>
  case GRXSTSP_SETUP_COMP:
 8006f80:	bf00      	nop
    break;
  default:
    break;
  }
}
 8006f82:	b006      	add	sp, #24
 8006f84:	bd10      	pop	{r4, pc}
 8006f86:	bf00      	nop
	...

08006f90 <otg_txfifo_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 8006f90:	b500      	push	{lr}
 8006f92:	b085      	sub	sp, #20
 8006f94:	9001      	str	r0, [sp, #4]
 8006f96:	460b      	mov	r3, r1
 8006f98:	f88d 3003 	strb.w	r3, [sp, #3]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8006f9c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006fa0:	9a01      	ldr	r2, [sp, #4]
 8006fa2:	3302      	adds	r3, #2
 8006fa4:	009b      	lsls	r3, r3, #2
 8006fa6:	4413      	add	r3, r2
 8006fa8:	685b      	ldr	r3, [r3, #4]
 8006faa:	695b      	ldr	r3, [r3, #20]
 8006fac:	685a      	ldr	r2, [r3, #4]
 8006fae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006fb2:	9901      	ldr	r1, [sp, #4]
 8006fb4:	3302      	adds	r3, #2
 8006fb6:	009b      	lsls	r3, r3, #2
 8006fb8:	440b      	add	r3, r1
 8006fba:	685b      	ldr	r3, [r3, #4]
 8006fbc:	695b      	ldr	r3, [r3, #20]
 8006fbe:	681b      	ldr	r3, [r3, #0]
 8006fc0:	429a      	cmp	r2, r3
 8006fc2:	d301      	bcc.n	8006fc8 <otg_txfifo_handler+0x38>
      return true;
 8006fc4:	2301      	movs	r3, #1
 8006fc6:	e075      	b.n	80070b4 <otg_txfifo_handler+0x124>

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8006fc8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006fcc:	9a01      	ldr	r2, [sp, #4]
 8006fce:	3302      	adds	r3, #2
 8006fd0:	009b      	lsls	r3, r3, #2
 8006fd2:	4413      	add	r3, r2
 8006fd4:	685b      	ldr	r3, [r3, #4]
 8006fd6:	695b      	ldr	r3, [r3, #20]
 8006fd8:	681a      	ldr	r2, [r3, #0]
 8006fda:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006fde:	9901      	ldr	r1, [sp, #4]
 8006fe0:	3302      	adds	r3, #2
 8006fe2:	009b      	lsls	r3, r3, #2
 8006fe4:	440b      	add	r3, r1
 8006fe6:	685b      	ldr	r3, [r3, #4]
 8006fe8:	695b      	ldr	r3, [r3, #20]
 8006fea:	685b      	ldr	r3, [r3, #4]
 8006fec:	1ad3      	subs	r3, r2, r3
 8006fee:	9303      	str	r3, [sp, #12]
    if (n > usbp->epc[ep]->in_maxsize)
 8006ff0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006ff4:	9a01      	ldr	r2, [sp, #4]
 8006ff6:	3302      	adds	r3, #2
 8006ff8:	009b      	lsls	r3, r3, #2
 8006ffa:	4413      	add	r3, r2
 8006ffc:	685b      	ldr	r3, [r3, #4]
 8006ffe:	8a1b      	ldrh	r3, [r3, #16]
 8007000:	461a      	mov	r2, r3
 8007002:	9b03      	ldr	r3, [sp, #12]
 8007004:	4293      	cmp	r3, r2
 8007006:	d908      	bls.n	800701a <otg_txfifo_handler+0x8a>
      n = usbp->epc[ep]->in_maxsize;
 8007008:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800700c:	9a01      	ldr	r2, [sp, #4]
 800700e:	3302      	adds	r3, #2
 8007010:	009b      	lsls	r3, r3, #2
 8007012:	4413      	add	r3, r2
 8007014:	685b      	ldr	r3, [r3, #4]
 8007016:	8a1b      	ldrh	r3, [r3, #16]
 8007018:	9303      	str	r3, [sp, #12]

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800701a:	9b01      	ldr	r3, [sp, #4]
 800701c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800701e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007022:	015b      	lsls	r3, r3, #5
 8007024:	4413      	add	r3, r2
 8007026:	f603 1318 	addw	r3, r3, #2328	; 0x918
 800702a:	681b      	ldr	r3, [r3, #0]
 800702c:	b29b      	uxth	r3, r3
 800702e:	009b      	lsls	r3, r3, #2
 8007030:	9a03      	ldr	r2, [sp, #12]
 8007032:	429a      	cmp	r2, r3
 8007034:	d901      	bls.n	800703a <otg_txfifo_handler+0xaa>
      return false;
 8007036:	2300      	movs	r3, #0
 8007038:	e03c      	b.n	80070b4 <otg_txfifo_handler+0x124>

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800703a:	9b01      	ldr	r3, [sp, #4]
 800703c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800703e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007042:	3301      	adds	r3, #1
 8007044:	031b      	lsls	r3, r3, #12
 8007046:	18d0      	adds	r0, r2, r3
                               usbp->epc[ep]->in_state->txbuf,
 8007048:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800704c:	9a01      	ldr	r2, [sp, #4]
 800704e:	3302      	adds	r3, #2
 8007050:	009b      	lsls	r3, r3, #2
 8007052:	4413      	add	r3, r2
 8007054:	685b      	ldr	r3, [r3, #4]
 8007056:	695b      	ldr	r3, [r3, #20]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8007058:	689b      	ldr	r3, [r3, #8]
 800705a:	9a03      	ldr	r2, [sp, #12]
 800705c:	4619      	mov	r1, r3
 800705e:	f7ff fec7 	bl	8006df0 <otg_fifo_write_from_buffer>
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 8007062:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007066:	9a01      	ldr	r2, [sp, #4]
 8007068:	3302      	adds	r3, #2
 800706a:	009b      	lsls	r3, r3, #2
 800706c:	4413      	add	r3, r2
 800706e:	685b      	ldr	r3, [r3, #4]
 8007070:	695b      	ldr	r3, [r3, #20]
 8007072:	6899      	ldr	r1, [r3, #8]
 8007074:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007078:	9a01      	ldr	r2, [sp, #4]
 800707a:	3302      	adds	r3, #2
 800707c:	009b      	lsls	r3, r3, #2
 800707e:	4413      	add	r3, r2
 8007080:	685b      	ldr	r3, [r3, #4]
 8007082:	695b      	ldr	r3, [r3, #20]
 8007084:	9a03      	ldr	r2, [sp, #12]
 8007086:	440a      	add	r2, r1
 8007088:	609a      	str	r2, [r3, #8]
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 800708a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800708e:	9a01      	ldr	r2, [sp, #4]
 8007090:	3302      	adds	r3, #2
 8007092:	009b      	lsls	r3, r3, #2
 8007094:	4413      	add	r3, r2
 8007096:	685b      	ldr	r3, [r3, #4]
 8007098:	695b      	ldr	r3, [r3, #20]
 800709a:	6859      	ldr	r1, [r3, #4]
 800709c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80070a0:	9a01      	ldr	r2, [sp, #4]
 80070a2:	3302      	adds	r3, #2
 80070a4:	009b      	lsls	r3, r3, #2
 80070a6:	4413      	add	r3, r2
 80070a8:	685b      	ldr	r3, [r3, #4]
 80070aa:	695b      	ldr	r3, [r3, #20]
 80070ac:	9a03      	ldr	r2, [sp, #12]
 80070ae:	440a      	add	r2, r1
 80070b0:	605a      	str	r2, [r3, #4]
 80070b2:	e773      	b.n	8006f9c <otg_txfifo_handler+0xc>
  }
}
 80070b4:	4618      	mov	r0, r3
 80070b6:	b005      	add	sp, #20
 80070b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80070bc:	0000      	movs	r0, r0
	...

080070c0 <otg_epin_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 80070c0:	b500      	push	{lr}
 80070c2:	b087      	sub	sp, #28
 80070c4:	9001      	str	r0, [sp, #4]
 80070c6:	460b      	mov	r3, r1
 80070c8:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 80070cc:	9b01      	ldr	r3, [sp, #4]
 80070ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80070d0:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->ie[ep].DIEPINT;
 80070d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80070d6:	9a05      	ldr	r2, [sp, #20]
 80070d8:	015b      	lsls	r3, r3, #5
 80070da:	4413      	add	r3, r2
 80070dc:	f603 1308 	addw	r3, r3, #2312	; 0x908
 80070e0:	681b      	ldr	r3, [r3, #0]
 80070e2:	9304      	str	r3, [sp, #16]

  otgp->ie[ep].DIEPINT = epint;
 80070e4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80070e8:	9a05      	ldr	r2, [sp, #20]
 80070ea:	015b      	lsls	r3, r3, #5
 80070ec:	4413      	add	r3, r2
 80070ee:	f603 1308 	addw	r3, r3, #2312	; 0x908
 80070f2:	9a04      	ldr	r2, [sp, #16]
 80070f4:	601a      	str	r2, [r3, #0]

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 80070f6:	9b04      	ldr	r3, [sp, #16]
 80070f8:	f003 0301 	and.w	r3, r3, #1
 80070fc:	2b00      	cmp	r3, #0
 80070fe:	d062      	beq.n	80071c6 <otg_epin_handler+0x106>
 8007100:	9b05      	ldr	r3, [sp, #20]
 8007102:	f8d3 3810 	ldr.w	r3, [r3, #2064]	; 0x810
 8007106:	f003 0301 	and.w	r3, r3, #1
 800710a:	2b00      	cmp	r3, #0
 800710c:	d05b      	beq.n	80071c6 <otg_epin_handler+0x106>
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800710e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007112:	9a01      	ldr	r2, [sp, #4]
 8007114:	3302      	adds	r3, #2
 8007116:	009b      	lsls	r3, r3, #2
 8007118:	4413      	add	r3, r2
 800711a:	685b      	ldr	r3, [r3, #4]
 800711c:	695b      	ldr	r3, [r3, #20]
 800711e:	9303      	str	r3, [sp, #12]

    if (isp->txsize < isp->totsize) {
 8007120:	9b03      	ldr	r3, [sp, #12]
 8007122:	681a      	ldr	r2, [r3, #0]
 8007124:	9b03      	ldr	r3, [sp, #12]
 8007126:	691b      	ldr	r3, [r3, #16]
 8007128:	429a      	cmp	r2, r3
 800712a:	d214      	bcs.n	8007156 <otg_epin_handler+0x96>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 800712c:	9b03      	ldr	r3, [sp, #12]
 800712e:	691a      	ldr	r2, [r3, #16]
 8007130:	9b03      	ldr	r3, [sp, #12]
 8007132:	681b      	ldr	r3, [r3, #0]
 8007134:	1ad2      	subs	r2, r2, r3
 8007136:	9b03      	ldr	r3, [sp, #12]
 8007138:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 800713a:	9b03      	ldr	r3, [sp, #12]
 800713c:	2200      	movs	r2, #0
 800713e:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 8007140:	f7ff fd46 	bl	8006bd0 <osalSysLockFromISR.lto_priv.144>
      usb_lld_start_in(usbp, ep);
 8007144:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007148:	4619      	mov	r1, r3
 800714a:	9801      	ldr	r0, [sp, #4]
 800714c:	f000 ff20 	bl	8007f90 <usb_lld_start_in>
      osalSysUnlockFromISR();
 8007150:	f7ff fd46 	bl	8006be0 <osalSysUnlockFromISR.lto_priv.136>
 8007154:	e037      	b.n	80071c6 <otg_epin_handler+0x106>
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 8007156:	9b01      	ldr	r3, [sp, #4]
 8007158:	891b      	ldrh	r3, [r3, #8]
 800715a:	b21a      	sxth	r2, r3
 800715c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007160:	2101      	movs	r1, #1
 8007162:	fa01 f303 	lsl.w	r3, r1, r3
 8007166:	b21b      	sxth	r3, r3
 8007168:	43db      	mvns	r3, r3
 800716a:	b21b      	sxth	r3, r3
 800716c:	4013      	ands	r3, r2
 800716e:	b21b      	sxth	r3, r3
 8007170:	b29a      	uxth	r2, r3
 8007172:	9b01      	ldr	r3, [sp, #4]
 8007174:	811a      	strh	r2, [r3, #8]
 8007176:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800717a:	9a01      	ldr	r2, [sp, #4]
 800717c:	3302      	adds	r3, #2
 800717e:	009b      	lsls	r3, r3, #2
 8007180:	4413      	add	r3, r2
 8007182:	685b      	ldr	r3, [r3, #4]
 8007184:	689b      	ldr	r3, [r3, #8]
 8007186:	2b00      	cmp	r3, #0
 8007188:	d00c      	beq.n	80071a4 <otg_epin_handler+0xe4>
 800718a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800718e:	9a01      	ldr	r2, [sp, #4]
 8007190:	3302      	adds	r3, #2
 8007192:	009b      	lsls	r3, r3, #2
 8007194:	4413      	add	r3, r2
 8007196:	685b      	ldr	r3, [r3, #4]
 8007198:	689b      	ldr	r3, [r3, #8]
 800719a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800719e:	4611      	mov	r1, r2
 80071a0:	9801      	ldr	r0, [sp, #4]
 80071a2:	4798      	blx	r3
 80071a4:	f7ff fd14 	bl	8006bd0 <osalSysLockFromISR.lto_priv.144>
 80071a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80071ac:	9a01      	ldr	r2, [sp, #4]
 80071ae:	3302      	adds	r3, #2
 80071b0:	009b      	lsls	r3, r3, #2
 80071b2:	4413      	add	r3, r2
 80071b4:	685b      	ldr	r3, [r3, #4]
 80071b6:	695b      	ldr	r3, [r3, #20]
 80071b8:	330c      	adds	r3, #12
 80071ba:	2100      	movs	r1, #0
 80071bc:	4618      	mov	r0, r3
 80071be:	f7ff fd37 	bl	8006c30 <osalThreadResumeI.lto_priv.212>
 80071c2:	f7ff fd0d 	bl	8006be0 <osalSysUnlockFromISR.lto_priv.136>
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 80071c6:	9b04      	ldr	r3, [sp, #16]
 80071c8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80071cc:	2b00      	cmp	r3, #0
 80071ce:	d02b      	beq.n	8007228 <otg_epin_handler+0x168>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 80071d0:	9b05      	ldr	r3, [sp, #20]
 80071d2:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 80071d6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80071da:	2101      	movs	r1, #1
 80071dc:	fa01 f303 	lsl.w	r3, r1, r3
 80071e0:	4013      	ands	r3, r2
  if ((epint & DIEPINT_TXFE) &&
 80071e2:	2b00      	cmp	r3, #0
 80071e4:	d020      	beq.n	8007228 <otg_epin_handler+0x168>
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
 80071e6:	f7ff fcf3 	bl	8006bd0 <osalSysLockFromISR.lto_priv.144>
    usbp->txpending |= (1 << ep);
 80071ea:	9b01      	ldr	r3, [sp, #4]
 80071ec:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80071ee:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80071f2:	2101      	movs	r1, #1
 80071f4:	fa01 f202 	lsl.w	r2, r1, r2
 80071f8:	431a      	orrs	r2, r3
 80071fa:	9b01      	ldr	r3, [sp, #4]
 80071fc:	679a      	str	r2, [r3, #120]	; 0x78
    otgp->DIEPEMPMSK &= ~(1 << ep);
 80071fe:	9b05      	ldr	r3, [sp, #20]
 8007200:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
 8007204:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007208:	2101      	movs	r1, #1
 800720a:	fa01 f202 	lsl.w	r2, r1, r2
 800720e:	43d2      	mvns	r2, r2
 8007210:	401a      	ands	r2, r3
 8007212:	9b05      	ldr	r3, [sp, #20]
 8007214:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
    osalThreadResumeI(&usbp->wait, MSG_OK);
 8007218:	9b01      	ldr	r3, [sp, #4]
 800721a:	337c      	adds	r3, #124	; 0x7c
 800721c:	2100      	movs	r1, #0
 800721e:	4618      	mov	r0, r3
 8007220:	f7ff fd06 	bl	8006c30 <osalThreadResumeI.lto_priv.212>
    osalSysUnlockFromISR();
 8007224:	f7ff fcdc 	bl	8006be0 <osalSysUnlockFromISR.lto_priv.136>
  }
}
 8007228:	b007      	add	sp, #28
 800722a:	f85d fb04 	ldr.w	pc, [sp], #4
 800722e:	bf00      	nop

08007230 <otg_epout_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8007230:	b500      	push	{lr}
 8007232:	b087      	sub	sp, #28
 8007234:	9001      	str	r0, [sp, #4]
 8007236:	460b      	mov	r3, r1
 8007238:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800723c:	9b01      	ldr	r3, [sp, #4]
 800723e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8007240:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8007242:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007246:	9a05      	ldr	r2, [sp, #20]
 8007248:	015b      	lsls	r3, r3, #5
 800724a:	4413      	add	r3, r2
 800724c:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8007250:	681b      	ldr	r3, [r3, #0]
 8007252:	9304      	str	r3, [sp, #16]

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 8007254:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007258:	9a05      	ldr	r2, [sp, #20]
 800725a:	015b      	lsls	r3, r3, #5
 800725c:	4413      	add	r3, r2
 800725e:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8007262:	9a04      	ldr	r2, [sp, #16]
 8007264:	601a      	str	r2, [r3, #0]

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8007266:	9b04      	ldr	r3, [sp, #16]
 8007268:	f003 0308 	and.w	r3, r3, #8
 800726c:	2b00      	cmp	r3, #0
 800726e:	d013      	beq.n	8007298 <otg_epout_handler+0x68>
 8007270:	9b05      	ldr	r3, [sp, #20]
 8007272:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 8007276:	f003 0308 	and.w	r3, r3, #8
 800727a:	2b00      	cmp	r3, #0
 800727c:	d00c      	beq.n	8007298 <otg_epout_handler+0x68>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 800727e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007282:	9a01      	ldr	r2, [sp, #4]
 8007284:	3302      	adds	r3, #2
 8007286:	009b      	lsls	r3, r3, #2
 8007288:	4413      	add	r3, r2
 800728a:	685b      	ldr	r3, [r3, #4]
 800728c:	685b      	ldr	r3, [r3, #4]
 800728e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007292:	4611      	mov	r1, r2
 8007294:	9801      	ldr	r0, [sp, #4]
 8007296:	4798      	blx	r3
  }

  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8007298:	9b04      	ldr	r3, [sp, #16]
 800729a:	f003 0301 	and.w	r3, r3, #1
 800729e:	2b00      	cmp	r3, #0
 80072a0:	f000 8081 	beq.w	80073a6 <otg_epout_handler+0x176>
 80072a4:	9b05      	ldr	r3, [sp, #20]
 80072a6:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 80072aa:	f003 0301 	and.w	r3, r3, #1
 80072ae:	2b00      	cmp	r3, #0
 80072b0:	d079      	beq.n	80073a6 <otg_epout_handler+0x176>
    USBOutEndpointState *osp;

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 80072b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80072b6:	9a01      	ldr	r2, [sp, #4]
 80072b8:	3302      	adds	r3, #2
 80072ba:	009b      	lsls	r3, r3, #2
 80072bc:	4413      	add	r3, r2
 80072be:	685b      	ldr	r3, [r3, #4]
 80072c0:	699b      	ldr	r3, [r3, #24]
 80072c2:	9303      	str	r3, [sp, #12]

    /* EP0 requires special handling.*/
    if (ep == 0) {
 80072c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80072c8:	2b00      	cmp	r3, #0
 80072ca:	d12b      	bne.n	8007324 <otg_epout_handler+0xf4>
#endif

      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 80072cc:	9b03      	ldr	r3, [sp, #12]
 80072ce:	685a      	ldr	r2, [r3, #4]
 80072d0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80072d4:	9901      	ldr	r1, [sp, #4]
 80072d6:	3302      	adds	r3, #2
 80072d8:	009b      	lsls	r3, r3, #2
 80072da:	440b      	add	r3, r1
 80072dc:	685b      	ldr	r3, [r3, #4]
 80072de:	8a5b      	ldrh	r3, [r3, #18]
 80072e0:	fbb2 f1f3 	udiv	r1, r2, r3
 80072e4:	fb03 f301 	mul.w	r3, r3, r1
 80072e8:	1ad3      	subs	r3, r2, r3
 80072ea:	2b00      	cmp	r3, #0
 80072ec:	d11a      	bne.n	8007324 <otg_epout_handler+0xf4>
          (osp->rxsize < osp->totsize)) {
 80072ee:	9b03      	ldr	r3, [sp, #12]
 80072f0:	681a      	ldr	r2, [r3, #0]
 80072f2:	9b03      	ldr	r3, [sp, #12]
 80072f4:	691b      	ldr	r3, [r3, #16]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 80072f6:	429a      	cmp	r2, r3
 80072f8:	d214      	bcs.n	8007324 <otg_epout_handler+0xf4>
        osp->rxsize = osp->totsize - osp->rxsize;
 80072fa:	9b03      	ldr	r3, [sp, #12]
 80072fc:	691a      	ldr	r2, [r3, #16]
 80072fe:	9b03      	ldr	r3, [sp, #12]
 8007300:	681b      	ldr	r3, [r3, #0]
 8007302:	1ad2      	subs	r2, r2, r3
 8007304:	9b03      	ldr	r3, [sp, #12]
 8007306:	601a      	str	r2, [r3, #0]
        osp->rxcnt  = 0;
 8007308:	9b03      	ldr	r3, [sp, #12]
 800730a:	2200      	movs	r2, #0
 800730c:	605a      	str	r2, [r3, #4]
        osalSysLockFromISR();
 800730e:	f7ff fc5f 	bl	8006bd0 <osalSysLockFromISR.lto_priv.144>
        usb_lld_start_out(usbp, ep);
 8007312:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007316:	4619      	mov	r1, r3
 8007318:	9801      	ldr	r0, [sp, #4]
 800731a:	f000 fd99 	bl	8007e50 <usb_lld_start_out>
        osalSysUnlockFromISR();
 800731e:	f7ff fc5f 	bl	8006be0 <osalSysUnlockFromISR.lto_priv.136>
 8007322:	e040      	b.n	80073a6 <otg_epout_handler+0x176>
        return;
      }
    }

    /* End on OUT transfer.*/
    _usb_isr_invoke_out_cb(usbp, ep);
 8007324:	9b01      	ldr	r3, [sp, #4]
 8007326:	895b      	ldrh	r3, [r3, #10]
 8007328:	b21a      	sxth	r2, r3
 800732a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800732e:	2101      	movs	r1, #1
 8007330:	fa01 f303 	lsl.w	r3, r1, r3
 8007334:	b21b      	sxth	r3, r3
 8007336:	43db      	mvns	r3, r3
 8007338:	b21b      	sxth	r3, r3
 800733a:	4013      	ands	r3, r2
 800733c:	b21b      	sxth	r3, r3
 800733e:	b29a      	uxth	r2, r3
 8007340:	9b01      	ldr	r3, [sp, #4]
 8007342:	815a      	strh	r2, [r3, #10]
 8007344:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007348:	9a01      	ldr	r2, [sp, #4]
 800734a:	3302      	adds	r3, #2
 800734c:	009b      	lsls	r3, r3, #2
 800734e:	4413      	add	r3, r2
 8007350:	685b      	ldr	r3, [r3, #4]
 8007352:	68db      	ldr	r3, [r3, #12]
 8007354:	2b00      	cmp	r3, #0
 8007356:	d00c      	beq.n	8007372 <otg_epout_handler+0x142>
 8007358:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800735c:	9a01      	ldr	r2, [sp, #4]
 800735e:	3302      	adds	r3, #2
 8007360:	009b      	lsls	r3, r3, #2
 8007362:	4413      	add	r3, r2
 8007364:	685b      	ldr	r3, [r3, #4]
 8007366:	68db      	ldr	r3, [r3, #12]
 8007368:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800736c:	4611      	mov	r1, r2
 800736e:	9801      	ldr	r0, [sp, #4]
 8007370:	4798      	blx	r3
 8007372:	f7ff fc2d 	bl	8006bd0 <osalSysLockFromISR.lto_priv.144>
 8007376:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800737a:	9a01      	ldr	r2, [sp, #4]
 800737c:	3302      	adds	r3, #2
 800737e:	009b      	lsls	r3, r3, #2
 8007380:	4413      	add	r3, r2
 8007382:	685b      	ldr	r3, [r3, #4]
 8007384:	699b      	ldr	r3, [r3, #24]
 8007386:	f103 000c 	add.w	r0, r3, #12
 800738a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800738e:	9a01      	ldr	r2, [sp, #4]
 8007390:	3302      	adds	r3, #2
 8007392:	009b      	lsls	r3, r3, #2
 8007394:	4413      	add	r3, r2
 8007396:	685b      	ldr	r3, [r3, #4]
 8007398:	699b      	ldr	r3, [r3, #24]
 800739a:	685b      	ldr	r3, [r3, #4]
 800739c:	4619      	mov	r1, r3
 800739e:	f7ff fc47 	bl	8006c30 <osalThreadResumeI.lto_priv.212>
 80073a2:	f7ff fc1d 	bl	8006be0 <osalSysUnlockFromISR.lto_priv.136>
  }
}
 80073a6:	b007      	add	sp, #28
 80073a8:	f85d fb04 	ldr.w	pc, [sp], #4
 80073ac:	0000      	movs	r0, r0
	...

080073b0 <otg_isoc_in_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
 80073b0:	b500      	push	{lr}
 80073b2:	b085      	sub	sp, #20
 80073b4:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 80073b6:	9b01      	ldr	r3, [sp, #4]
 80073b8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80073ba:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80073bc:	2300      	movs	r3, #0
 80073be:	f88d 300f 	strb.w	r3, [sp, #15]
 80073c2:	e092      	b.n	80074ea <otg_isoc_in_failed_handler+0x13a>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 80073c4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80073c8:	9a02      	ldr	r2, [sp, #8]
 80073ca:	3348      	adds	r3, #72	; 0x48
 80073cc:	015b      	lsls	r3, r3, #5
 80073ce:	4413      	add	r3, r2
 80073d0:	681b      	ldr	r3, [r3, #0]
 80073d2:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 80073d6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80073da:	f040 8081 	bne.w	80074e0 <otg_isoc_in_failed_handler+0x130>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 80073de:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80073e2:	9a02      	ldr	r2, [sp, #8]
 80073e4:	3348      	adds	r3, #72	; 0x48
 80073e6:	015b      	lsls	r3, r3, #5
 80073e8:	4413      	add	r3, r2
 80073ea:	681b      	ldr	r3, [r3, #0]
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 80073ec:	2b00      	cmp	r3, #0
 80073ee:	da77      	bge.n	80074e0 <otg_isoc_in_failed_handler+0x130>
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 80073f0:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80073f4:	9a02      	ldr	r2, [sp, #8]
 80073f6:	3348      	adds	r3, #72	; 0x48
 80073f8:	015b      	lsls	r3, r3, #5
 80073fa:	4413      	add	r3, r2
 80073fc:	681a      	ldr	r2, [r3, #0]
 80073fe:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007402:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 8007406:	9902      	ldr	r1, [sp, #8]
 8007408:	3348      	adds	r3, #72	; 0x48
 800740a:	015b      	lsls	r3, r3, #5
 800740c:	440b      	add	r3, r1
 800740e:	601a      	str	r2, [r3, #0]
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8007410:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007414:	9a02      	ldr	r2, [sp, #8]
 8007416:	3348      	adds	r3, #72	; 0x48
 8007418:	015b      	lsls	r3, r3, #5
 800741a:	4413      	add	r3, r2
 800741c:	681b      	ldr	r3, [r3, #0]
 800741e:	2b00      	cmp	r3, #0
 8007420:	dbf6      	blt.n	8007410 <otg_isoc_in_failed_handler+0x60>
        ;

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);
 8007422:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007426:	4619      	mov	r1, r3
 8007428:	9801      	ldr	r0, [sp, #4]
 800742a:	f7ff fc91 	bl	8006d50 <otg_txfifo_flush>

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 800742e:	9b01      	ldr	r3, [sp, #4]
 8007430:	891b      	ldrh	r3, [r3, #8]
 8007432:	b21a      	sxth	r2, r3
 8007434:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007438:	2101      	movs	r1, #1
 800743a:	fa01 f303 	lsl.w	r3, r1, r3
 800743e:	b21b      	sxth	r3, r3
 8007440:	43db      	mvns	r3, r3
 8007442:	b21b      	sxth	r3, r3
 8007444:	4013      	ands	r3, r2
 8007446:	b21b      	sxth	r3, r3
 8007448:	b29a      	uxth	r2, r3
 800744a:	9b01      	ldr	r3, [sp, #4]
 800744c:	811a      	strh	r2, [r3, #8]
 800744e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007452:	9a01      	ldr	r2, [sp, #4]
 8007454:	3302      	adds	r3, #2
 8007456:	009b      	lsls	r3, r3, #2
 8007458:	4413      	add	r3, r2
 800745a:	685b      	ldr	r3, [r3, #4]
 800745c:	689b      	ldr	r3, [r3, #8]
 800745e:	2b00      	cmp	r3, #0
 8007460:	d00c      	beq.n	800747c <otg_isoc_in_failed_handler+0xcc>
 8007462:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007466:	9a01      	ldr	r2, [sp, #4]
 8007468:	3302      	adds	r3, #2
 800746a:	009b      	lsls	r3, r3, #2
 800746c:	4413      	add	r3, r2
 800746e:	685b      	ldr	r3, [r3, #4]
 8007470:	689b      	ldr	r3, [r3, #8]
 8007472:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8007476:	4611      	mov	r1, r2
 8007478:	9801      	ldr	r0, [sp, #4]
 800747a:	4798      	blx	r3
 800747c:	f7ff fba8 	bl	8006bd0 <osalSysLockFromISR.lto_priv.144>
 8007480:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007484:	9a01      	ldr	r2, [sp, #4]
 8007486:	3302      	adds	r3, #2
 8007488:	009b      	lsls	r3, r3, #2
 800748a:	4413      	add	r3, r2
 800748c:	685b      	ldr	r3, [r3, #4]
 800748e:	695b      	ldr	r3, [r3, #20]
 8007490:	330c      	adds	r3, #12
 8007492:	2100      	movs	r1, #0
 8007494:	4618      	mov	r0, r3
 8007496:	f7ff fbcb 	bl	8006c30 <osalThreadResumeI.lto_priv.212>
 800749a:	f7ff fba1 	bl	8006be0 <osalSysUnlockFromISR.lto_priv.136>

      /* Pump out data for next frame */
      osalSysLockFromISR();
 800749e:	f7ff fb97 	bl	8006bd0 <osalSysLockFromISR.lto_priv.144>
      otgp->DIEPEMPMSK &= ~(1 << ep);
 80074a2:	9b02      	ldr	r3, [sp, #8]
 80074a4:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
 80074a8:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80074ac:	2101      	movs	r1, #1
 80074ae:	fa01 f202 	lsl.w	r2, r1, r2
 80074b2:	43d2      	mvns	r2, r2
 80074b4:	401a      	ands	r2, r3
 80074b6:	9b02      	ldr	r3, [sp, #8]
 80074b8:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
      usbp->txpending |= (1 << ep);
 80074bc:	9b01      	ldr	r3, [sp, #4]
 80074be:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80074c0:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80074c4:	2101      	movs	r1, #1
 80074c6:	fa01 f202 	lsl.w	r2, r1, r2
 80074ca:	431a      	orrs	r2, r3
 80074cc:	9b01      	ldr	r3, [sp, #4]
 80074ce:	679a      	str	r2, [r3, #120]	; 0x78
      osalThreadResumeI(&usbp->wait, MSG_OK);
 80074d0:	9b01      	ldr	r3, [sp, #4]
 80074d2:	337c      	adds	r3, #124	; 0x7c
 80074d4:	2100      	movs	r1, #0
 80074d6:	4618      	mov	r0, r3
 80074d8:	f7ff fbaa 	bl	8006c30 <osalThreadResumeI.lto_priv.212>
      osalSysUnlockFromISR();
 80074dc:	f7ff fb80 	bl	8006be0 <osalSysUnlockFromISR.lto_priv.136>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80074e0:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80074e4:	3301      	adds	r3, #1
 80074e6:	f88d 300f 	strb.w	r3, [sp, #15]
 80074ea:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80074ee:	9b01      	ldr	r3, [sp, #4]
 80074f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80074f2:	689b      	ldr	r3, [r3, #8]
 80074f4:	429a      	cmp	r2, r3
 80074f6:	f67f af65 	bls.w	80073c4 <otg_isoc_in_failed_handler+0x14>
    }
  }
}
 80074fa:	b005      	add	sp, #20
 80074fc:	f85d fb04 	ldr.w	pc, [sp], #4

08007500 <otg_isoc_out_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
 8007500:	b500      	push	{lr}
 8007502:	b085      	sub	sp, #20
 8007504:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8007506:	9b01      	ldr	r3, [sp, #4]
 8007508:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800750a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800750c:	2300      	movs	r3, #0
 800750e:	f88d 300f 	strb.w	r3, [sp, #15]
 8007512:	e05a      	b.n	80075ca <otg_isoc_out_failed_handler+0xca>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8007514:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007518:	9a02      	ldr	r2, [sp, #8]
 800751a:	3358      	adds	r3, #88	; 0x58
 800751c:	015b      	lsls	r3, r3, #5
 800751e:	4413      	add	r3, r2
 8007520:	681b      	ldr	r3, [r3, #0]
 8007522:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8007526:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800752a:	d149      	bne.n	80075c0 <otg_isoc_out_failed_handler+0xc0>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 800752c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007530:	9a02      	ldr	r2, [sp, #8]
 8007532:	3358      	adds	r3, #88	; 0x58
 8007534:	015b      	lsls	r3, r3, #5
 8007536:	4413      	add	r3, r2
 8007538:	681b      	ldr	r3, [r3, #0]
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 800753a:	2b00      	cmp	r3, #0
 800753c:	da40      	bge.n	80075c0 <otg_isoc_out_failed_handler+0xc0>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 800753e:	9b01      	ldr	r3, [sp, #4]
 8007540:	895b      	ldrh	r3, [r3, #10]
 8007542:	b21a      	sxth	r2, r3
 8007544:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007548:	2101      	movs	r1, #1
 800754a:	fa01 f303 	lsl.w	r3, r1, r3
 800754e:	b21b      	sxth	r3, r3
 8007550:	43db      	mvns	r3, r3
 8007552:	b21b      	sxth	r3, r3
 8007554:	4013      	ands	r3, r2
 8007556:	b21b      	sxth	r3, r3
 8007558:	b29a      	uxth	r2, r3
 800755a:	9b01      	ldr	r3, [sp, #4]
 800755c:	815a      	strh	r2, [r3, #10]
 800755e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007562:	9a01      	ldr	r2, [sp, #4]
 8007564:	3302      	adds	r3, #2
 8007566:	009b      	lsls	r3, r3, #2
 8007568:	4413      	add	r3, r2
 800756a:	685b      	ldr	r3, [r3, #4]
 800756c:	68db      	ldr	r3, [r3, #12]
 800756e:	2b00      	cmp	r3, #0
 8007570:	d00c      	beq.n	800758c <otg_isoc_out_failed_handler+0x8c>
 8007572:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007576:	9a01      	ldr	r2, [sp, #4]
 8007578:	3302      	adds	r3, #2
 800757a:	009b      	lsls	r3, r3, #2
 800757c:	4413      	add	r3, r2
 800757e:	685b      	ldr	r3, [r3, #4]
 8007580:	68db      	ldr	r3, [r3, #12]
 8007582:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8007586:	4611      	mov	r1, r2
 8007588:	9801      	ldr	r0, [sp, #4]
 800758a:	4798      	blx	r3
 800758c:	f7ff fb20 	bl	8006bd0 <osalSysLockFromISR.lto_priv.144>
 8007590:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007594:	9a01      	ldr	r2, [sp, #4]
 8007596:	3302      	adds	r3, #2
 8007598:	009b      	lsls	r3, r3, #2
 800759a:	4413      	add	r3, r2
 800759c:	685b      	ldr	r3, [r3, #4]
 800759e:	699b      	ldr	r3, [r3, #24]
 80075a0:	f103 000c 	add.w	r0, r3, #12
 80075a4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80075a8:	9a01      	ldr	r2, [sp, #4]
 80075aa:	3302      	adds	r3, #2
 80075ac:	009b      	lsls	r3, r3, #2
 80075ae:	4413      	add	r3, r2
 80075b0:	685b      	ldr	r3, [r3, #4]
 80075b2:	699b      	ldr	r3, [r3, #24]
 80075b4:	685b      	ldr	r3, [r3, #4]
 80075b6:	4619      	mov	r1, r3
 80075b8:	f7ff fb3a 	bl	8006c30 <osalThreadResumeI.lto_priv.212>
 80075bc:	f7ff fb10 	bl	8006be0 <osalSysUnlockFromISR.lto_priv.136>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80075c0:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80075c4:	3301      	adds	r3, #1
 80075c6:	f88d 300f 	strb.w	r3, [sp, #15]
 80075ca:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80075ce:	9b01      	ldr	r3, [sp, #4]
 80075d0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80075d2:	689b      	ldr	r3, [r3, #8]
 80075d4:	429a      	cmp	r2, r3
 80075d6:	d99d      	bls.n	8007514 <otg_isoc_out_failed_handler+0x14>
    }
  }
}
 80075d8:	b005      	add	sp, #20
 80075da:	f85d fb04 	ldr.w	pc, [sp], #4
 80075de:	bf00      	nop

080075e0 <usb_lld_serve_interrupt>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 80075e0:	b500      	push	{lr}
 80075e2:	b087      	sub	sp, #28
 80075e4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80075e6:	9b01      	ldr	r3, [sp, #4]
 80075e8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80075ea:	9305      	str	r3, [sp, #20]
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 80075ec:	9b05      	ldr	r3, [sp, #20]
 80075ee:	695b      	ldr	r3, [r3, #20]
 80075f0:	9304      	str	r3, [sp, #16]
  sts &= otgp->GINTMSK;
 80075f2:	9b05      	ldr	r3, [sp, #20]
 80075f4:	699b      	ldr	r3, [r3, #24]
 80075f6:	9a04      	ldr	r2, [sp, #16]
 80075f8:	4013      	ands	r3, r2
 80075fa:	9304      	str	r3, [sp, #16]
  otgp->GINTSTS = sts;
 80075fc:	9b05      	ldr	r3, [sp, #20]
 80075fe:	9a04      	ldr	r2, [sp, #16]
 8007600:	615a      	str	r2, [r3, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8007602:	9b04      	ldr	r3, [sp, #16]
 8007604:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8007608:	2b00      	cmp	r3, #0
 800760a:	d006      	beq.n	800761a <usb_lld_serve_interrupt+0x3a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 800760c:	9b01      	ldr	r3, [sp, #4]
 800760e:	2200      	movs	r2, #0
 8007610:	679a      	str	r2, [r3, #120]	; 0x78

    /* Default reset action.*/
    _usb_reset(usbp);
 8007612:	9801      	ldr	r0, [sp, #4]
 8007614:	f7fe f88c 	bl	8005730 <_usb_reset>
 8007618:	e0f2      	b.n	8007800 <usb_lld_serve_interrupt+0x220>
    /* Preventing execution of more handlers, the core has been reset.*/
    return;
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 800761a:	9b04      	ldr	r3, [sp, #16]
 800761c:	2b00      	cmp	r3, #0
 800761e:	da19      	bge.n	8007654 <usb_lld_serve_interrupt+0x74>
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8007620:	9b05      	ldr	r3, [sp, #20]
 8007622:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8007626:	f003 0303 	and.w	r3, r3, #3
 800762a:	2b00      	cmp	r3, #0
 800762c:	d007      	beq.n	800763e <usb_lld_serve_interrupt+0x5e>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 800762e:	9b05      	ldr	r3, [sp, #20]
 8007630:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8007634:	f023 0203 	bic.w	r2, r3, #3
 8007638:	9b05      	ldr	r3, [sp, #20]
 800763a:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL |= DCTL_RWUSIG;
 800763e:	9b05      	ldr	r3, [sp, #20]
 8007640:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8007644:	f043 0201 	orr.w	r2, r3, #1
 8007648:	9b05      	ldr	r3, [sp, #20]
 800764a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804

    _usb_wakeup(usbp);
 800764e:	9801      	ldr	r0, [sp, #4]
 8007650:	f7fe f946 	bl	80058e0 <_usb_wakeup>
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 8007654:	9b04      	ldr	r3, [sp, #16]
 8007656:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800765a:	2b00      	cmp	r3, #0
 800765c:	d005      	beq.n	800766a <usb_lld_serve_interrupt+0x8a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 800765e:	9b01      	ldr	r3, [sp, #4]
 8007660:	2200      	movs	r2, #0
 8007662:	679a      	str	r2, [r3, #120]	; 0x78

    /* Default suspend action.*/
    _usb_suspend(usbp);
 8007664:	9801      	ldr	r0, [sp, #4]
 8007666:	f7fe f8db 	bl	8005820 <_usb_suspend>
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 800766a:	9b04      	ldr	r3, [sp, #16]
 800766c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8007670:	2b00      	cmp	r3, #0
 8007672:	d017      	beq.n	80076a4 <usb_lld_serve_interrupt+0xc4>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8007674:	9b05      	ldr	r3, [sp, #20]
 8007676:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 800767a:	f003 0306 	and.w	r3, r3, #6
 800767e:	2b00      	cmp	r3, #0
 8007680:	d108      	bne.n	8007694 <usb_lld_serve_interrupt+0xb4>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8007682:	9b05      	ldr	r3, [sp, #20]
 8007684:	68db      	ldr	r3, [r3, #12]
 8007686:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 800768a:	f443 5210 	orr.w	r2, r3, #9216	; 0x2400
 800768e:	9b05      	ldr	r3, [sp, #20]
 8007690:	60da      	str	r2, [r3, #12]
 8007692:	e007      	b.n	80076a4 <usb_lld_serve_interrupt+0xc4>
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8007694:	9b05      	ldr	r3, [sp, #20]
 8007696:	68db      	ldr	r3, [r3, #12]
 8007698:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 800769c:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 80076a0:	9b05      	ldr	r3, [sp, #20]
 80076a2:	60da      	str	r2, [r3, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 80076a4:	9b04      	ldr	r3, [sp, #16]
 80076a6:	f003 0308 	and.w	r3, r3, #8
 80076aa:	2b00      	cmp	r3, #0
 80076ac:	d009      	beq.n	80076c2 <usb_lld_serve_interrupt+0xe2>
    _usb_isr_invoke_sof_cb(usbp);
 80076ae:	9b01      	ldr	r3, [sp, #4]
 80076b0:	685b      	ldr	r3, [r3, #4]
 80076b2:	68db      	ldr	r3, [r3, #12]
 80076b4:	2b00      	cmp	r3, #0
 80076b6:	d004      	beq.n	80076c2 <usb_lld_serve_interrupt+0xe2>
 80076b8:	9b01      	ldr	r3, [sp, #4]
 80076ba:	685b      	ldr	r3, [r3, #4]
 80076bc:	68db      	ldr	r3, [r3, #12]
 80076be:	9801      	ldr	r0, [sp, #4]
 80076c0:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 80076c2:	9b04      	ldr	r3, [sp, #16]
 80076c4:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 80076c8:	2b00      	cmp	r3, #0
 80076ca:	d002      	beq.n	80076d2 <usb_lld_serve_interrupt+0xf2>
    otg_isoc_in_failed_handler(usbp);
 80076cc:	9801      	ldr	r0, [sp, #4]
 80076ce:	f7ff fe6f 	bl	80073b0 <otg_isoc_in_failed_handler>
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 80076d2:	9b04      	ldr	r3, [sp, #16]
 80076d4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80076d8:	2b00      	cmp	r3, #0
 80076da:	d002      	beq.n	80076e2 <usb_lld_serve_interrupt+0x102>
    otg_isoc_out_failed_handler(usbp);
 80076dc:	9801      	ldr	r0, [sp, #4]
 80076de:	f7ff ff0f 	bl	8007500 <otg_isoc_out_failed_handler>
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 80076e2:	9b04      	ldr	r3, [sp, #16]
 80076e4:	f003 0310 	and.w	r3, r3, #16
 80076e8:	2b00      	cmp	r3, #0
 80076ea:	d00f      	beq.n	800770c <usb_lld_serve_interrupt+0x12c>
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
 80076ec:	f7ff fa70 	bl	8006bd0 <osalSysLockFromISR.lto_priv.144>
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 80076f0:	9b05      	ldr	r3, [sp, #20]
 80076f2:	699b      	ldr	r3, [r3, #24]
 80076f4:	f023 0210 	bic.w	r2, r3, #16
 80076f8:	9b05      	ldr	r3, [sp, #20]
 80076fa:	619a      	str	r2, [r3, #24]
    osalThreadResumeI(&usbp->wait, MSG_OK);
 80076fc:	9b01      	ldr	r3, [sp, #4]
 80076fe:	337c      	adds	r3, #124	; 0x7c
 8007700:	2100      	movs	r1, #0
 8007702:	4618      	mov	r0, r3
 8007704:	f7ff fa94 	bl	8006c30 <osalThreadResumeI.lto_priv.212>
    osalSysUnlockFromISR();
 8007708:	f7ff fa6a 	bl	8006be0 <osalSysUnlockFromISR.lto_priv.136>
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 800770c:	9b05      	ldr	r3, [sp, #20]
 800770e:	f8d3 3818 	ldr.w	r3, [r3, #2072]	; 0x818
 8007712:	9303      	str	r3, [sp, #12]
  if (sts & GINTSTS_OEPINT) {
 8007714:	9b04      	ldr	r3, [sp, #16]
 8007716:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800771a:	2b00      	cmp	r3, #0
 800771c:	d035      	beq.n	800778a <usb_lld_serve_interrupt+0x1aa>
    if (src & (1 << 16))
 800771e:	9b03      	ldr	r3, [sp, #12]
 8007720:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8007724:	2b00      	cmp	r3, #0
 8007726:	d003      	beq.n	8007730 <usb_lld_serve_interrupt+0x150>
      otg_epout_handler(usbp, 0);
 8007728:	2100      	movs	r1, #0
 800772a:	9801      	ldr	r0, [sp, #4]
 800772c:	f7ff fd80 	bl	8007230 <otg_epout_handler>
    if (src & (1 << 17))
 8007730:	9b03      	ldr	r3, [sp, #12]
 8007732:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8007736:	2b00      	cmp	r3, #0
 8007738:	d003      	beq.n	8007742 <usb_lld_serve_interrupt+0x162>
      otg_epout_handler(usbp, 1);
 800773a:	2101      	movs	r1, #1
 800773c:	9801      	ldr	r0, [sp, #4]
 800773e:	f7ff fd77 	bl	8007230 <otg_epout_handler>
    if (src & (1 << 18))
 8007742:	9b03      	ldr	r3, [sp, #12]
 8007744:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8007748:	2b00      	cmp	r3, #0
 800774a:	d003      	beq.n	8007754 <usb_lld_serve_interrupt+0x174>
      otg_epout_handler(usbp, 2);
 800774c:	2102      	movs	r1, #2
 800774e:	9801      	ldr	r0, [sp, #4]
 8007750:	f7ff fd6e 	bl	8007230 <otg_epout_handler>
    if (src & (1 << 19))
 8007754:	9b03      	ldr	r3, [sp, #12]
 8007756:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800775a:	2b00      	cmp	r3, #0
 800775c:	d003      	beq.n	8007766 <usb_lld_serve_interrupt+0x186>
      otg_epout_handler(usbp, 3);
 800775e:	2103      	movs	r1, #3
 8007760:	9801      	ldr	r0, [sp, #4]
 8007762:	f7ff fd65 	bl	8007230 <otg_epout_handler>
#if USB_MAX_ENDPOINTS >= 4
    if (src & (1 << 20))
 8007766:	9b03      	ldr	r3, [sp, #12]
 8007768:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800776c:	2b00      	cmp	r3, #0
 800776e:	d003      	beq.n	8007778 <usb_lld_serve_interrupt+0x198>
      otg_epout_handler(usbp, 4);
 8007770:	2104      	movs	r1, #4
 8007772:	9801      	ldr	r0, [sp, #4]
 8007774:	f7ff fd5c 	bl	8007230 <otg_epout_handler>
#endif
#if USB_MAX_ENDPOINTS >= 5
    if (src & (1 << 21))
 8007778:	9b03      	ldr	r3, [sp, #12]
 800777a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800777e:	2b00      	cmp	r3, #0
 8007780:	d003      	beq.n	800778a <usb_lld_serve_interrupt+0x1aa>
      otg_epout_handler(usbp, 5);
 8007782:	2105      	movs	r1, #5
 8007784:	9801      	ldr	r0, [sp, #4]
 8007786:	f7ff fd53 	bl	8007230 <otg_epout_handler>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 24))
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
 800778a:	9b04      	ldr	r3, [sp, #16]
 800778c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8007790:	2b00      	cmp	r3, #0
 8007792:	d035      	beq.n	8007800 <usb_lld_serve_interrupt+0x220>
    if (src & (1 << 0))
 8007794:	9b03      	ldr	r3, [sp, #12]
 8007796:	f003 0301 	and.w	r3, r3, #1
 800779a:	2b00      	cmp	r3, #0
 800779c:	d003      	beq.n	80077a6 <usb_lld_serve_interrupt+0x1c6>
      otg_epin_handler(usbp, 0);
 800779e:	2100      	movs	r1, #0
 80077a0:	9801      	ldr	r0, [sp, #4]
 80077a2:	f7ff fc8d 	bl	80070c0 <otg_epin_handler>
    if (src & (1 << 1))
 80077a6:	9b03      	ldr	r3, [sp, #12]
 80077a8:	f003 0302 	and.w	r3, r3, #2
 80077ac:	2b00      	cmp	r3, #0
 80077ae:	d003      	beq.n	80077b8 <usb_lld_serve_interrupt+0x1d8>
      otg_epin_handler(usbp, 1);
 80077b0:	2101      	movs	r1, #1
 80077b2:	9801      	ldr	r0, [sp, #4]
 80077b4:	f7ff fc84 	bl	80070c0 <otg_epin_handler>
    if (src & (1 << 2))
 80077b8:	9b03      	ldr	r3, [sp, #12]
 80077ba:	f003 0304 	and.w	r3, r3, #4
 80077be:	2b00      	cmp	r3, #0
 80077c0:	d003      	beq.n	80077ca <usb_lld_serve_interrupt+0x1ea>
      otg_epin_handler(usbp, 2);
 80077c2:	2102      	movs	r1, #2
 80077c4:	9801      	ldr	r0, [sp, #4]
 80077c6:	f7ff fc7b 	bl	80070c0 <otg_epin_handler>
    if (src & (1 << 3))
 80077ca:	9b03      	ldr	r3, [sp, #12]
 80077cc:	f003 0308 	and.w	r3, r3, #8
 80077d0:	2b00      	cmp	r3, #0
 80077d2:	d003      	beq.n	80077dc <usb_lld_serve_interrupt+0x1fc>
      otg_epin_handler(usbp, 3);
 80077d4:	2103      	movs	r1, #3
 80077d6:	9801      	ldr	r0, [sp, #4]
 80077d8:	f7ff fc72 	bl	80070c0 <otg_epin_handler>
#if USB_MAX_ENDPOINTS >= 4
    if (src & (1 << 4))
 80077dc:	9b03      	ldr	r3, [sp, #12]
 80077de:	f003 0310 	and.w	r3, r3, #16
 80077e2:	2b00      	cmp	r3, #0
 80077e4:	d003      	beq.n	80077ee <usb_lld_serve_interrupt+0x20e>
      otg_epin_handler(usbp, 4);
 80077e6:	2104      	movs	r1, #4
 80077e8:	9801      	ldr	r0, [sp, #4]
 80077ea:	f7ff fc69 	bl	80070c0 <otg_epin_handler>
#endif
#if USB_MAX_ENDPOINTS >= 5
    if (src & (1 << 5))
 80077ee:	9b03      	ldr	r3, [sp, #12]
 80077f0:	f003 0320 	and.w	r3, r3, #32
 80077f4:	2b00      	cmp	r3, #0
 80077f6:	d003      	beq.n	8007800 <usb_lld_serve_interrupt+0x220>
      otg_epin_handler(usbp, 5);
 80077f8:	2105      	movs	r1, #5
 80077fa:	9801      	ldr	r0, [sp, #4]
 80077fc:	f7ff fc60 	bl	80070c0 <otg_epin_handler>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 8))
      otg_epin_handler(usbp, 8);
#endif
  }
}
 8007800:	b007      	add	sp, #28
 8007802:	f85d fb04 	ldr.w	pc, [sp], #4
 8007806:	bf00      	nop
	...

08007810 <Vector174>:
/**
 * @brief   OTG2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG2_HANDLER) {
 8007810:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8007812:	f7fa f835 	bl	8001880 <_stats_increase_irq>
 8007816:	f7f9 f8e3 	bl	80009e0 <_dbg_check_enter_isr>

  usb_lld_serve_interrupt(&USBD2);
 800781a:	4804      	ldr	r0, [pc, #16]	; (800782c <Vector174+0x1c>)
 800781c:	f7ff fee0 	bl	80075e0 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8007820:	f7f9 f8fe 	bl	8000a20 <_dbg_check_leave_isr>
 8007824:	f7fb f8fc 	bl	8002a20 <_port_irq_epilogue>
}
 8007828:	bd08      	pop	{r3, pc}
 800782a:	bf00      	nop
 800782c:	20002468 	.word	0x20002468

08007830 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8007830:	b500      	push	{lr}
 8007832:	b083      	sub	sp, #12
#endif /* CH_DBG_FILL_THREADS */
#endif /* defined(_CHIBIOS_RT_) */
#endif

#if STM32_USB_USE_OTG2
  usbObjectInit(&USBD2);
 8007834:	4812      	ldr	r0, [pc, #72]	; (8007880 <usb_lld_init+0x50>)
 8007836:	f7fd fdb3 	bl	80053a0 <usbObjectInit>
  USBD2.wait      = NULL;
 800783a:	4b11      	ldr	r3, [pc, #68]	; (8007880 <usb_lld_init+0x50>)
 800783c:	2200      	movs	r2, #0
 800783e:	67da      	str	r2, [r3, #124]	; 0x7c
  USBD2.otg       = OTG_HS;
 8007840:	4b0f      	ldr	r3, [pc, #60]	; (8007880 <usb_lld_init+0x50>)
 8007842:	4a10      	ldr	r2, [pc, #64]	; (8007884 <usb_lld_init+0x54>)
 8007844:	66da      	str	r2, [r3, #108]	; 0x6c
  USBD2.otgparams = &hsparams;
 8007846:	4b0e      	ldr	r3, [pc, #56]	; (8007880 <usb_lld_init+0x50>)
 8007848:	4a0f      	ldr	r2, [pc, #60]	; (8007888 <usb_lld_init+0x58>)
 800784a:	671a      	str	r2, [r3, #112]	; 0x70

#if defined(_CHIBIOS_RT_)
  USBD2.tr = NULL;
 800784c:	4b0c      	ldr	r3, [pc, #48]	; (8007880 <usb_lld_init+0x50>)
 800784e:	2200      	movs	r2, #0
 8007850:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  /* Filling the thread working area here because the function
     @p chThdCreateI() does not do it.*/
#if CH_DBG_FILL_THREADS
  {
    void *wsp = USBD2.wa_pump;
 8007854:	4b0d      	ldr	r3, [pc, #52]	; (800788c <usb_lld_init+0x5c>)
 8007856:	9301      	str	r3, [sp, #4]
    _thread_memfill((uint8_t *)wsp,
 8007858:	9b01      	ldr	r3, [sp, #4]
 800785a:	3360      	adds	r3, #96	; 0x60
 800785c:	22ff      	movs	r2, #255	; 0xff
 800785e:	4619      	mov	r1, r3
 8007860:	9801      	ldr	r0, [sp, #4]
 8007862:	f7f9 fd8d 	bl	8001380 <_thread_memfill>
                    (uint8_t *)wsp + sizeof(thread_t),
                    CH_DBG_THREAD_FILL_VALUE);
    _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 8007866:	9b01      	ldr	r3, [sp, #4]
 8007868:	f103 0060 	add.w	r0, r3, #96	; 0x60
 800786c:	9b01      	ldr	r3, [sp, #4]
 800786e:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
 8007872:	2255      	movs	r2, #85	; 0x55
 8007874:	4619      	mov	r1, r3
 8007876:	f7f9 fd83 	bl	8001380 <_thread_memfill>
                    CH_DBG_STACK_FILL_VALUE);
  }
#endif /* CH_DBG_FILL_THREADS */
#endif /* defined(_CHIBIOS_RT_) */
#endif
}
 800787a:	b003      	add	sp, #12
 800787c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007880:	20002468 	.word	0x20002468
 8007884:	40040000 	.word	0x40040000
 8007888:	0800abc0 	.word	0x0800abc0
 800788c:	200024f0 	.word	0x200024f0

08007890 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8007890:	b500      	push	{lr}
 8007892:	b087      	sub	sp, #28
 8007894:	9003      	str	r0, [sp, #12]
  stm32_otg_t *otgp = usbp->otg;
 8007896:	9b03      	ldr	r3, [sp, #12]
 8007898:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800789a:	9305      	str	r3, [sp, #20]

  if (usbp->state == USB_STOP) {
 800789c:	9b03      	ldr	r3, [sp, #12]
 800789e:	781b      	ldrb	r3, [r3, #0]
 80078a0:	2b01      	cmp	r3, #1
 80078a2:	d17e      	bne.n	80079a2 <usb_lld_start+0x112>
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
    }
#endif

#if STM32_USB_USE_OTG2
    if (&USBD2 == usbp) {
 80078a4:	9b03      	ldr	r3, [sp, #12]
 80078a6:	4a40      	ldr	r2, [pc, #256]	; (80079a8 <usb_lld_start+0x118>)
 80078a8:	4293      	cmp	r3, r2
 80078aa:	d125      	bne.n	80078f8 <usb_lld_start+0x68>
      /* OTG HS clock enable and reset.*/
      rccEnableOTG_HS(false);
 80078ac:	4b3f      	ldr	r3, [pc, #252]	; (80079ac <usb_lld_start+0x11c>)
 80078ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80078b0:	4a3e      	ldr	r2, [pc, #248]	; (80079ac <usb_lld_start+0x11c>)
 80078b2:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80078b6:	6313      	str	r3, [r2, #48]	; 0x30
      rccResetOTG_HS();
 80078b8:	4b3c      	ldr	r3, [pc, #240]	; (80079ac <usb_lld_start+0x11c>)
 80078ba:	691b      	ldr	r3, [r3, #16]
 80078bc:	4a3b      	ldr	r2, [pc, #236]	; (80079ac <usb_lld_start+0x11c>)
 80078be:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80078c2:	6113      	str	r3, [r2, #16]
 80078c4:	4b39      	ldr	r3, [pc, #228]	; (80079ac <usb_lld_start+0x11c>)
 80078c6:	2200      	movs	r2, #0
 80078c8:	611a      	str	r2, [r3, #16]
#if defined(BOARD_OTG2_USES_ULPI)
      rccEnableOTG_HSULPI(true);
#else
      /* Workaround for the problem described here:
         http://forum.chibios.org/phpbb/viewtopic.php?f=16&t=1798.*/
      rccDisableOTG_HSULPI(true);
 80078ca:	4b38      	ldr	r3, [pc, #224]	; (80079ac <usb_lld_start+0x11c>)
 80078cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80078ce:	4a37      	ldr	r2, [pc, #220]	; (80079ac <usb_lld_start+0x11c>)
 80078d0:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 80078d4:	6313      	str	r3, [r2, #48]	; 0x30
 80078d6:	4b35      	ldr	r3, [pc, #212]	; (80079ac <usb_lld_start+0x11c>)
 80078d8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80078da:	4a34      	ldr	r2, [pc, #208]	; (80079ac <usb_lld_start+0x11c>)
 80078dc:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 80078e0:	6513      	str	r3, [r2, #80]	; 0x50
#endif

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
 80078e2:	210e      	movs	r1, #14
 80078e4:	204d      	movs	r0, #77	; 0x4d
 80078e6:	f7fe f9eb 	bl	8005cc0 <nvicEnableVector>
#if defined(BOARD_OTG2_USES_ULPI)
      /* High speed ULPI PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_HS) |
                      GUSBCFG_SRPCAP | GUSBCFG_HNPCAP;
#else
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 80078ea:	9b05      	ldr	r3, [sp, #20]
 80078ec:	4a30      	ldr	r2, [pc, #192]	; (80079b0 <usb_lld_start+0x120>)
 80078ee:	60da      	str	r2, [r3, #12]
      /* USB 2.0 High Speed PHY in FS mode.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_HS_FS;
#endif
#else
      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 80078f0:	9b05      	ldr	r3, [sp, #20]
 80078f2:	4a30      	ldr	r2, [pc, #192]	; (80079b4 <usb_lld_start+0x124>)
 80078f4:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
#endif
    }
#endif

    /* Clearing mask of TXFIFOs to be filled.*/
    usbp->txpending = 0;
 80078f8:	9b03      	ldr	r3, [sp, #12]
 80078fa:	2200      	movs	r2, #0
 80078fc:	679a      	str	r2, [r3, #120]	; 0x78

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 80078fe:	9b05      	ldr	r3, [sp, #20]
 8007900:	2200      	movs	r2, #0
 8007902:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8007906:	9b05      	ldr	r3, [sp, #20]
 8007908:	22c0      	movs	r2, #192	; 0xc0
 800790a:	601a      	str	r2, [r3, #0]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 800790c:	9b05      	ldr	r3, [sp, #20]
 800790e:	f44f 2250 	mov.w	r2, #851968	; 0xd0000
 8007912:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    /* Soft core reset.*/
    otg_core_reset(usbp);
 8007914:	9803      	ldr	r0, [sp, #12]
 8007916:	f7ff f99b 	bl	8006c50 <otg_core_reset>

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 800791a:	9b05      	ldr	r3, [sp, #20]
 800791c:	2200      	movs	r2, #0
 800791e:	609a      	str	r2, [r3, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 8007920:	9803      	ldr	r0, [sp, #12]
 8007922:	f7ff f9b5 	bl	8006c90 <otg_disable_ep>

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8007926:	9b05      	ldr	r3, [sp, #20]
 8007928:	2200      	movs	r2, #0
 800792a:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 800792e:	9b05      	ldr	r3, [sp, #20]
 8007930:	2200      	movs	r2, #0
 8007932:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8007936:	9b05      	ldr	r3, [sp, #20]
 8007938:	2200      	movs	r2, #0
 800793a:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 800793e:	9b03      	ldr	r3, [sp, #12]
 8007940:	685b      	ldr	r3, [r3, #4]
 8007942:	68db      	ldr	r3, [r3, #12]
 8007944:	2b00      	cmp	r3, #0
 8007946:	d103      	bne.n	8007950 <usb_lld_start+0xc0>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8007948:	9b05      	ldr	r3, [sp, #20]
 800794a:	4a1b      	ldr	r2, [pc, #108]	; (80079b8 <usb_lld_start+0x128>)
 800794c:	619a      	str	r2, [r3, #24]
 800794e:	e002      	b.n	8007956 <usb_lld_start+0xc6>
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8007950:	9b05      	ldr	r3, [sp, #20]
 8007952:	4a1a      	ldr	r2, [pc, #104]	; (80079bc <usb_lld_start+0x12c>)
 8007954:	619a      	str	r2, [r3, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 8007956:	9b05      	ldr	r3, [sp, #20]
 8007958:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800795c:	615a      	str	r2, [r3, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 800795e:	9b03      	ldr	r3, [sp, #12]
 8007960:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8007964:	2b00      	cmp	r3, #0
 8007966:	d116      	bne.n	8007996 <usb_lld_start+0x106>
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 8007968:	9b03      	ldr	r3, [sp, #12]
 800796a:	f103 0088 	add.w	r0, r3, #136	; 0x88
 800796e:	9b03      	ldr	r3, [sp, #12]
 8007970:	9300      	str	r3, [sp, #0]
 8007972:	4b13      	ldr	r3, [pc, #76]	; (80079c0 <usb_lld_start+0x130>)
 8007974:	2202      	movs	r2, #2
 8007976:	f44f 71f8 	mov.w	r1, #496	; 0x1f0
 800797a:	f7f9 fd19 	bl	80013b0 <chThdCreateI>
 800797e:	4602      	mov	r2, r0
 8007980:	9b03      	ldr	r3, [sp, #12]
 8007982:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
                              STM32_USB_OTG_THREAD_PRIO,
                              usb_lld_pump, usbp);
      chThdStartI(usbp->tr);
 8007986:	9b03      	ldr	r3, [sp, #12]
 8007988:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800798c:	4618      	mov	r0, r3
 800798e:	f7ff f8e7 	bl	8006b60 <chThdStartI.lto_priv.243>
      chSchRescheduleS();
 8007992:	f7f9 fb35 	bl	8001000 <chSchRescheduleS>
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8007996:	9b05      	ldr	r3, [sp, #20]
 8007998:	689b      	ldr	r3, [r3, #8]
 800799a:	f043 0201 	orr.w	r2, r3, #1
 800799e:	9b05      	ldr	r3, [sp, #20]
 80079a0:	609a      	str	r2, [r3, #8]
  }
}
 80079a2:	b007      	add	sp, #28
 80079a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80079a8:	20002468 	.word	0x20002468
 80079ac:	40023800 	.word	0x40023800
 80079b0:	40001440 	.word	0x40001440
 80079b4:	02200003 	.word	0x02200003
 80079b8:	c0303c00 	.word	0xc0303c00
 80079bc:	c0303c08 	.word	0xc0303c08
 80079c0:	080081f1 	.word	0x080081f1
	...

080079d0 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 80079d0:	b510      	push	{r4, lr}
 80079d2:	b084      	sub	sp, #16
 80079d4:	9001      	str	r0, [sp, #4]
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 80079d6:	9b01      	ldr	r3, [sp, #4]
 80079d8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80079da:	9302      	str	r3, [sp, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);
 80079dc:	2100      	movs	r1, #0
 80079de:	9801      	ldr	r0, [sp, #4]
 80079e0:	f7ff f9b6 	bl	8006d50 <otg_txfifo_flush>

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 80079e4:	9b02      	ldr	r3, [sp, #8]
 80079e6:	2200      	movs	r2, #0
 80079e8:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80079ec:	9b02      	ldr	r3, [sp, #8]
 80079ee:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 80079f2:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80079f6:	2300      	movs	r3, #0
 80079f8:	9303      	str	r3, [sp, #12]
 80079fa:	e024      	b.n	8007a46 <usb_lld_reset+0x76>
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 80079fc:	9a02      	ldr	r2, [sp, #8]
 80079fe:	9b03      	ldr	r3, [sp, #12]
 8007a00:	3348      	adds	r3, #72	; 0x48
 8007a02:	015b      	lsls	r3, r3, #5
 8007a04:	4413      	add	r3, r2
 8007a06:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8007a0a:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8007a0c:	9a02      	ldr	r2, [sp, #8]
 8007a0e:	9b03      	ldr	r3, [sp, #12]
 8007a10:	3358      	adds	r3, #88	; 0x58
 8007a12:	015b      	lsls	r3, r3, #5
 8007a14:	4413      	add	r3, r2
 8007a16:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8007a1a:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8007a1c:	9a02      	ldr	r2, [sp, #8]
 8007a1e:	9b03      	ldr	r3, [sp, #12]
 8007a20:	015b      	lsls	r3, r3, #5
 8007a22:	4413      	add	r3, r2
 8007a24:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8007a28:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8007a2c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8007a2e:	9a02      	ldr	r2, [sp, #8]
 8007a30:	9b03      	ldr	r3, [sp, #12]
 8007a32:	015b      	lsls	r3, r3, #5
 8007a34:	4413      	add	r3, r2
 8007a36:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8007a3a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8007a3e:	601a      	str	r2, [r3, #0]
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8007a40:	9b03      	ldr	r3, [sp, #12]
 8007a42:	3301      	adds	r3, #1
 8007a44:	9303      	str	r3, [sp, #12]
 8007a46:	9b01      	ldr	r3, [sp, #4]
 8007a48:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007a4a:	689b      	ldr	r3, [r3, #8]
 8007a4c:	9a03      	ldr	r2, [sp, #12]
 8007a4e:	429a      	cmp	r2, r3
 8007a50:	d9d4      	bls.n	80079fc <usb_lld_reset+0x2c>
  }

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 8007a52:	9801      	ldr	r0, [sp, #4]
 8007a54:	f7ff f99c 	bl	8006d90 <otg_ram_reset>

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8007a58:	9b01      	ldr	r3, [sp, #4]
 8007a5a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007a5c:	681a      	ldr	r2, [r3, #0]
 8007a5e:	9b02      	ldr	r3, [sp, #8]
 8007a60:	625a      	str	r2, [r3, #36]	; 0x24
  otg_rxfifo_flush(usbp);
 8007a62:	9801      	ldr	r0, [sp, #4]
 8007a64:	f7ff f95c 	bl	8006d20 <otg_rxfifo_flush>

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8007a68:	9b02      	ldr	r3, [sp, #8]
 8007a6a:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 8007a6e:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 8007a72:	9b02      	ldr	r3, [sp, #8]
 8007a74:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8007a78:	9b02      	ldr	r3, [sp, #8]
 8007a7a:	699b      	ldr	r3, [r3, #24]
 8007a7c:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8007a80:	f043 0310 	orr.w	r3, r3, #16
 8007a84:	9a02      	ldr	r2, [sp, #8]
 8007a86:	6193      	str	r3, [r2, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8007a88:	9b02      	ldr	r3, [sp, #8]
 8007a8a:	2209      	movs	r2, #9
 8007a8c:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8007a90:	9b02      	ldr	r3, [sp, #8]
 8007a92:	2209      	movs	r2, #9
 8007a94:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8007a98:	9b01      	ldr	r3, [sp, #4]
 8007a9a:	4a17      	ldr	r2, [pc, #92]	; (8007af8 <usb_lld_reset+0x128>)
 8007a9c:	60da      	str	r2, [r3, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 8007a9e:	9b02      	ldr	r3, [sp, #8]
 8007aa0:	f04f 42c0 	mov.w	r2, #1610612736	; 0x60000000
 8007aa4:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
 8007aa8:	2340      	movs	r3, #64	; 0x40
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8007aaa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8007aae:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8007ab2:	9a02      	ldr	r2, [sp, #8]
 8007ab4:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 8007ab8:	9b02      	ldr	r3, [sp, #8]
 8007aba:	2200      	movs	r2, #0
 8007abc:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
 8007ac0:	2340      	movs	r3, #64	; 0x40
 8007ac2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8007ac6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8007aca:	9a02      	ldr	r2, [sp, #8]
 8007acc:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8007ad0:	2340      	movs	r3, #64	; 0x40
 8007ad2:	089b      	lsrs	r3, r3, #2
 8007ad4:	b29b      	uxth	r3, r3
 8007ad6:	041b      	lsls	r3, r3, #16
 8007ad8:	461c      	mov	r4, r3
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 8007ada:	2340      	movs	r3, #64	; 0x40
 8007adc:	089b      	lsrs	r3, r3, #2
 8007ade:	b29b      	uxth	r3, r3
 8007ae0:	4619      	mov	r1, r3
 8007ae2:	9801      	ldr	r0, [sp, #4]
 8007ae4:	f7ff f964 	bl	8006db0 <otg_ram_alloc>
 8007ae8:	4603      	mov	r3, r0
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8007aea:	ea44 0203 	orr.w	r2, r4, r3
 8007aee:	9b02      	ldr	r3, [sp, #8]
 8007af0:	629a      	str	r2, [r3, #40]	; 0x28
                                                  ep0config.in_maxsize / 4));
}
 8007af2:	b004      	add	sp, #16
 8007af4:	bd10      	pop	{r4, pc}
 8007af6:	bf00      	nop
 8007af8:	0800ab90 	.word	0x0800ab90
 8007afc:	00000000 	.word	0x00000000

08007b00 <usb_lld_set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
 8007b00:	b084      	sub	sp, #16
 8007b02:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8007b04:	9b01      	ldr	r3, [sp, #4]
 8007b06:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8007b08:	9303      	str	r3, [sp, #12]

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 8007b0a:	9b03      	ldr	r3, [sp, #12]
 8007b0c:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 8007b10:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8007b14:	9a01      	ldr	r2, [sp, #4]
 8007b16:	f892 2066 	ldrb.w	r2, [r2, #102]	; 0x66
 8007b1a:	0112      	lsls	r2, r2, #4
 8007b1c:	431a      	orrs	r2, r3
 8007b1e:	9b03      	ldr	r3, [sp, #12]
 8007b20:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
}
 8007b24:	b004      	add	sp, #16
 8007b26:	4770      	bx	lr
	...

08007b30 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8007b30:	b510      	push	{r4, lr}
 8007b32:	b086      	sub	sp, #24
 8007b34:	9001      	str	r0, [sp, #4]
 8007b36:	460b      	mov	r3, r1
 8007b38:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 8007b3c:	9b01      	ldr	r3, [sp, #4]
 8007b3e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8007b40:	9303      	str	r3, [sp, #12]

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8007b42:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007b46:	9a01      	ldr	r2, [sp, #4]
 8007b48:	3302      	adds	r3, #2
 8007b4a:	009b      	lsls	r3, r3, #2
 8007b4c:	4413      	add	r3, r2
 8007b4e:	685b      	ldr	r3, [r3, #4]
 8007b50:	681b      	ldr	r3, [r3, #0]
 8007b52:	f003 0303 	and.w	r3, r3, #3
 8007b56:	2b03      	cmp	r3, #3
 8007b58:	f200 8104 	bhi.w	8007d64 <usb_lld_init_endpoint+0x234>
 8007b5c:	a201      	add	r2, pc, #4	; (adr r2, 8007b64 <usb_lld_init_endpoint+0x34>)
 8007b5e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007b62:	bf00      	nop
 8007b64:	08007b75 	.word	0x08007b75
 8007b68:	08007b7b 	.word	0x08007b7b
 8007b6c:	08007b81 	.word	0x08007b81
 8007b70:	08007b87 	.word	0x08007b87
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8007b74:	4b7d      	ldr	r3, [pc, #500]	; (8007d6c <usb_lld_init_endpoint+0x23c>)
 8007b76:	9305      	str	r3, [sp, #20]
 8007b78:	e007      	b.n	8007b8a <usb_lld_init_endpoint+0x5a>
    break;
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
 8007b7a:	4b7d      	ldr	r3, [pc, #500]	; (8007d70 <usb_lld_init_endpoint+0x240>)
 8007b7c:	9305      	str	r3, [sp, #20]
 8007b7e:	e004      	b.n	8007b8a <usb_lld_init_endpoint+0x5a>
    break;
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 8007b80:	4b7c      	ldr	r3, [pc, #496]	; (8007d74 <usb_lld_init_endpoint+0x244>)
 8007b82:	9305      	str	r3, [sp, #20]
 8007b84:	e001      	b.n	8007b8a <usb_lld_init_endpoint+0x5a>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8007b86:	4b7c      	ldr	r3, [pc, #496]	; (8007d78 <usb_lld_init_endpoint+0x248>)
 8007b88:	9305      	str	r3, [sp, #20]
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 8007b8a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007b8e:	9a03      	ldr	r2, [sp, #12]
 8007b90:	015b      	lsls	r3, r3, #5
 8007b92:	4413      	add	r3, r2
 8007b94:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8007b98:	2200      	movs	r2, #0
 8007b9a:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 8007b9c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007ba0:	9a01      	ldr	r2, [sp, #4]
 8007ba2:	3302      	adds	r3, #2
 8007ba4:	009b      	lsls	r3, r3, #2
 8007ba6:	4413      	add	r3, r2
 8007ba8:	685b      	ldr	r3, [r3, #4]
 8007baa:	699b      	ldr	r3, [r3, #24]
 8007bac:	2b00      	cmp	r3, #0
 8007bae:	d01f      	beq.n	8007bf0 <usb_lld_init_endpoint+0xc0>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8007bb0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007bb4:	9a01      	ldr	r2, [sp, #4]
 8007bb6:	3302      	adds	r3, #2
 8007bb8:	009b      	lsls	r3, r3, #2
 8007bba:	4413      	add	r3, r2
 8007bbc:	685b      	ldr	r3, [r3, #4]
 8007bbe:	8a5b      	ldrh	r3, [r3, #18]
 8007bc0:	4619      	mov	r1, r3
 8007bc2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007bc6:	9a05      	ldr	r2, [sp, #20]
 8007bc8:	430a      	orrs	r2, r1
 8007bca:	9903      	ldr	r1, [sp, #12]
 8007bcc:	3358      	adds	r3, #88	; 0x58
 8007bce:	015b      	lsls	r3, r3, #5
 8007bd0:	440b      	add	r3, r1
 8007bd2:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8007bd4:	9b03      	ldr	r3, [sp, #12]
 8007bd6:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8007bda:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007bde:	3310      	adds	r3, #16
 8007be0:	2101      	movs	r1, #1
 8007be2:	fa01 f303 	lsl.w	r3, r1, r3
 8007be6:	431a      	orrs	r2, r3
 8007be8:	9b03      	ldr	r3, [sp, #12]
 8007bea:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8007bee:	e01d      	b.n	8007c2c <usb_lld_init_endpoint+0xfc>
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8007bf0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007bf4:	9a03      	ldr	r2, [sp, #12]
 8007bf6:	3358      	adds	r3, #88	; 0x58
 8007bf8:	015b      	lsls	r3, r3, #5
 8007bfa:	4413      	add	r3, r2
 8007bfc:	681a      	ldr	r2, [r3, #0]
 8007bfe:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007c02:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8007c06:	9903      	ldr	r1, [sp, #12]
 8007c08:	3358      	adds	r3, #88	; 0x58
 8007c0a:	015b      	lsls	r3, r3, #5
 8007c0c:	440b      	add	r3, r1
 8007c0e:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8007c10:	9b03      	ldr	r3, [sp, #12]
 8007c12:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8007c16:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007c1a:	3310      	adds	r3, #16
 8007c1c:	2101      	movs	r1, #1
 8007c1e:	fa01 f303 	lsl.w	r3, r1, r3
 8007c22:	43db      	mvns	r3, r3
 8007c24:	401a      	ands	r2, r3
 8007c26:	9b03      	ldr	r3, [sp, #12]
 8007c28:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 8007c2c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007c30:	9a03      	ldr	r2, [sp, #12]
 8007c32:	015b      	lsls	r3, r3, #5
 8007c34:	4413      	add	r3, r2
 8007c36:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8007c3a:	2200      	movs	r2, #0
 8007c3c:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->in_state != NULL) {
 8007c3e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007c42:	9a01      	ldr	r2, [sp, #4]
 8007c44:	3302      	adds	r3, #2
 8007c46:	009b      	lsls	r3, r3, #2
 8007c48:	4413      	add	r3, r2
 8007c4a:	685b      	ldr	r3, [r3, #4]
 8007c4c:	695b      	ldr	r3, [r3, #20]
 8007c4e:	2b00      	cmp	r3, #0
 8007c50:	d05b      	beq.n	8007d0a <usb_lld_init_endpoint+0x1da>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8007c52:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007c56:	9a01      	ldr	r2, [sp, #4]
 8007c58:	3302      	adds	r3, #2
 8007c5a:	009b      	lsls	r3, r3, #2
 8007c5c:	4413      	add	r3, r2
 8007c5e:	685b      	ldr	r3, [r3, #4]
 8007c60:	8a1b      	ldrh	r3, [r3, #16]
 8007c62:	089b      	lsrs	r3, r3, #2
 8007c64:	b29b      	uxth	r3, r3
 8007c66:	9304      	str	r3, [sp, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 8007c68:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007c6c:	9a01      	ldr	r2, [sp, #4]
 8007c6e:	3302      	adds	r3, #2
 8007c70:	009b      	lsls	r3, r3, #2
 8007c72:	4413      	add	r3, r2
 8007c74:	685b      	ldr	r3, [r3, #4]
 8007c76:	8b9b      	ldrh	r3, [r3, #28]
 8007c78:	2b01      	cmp	r3, #1
 8007c7a:	d90c      	bls.n	8007c96 <usb_lld_init_endpoint+0x166>
      fsize *= usbp->epc[ep]->in_multiplier;
 8007c7c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007c80:	9a01      	ldr	r2, [sp, #4]
 8007c82:	3302      	adds	r3, #2
 8007c84:	009b      	lsls	r3, r3, #2
 8007c86:	4413      	add	r3, r2
 8007c88:	685b      	ldr	r3, [r3, #4]
 8007c8a:	8b9b      	ldrh	r3, [r3, #28]
 8007c8c:	461a      	mov	r2, r3
 8007c8e:	9b04      	ldr	r3, [sp, #16]
 8007c90:	fb02 f303 	mul.w	r3, r2, r3
 8007c94:	9304      	str	r3, [sp, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8007c96:	9b04      	ldr	r3, [sp, #16]
 8007c98:	041c      	lsls	r4, r3, #16
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
 8007c9a:	9904      	ldr	r1, [sp, #16]
 8007c9c:	9801      	ldr	r0, [sp, #4]
 8007c9e:	f7ff f887 	bl	8006db0 <otg_ram_alloc>
 8007ca2:	4602      	mov	r2, r0
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8007ca4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007ca8:	3b01      	subs	r3, #1
 8007caa:	4322      	orrs	r2, r4
 8007cac:	9903      	ldr	r1, [sp, #12]
 8007cae:	3340      	adds	r3, #64	; 0x40
 8007cb0:	009b      	lsls	r3, r3, #2
 8007cb2:	440b      	add	r3, r1
 8007cb4:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 8007cb6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007cba:	4619      	mov	r1, r3
 8007cbc:	9801      	ldr	r0, [sp, #4]
 8007cbe:	f7ff f847 	bl	8006d50 <otg_txfifo_flush>

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 8007cc2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007cc6:	059b      	lsls	r3, r3, #22
 8007cc8:	461a      	mov	r2, r3
    otgp->ie[ep].DIEPCTL = ctl |
 8007cca:	9b05      	ldr	r3, [sp, #20]
 8007ccc:	431a      	orrs	r2, r3
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 8007cce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007cd2:	9901      	ldr	r1, [sp, #4]
 8007cd4:	3302      	adds	r3, #2
 8007cd6:	009b      	lsls	r3, r3, #2
 8007cd8:	440b      	add	r3, r1
 8007cda:	685b      	ldr	r3, [r3, #4]
 8007cdc:	8a1b      	ldrh	r3, [r3, #16]
 8007cde:	4619      	mov	r1, r3
    otgp->ie[ep].DIEPCTL = ctl |
 8007ce0:	f89d 3003 	ldrb.w	r3, [sp, #3]
                           DIEPCTL_TXFNUM(ep) |
 8007ce4:	430a      	orrs	r2, r1
    otgp->ie[ep].DIEPCTL = ctl |
 8007ce6:	9903      	ldr	r1, [sp, #12]
 8007ce8:	3348      	adds	r3, #72	; 0x48
 8007cea:	015b      	lsls	r3, r3, #5
 8007cec:	440b      	add	r3, r1
 8007cee:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8007cf0:	9b03      	ldr	r3, [sp, #12]
 8007cf2:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8007cf6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007cfa:	2101      	movs	r1, #1
 8007cfc:	fa01 f303 	lsl.w	r3, r1, r3
 8007d00:	431a      	orrs	r2, r3
 8007d02:	9b03      	ldr	r3, [sp, #12]
 8007d04:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8007d08:	e02d      	b.n	8007d66 <usb_lld_init_endpoint+0x236>
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8007d0a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007d0e:	3b01      	subs	r3, #1
 8007d10:	9a03      	ldr	r2, [sp, #12]
 8007d12:	3340      	adds	r3, #64	; 0x40
 8007d14:	009b      	lsls	r3, r3, #2
 8007d16:	4413      	add	r3, r2
 8007d18:	4a18      	ldr	r2, [pc, #96]	; (8007d7c <usb_lld_init_endpoint+0x24c>)
 8007d1a:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 8007d1c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007d20:	4619      	mov	r1, r3
 8007d22:	9801      	ldr	r0, [sp, #4]
 8007d24:	f7ff f814 	bl	8006d50 <otg_txfifo_flush>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8007d28:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007d2c:	9a03      	ldr	r2, [sp, #12]
 8007d2e:	3348      	adds	r3, #72	; 0x48
 8007d30:	015b      	lsls	r3, r3, #5
 8007d32:	4413      	add	r3, r2
 8007d34:	681a      	ldr	r2, [r3, #0]
 8007d36:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007d3a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8007d3e:	9903      	ldr	r1, [sp, #12]
 8007d40:	3348      	adds	r3, #72	; 0x48
 8007d42:	015b      	lsls	r3, r3, #5
 8007d44:	440b      	add	r3, r1
 8007d46:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8007d48:	9b03      	ldr	r3, [sp, #12]
 8007d4a:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8007d4e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007d52:	2101      	movs	r1, #1
 8007d54:	fa01 f303 	lsl.w	r3, r1, r3
 8007d58:	43db      	mvns	r3, r3
 8007d5a:	401a      	ands	r2, r3
 8007d5c:	9b03      	ldr	r3, [sp, #12]
 8007d5e:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8007d62:	e000      	b.n	8007d66 <usb_lld_init_endpoint+0x236>
  default:
 8007d64:	bf00      	nop
  }
}
 8007d66:	b006      	add	sp, #24
 8007d68:	bd10      	pop	{r4, pc}
 8007d6a:	bf00      	nop
 8007d6c:	10008000 	.word	0x10008000
 8007d70:	10048000 	.word	0x10048000
 8007d74:	10088000 	.word	0x10088000
 8007d78:	100c8000 	.word	0x100c8000
 8007d7c:	02000400 	.word	0x02000400

08007d80 <usb_lld_disable_endpoints>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_disable_endpoints(USBDriver *usbp) {
 8007d80:	b500      	push	{lr}
 8007d82:	b083      	sub	sp, #12
 8007d84:	9001      	str	r0, [sp, #4]

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 8007d86:	9801      	ldr	r0, [sp, #4]
 8007d88:	f7ff f802 	bl	8006d90 <otg_ram_reset>

  /* Disabling all endpoints.*/
  otg_disable_ep(usbp);
 8007d8c:	9801      	ldr	r0, [sp, #4]
 8007d8e:	f7fe ff7f 	bl	8006c90 <otg_disable_ep>
}
 8007d92:	b003      	add	sp, #12
 8007d94:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08007da0 <usb_lld_get_status_out>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
 8007da0:	b084      	sub	sp, #16
 8007da2:	9001      	str	r0, [sp, #4]
 8007da4:	460b      	mov	r3, r1
 8007da6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 8007daa:	9b01      	ldr	r3, [sp, #4]
 8007dac:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8007dae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007db2:	3358      	adds	r3, #88	; 0x58
 8007db4:	015b      	lsls	r3, r3, #5
 8007db6:	4413      	add	r3, r2
 8007db8:	681b      	ldr	r3, [r3, #0]
 8007dba:	9303      	str	r3, [sp, #12]
  if (!(ctl & DOEPCTL_USBAEP))
 8007dbc:	9b03      	ldr	r3, [sp, #12]
 8007dbe:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8007dc2:	2b00      	cmp	r3, #0
 8007dc4:	d101      	bne.n	8007dca <usb_lld_get_status_out+0x2a>
    return EP_STATUS_DISABLED;
 8007dc6:	2300      	movs	r3, #0
 8007dc8:	e007      	b.n	8007dda <usb_lld_get_status_out+0x3a>
  if (ctl & DOEPCTL_STALL)
 8007dca:	9b03      	ldr	r3, [sp, #12]
 8007dcc:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8007dd0:	2b00      	cmp	r3, #0
 8007dd2:	d001      	beq.n	8007dd8 <usb_lld_get_status_out+0x38>
    return EP_STATUS_STALLED;
 8007dd4:	2301      	movs	r3, #1
 8007dd6:	e000      	b.n	8007dda <usb_lld_get_status_out+0x3a>
  return EP_STATUS_ACTIVE;
 8007dd8:	2302      	movs	r3, #2
}
 8007dda:	4618      	mov	r0, r3
 8007ddc:	b004      	add	sp, #16
 8007dde:	4770      	bx	lr

08007de0 <usb_lld_get_status_in>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
 8007de0:	b084      	sub	sp, #16
 8007de2:	9001      	str	r0, [sp, #4]
 8007de4:	460b      	mov	r3, r1
 8007de6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 8007dea:	9b01      	ldr	r3, [sp, #4]
 8007dec:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8007dee:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007df2:	3348      	adds	r3, #72	; 0x48
 8007df4:	015b      	lsls	r3, r3, #5
 8007df6:	4413      	add	r3, r2
 8007df8:	681b      	ldr	r3, [r3, #0]
 8007dfa:	9303      	str	r3, [sp, #12]
  if (!(ctl & DIEPCTL_USBAEP))
 8007dfc:	9b03      	ldr	r3, [sp, #12]
 8007dfe:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8007e02:	2b00      	cmp	r3, #0
 8007e04:	d101      	bne.n	8007e0a <usb_lld_get_status_in+0x2a>
    return EP_STATUS_DISABLED;
 8007e06:	2300      	movs	r3, #0
 8007e08:	e007      	b.n	8007e1a <usb_lld_get_status_in+0x3a>
  if (ctl & DIEPCTL_STALL)
 8007e0a:	9b03      	ldr	r3, [sp, #12]
 8007e0c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8007e10:	2b00      	cmp	r3, #0
 8007e12:	d001      	beq.n	8007e18 <usb_lld_get_status_in+0x38>
    return EP_STATUS_STALLED;
 8007e14:	2301      	movs	r3, #1
 8007e16:	e000      	b.n	8007e1a <usb_lld_get_status_in+0x3a>
  return EP_STATUS_ACTIVE;
 8007e18:	2302      	movs	r3, #2
}
 8007e1a:	4618      	mov	r0, r3
 8007e1c:	b004      	add	sp, #16
 8007e1e:	4770      	bx	lr

08007e20 <usb_lld_read_setup>:
 * @param[in] ep        endpoint number
 * @param[out] buf      buffer where to copy the packet data
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 8007e20:	b500      	push	{lr}
 8007e22:	b085      	sub	sp, #20
 8007e24:	9003      	str	r0, [sp, #12]
 8007e26:	460b      	mov	r3, r1
 8007e28:	9201      	str	r2, [sp, #4]
 8007e2a:	f88d 300b 	strb.w	r3, [sp, #11]

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8007e2e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8007e32:	9a03      	ldr	r2, [sp, #12]
 8007e34:	3302      	adds	r3, #2
 8007e36:	009b      	lsls	r3, r3, #2
 8007e38:	4413      	add	r3, r2
 8007e3a:	685b      	ldr	r3, [r3, #4]
 8007e3c:	6a1b      	ldr	r3, [r3, #32]
 8007e3e:	2208      	movs	r2, #8
 8007e40:	4619      	mov	r1, r3
 8007e42:	9801      	ldr	r0, [sp, #4]
 8007e44:	f7f8 fa6c 	bl	8000320 <memcpy>
}
 8007e48:	b005      	add	sp, #20
 8007e4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8007e4e:	bf00      	nop

08007e50 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8007e50:	b086      	sub	sp, #24
 8007e52:	9001      	str	r0, [sp, #4]
 8007e54:	460b      	mov	r3, r1
 8007e56:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8007e5a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007e5e:	9a01      	ldr	r2, [sp, #4]
 8007e60:	3302      	adds	r3, #2
 8007e62:	009b      	lsls	r3, r3, #2
 8007e64:	4413      	add	r3, r2
 8007e66:	685b      	ldr	r3, [r3, #4]
 8007e68:	699b      	ldr	r3, [r3, #24]
 8007e6a:	9305      	str	r3, [sp, #20]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 8007e6c:	9b05      	ldr	r3, [sp, #20]
 8007e6e:	681a      	ldr	r2, [r3, #0]
 8007e70:	9b05      	ldr	r3, [sp, #20]
 8007e72:	611a      	str	r2, [r3, #16]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8007e74:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007e78:	2b00      	cmp	r3, #0
 8007e7a:	d106      	bne.n	8007e8a <usb_lld_start_out+0x3a>
 8007e7c:	9b05      	ldr	r3, [sp, #20]
 8007e7e:	681b      	ldr	r3, [r3, #0]
 8007e80:	2b40      	cmp	r3, #64	; 0x40
 8007e82:	d902      	bls.n	8007e8a <usb_lld_start_out+0x3a>
      osp->rxsize = EP0_MAX_OUTSIZE;
 8007e84:	9b05      	ldr	r3, [sp, #20]
 8007e86:	2240      	movs	r2, #64	; 0x40
 8007e88:	601a      	str	r2, [r3, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8007e8a:	9b05      	ldr	r3, [sp, #20]
 8007e8c:	681a      	ldr	r2, [r3, #0]
 8007e8e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007e92:	9901      	ldr	r1, [sp, #4]
 8007e94:	3302      	adds	r3, #2
 8007e96:	009b      	lsls	r3, r3, #2
 8007e98:	440b      	add	r3, r1
 8007e9a:	685b      	ldr	r3, [r3, #4]
 8007e9c:	8a5b      	ldrh	r3, [r3, #18]
 8007e9e:	4413      	add	r3, r2
 8007ea0:	1e5a      	subs	r2, r3, #1
           usbp->epc[ep]->out_maxsize;
 8007ea2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007ea6:	9901      	ldr	r1, [sp, #4]
 8007ea8:	3302      	adds	r3, #2
 8007eaa:	009b      	lsls	r3, r3, #2
 8007eac:	440b      	add	r3, r1
 8007eae:	685b      	ldr	r3, [r3, #4]
 8007eb0:	8a5b      	ldrh	r3, [r3, #18]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8007eb2:	fbb2 f3f3 	udiv	r3, r2, r3
 8007eb6:	9304      	str	r3, [sp, #16]
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8007eb8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007ebc:	9a01      	ldr	r2, [sp, #4]
 8007ebe:	3302      	adds	r3, #2
 8007ec0:	009b      	lsls	r3, r3, #2
 8007ec2:	4413      	add	r3, r2
 8007ec4:	685b      	ldr	r3, [r3, #4]
 8007ec6:	8a5b      	ldrh	r3, [r3, #18]
 8007ec8:	461a      	mov	r2, r3
 8007eca:	9b04      	ldr	r3, [sp, #16]
 8007ecc:	fb03 f302 	mul.w	r3, r3, r2
 8007ed0:	3303      	adds	r3, #3
 8007ed2:	f023 0303 	bic.w	r3, r3, #3
 8007ed6:	9303      	str	r3, [sp, #12]

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8007ed8:	9b04      	ldr	r3, [sp, #16]
 8007eda:	04da      	lsls	r2, r3, #19
 8007edc:	9b03      	ldr	r3, [sp, #12]
 8007ede:	431a      	orrs	r2, r3
 8007ee0:	9b01      	ldr	r3, [sp, #4]
 8007ee2:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8007ee4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007ee8:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 8007eec:	015b      	lsls	r3, r3, #5
 8007eee:	440b      	add	r3, r1
 8007ef0:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8007ef4:	601a      	str	r2, [r3, #0]
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007ef6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007efa:	9a01      	ldr	r2, [sp, #4]
 8007efc:	3302      	adds	r3, #2
 8007efe:	009b      	lsls	r3, r3, #2
 8007f00:	4413      	add	r3, r2
 8007f02:	685b      	ldr	r3, [r3, #4]
 8007f04:	681b      	ldr	r3, [r3, #0]
 8007f06:	f003 0303 	and.w	r3, r3, #3
 8007f0a:	2b01      	cmp	r3, #1
 8007f0c:	d12c      	bne.n	8007f68 <usb_lld_start_out+0x118>
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8007f0e:	9b01      	ldr	r3, [sp, #4]
 8007f10:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8007f12:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8007f16:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8007f1a:	2b00      	cmp	r3, #0
 8007f1c:	d012      	beq.n	8007f44 <usb_lld_start_out+0xf4>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 8007f1e:	9b01      	ldr	r3, [sp, #4]
 8007f20:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8007f22:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007f26:	3358      	adds	r3, #88	; 0x58
 8007f28:	015b      	lsls	r3, r3, #5
 8007f2a:	4413      	add	r3, r2
 8007f2c:	681a      	ldr	r2, [r3, #0]
 8007f2e:	9b01      	ldr	r3, [sp, #4]
 8007f30:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8007f32:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007f36:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8007f3a:	3358      	adds	r3, #88	; 0x58
 8007f3c:	015b      	lsls	r3, r3, #5
 8007f3e:	440b      	add	r3, r1
 8007f40:	601a      	str	r2, [r3, #0]
 8007f42:	e011      	b.n	8007f68 <usb_lld_start_out+0x118>
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8007f44:	9b01      	ldr	r3, [sp, #4]
 8007f46:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8007f48:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007f4c:	3358      	adds	r3, #88	; 0x58
 8007f4e:	015b      	lsls	r3, r3, #5
 8007f50:	4413      	add	r3, r2
 8007f52:	681a      	ldr	r2, [r3, #0]
 8007f54:	9b01      	ldr	r3, [sp, #4]
 8007f56:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8007f58:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007f5c:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8007f60:	3358      	adds	r3, #88	; 0x58
 8007f62:	015b      	lsls	r3, r3, #5
 8007f64:	440b      	add	r3, r1
 8007f66:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8007f68:	9b01      	ldr	r3, [sp, #4]
 8007f6a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8007f6c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007f70:	3358      	adds	r3, #88	; 0x58
 8007f72:	015b      	lsls	r3, r3, #5
 8007f74:	4413      	add	r3, r2
 8007f76:	681a      	ldr	r2, [r3, #0]
 8007f78:	9b01      	ldr	r3, [sp, #4]
 8007f7a:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8007f7c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007f80:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8007f84:	3358      	adds	r3, #88	; 0x58
 8007f86:	015b      	lsls	r3, r3, #5
 8007f88:	440b      	add	r3, r1
 8007f8a:	601a      	str	r2, [r3, #0]
}
 8007f8c:	b006      	add	sp, #24
 8007f8e:	4770      	bx	lr

08007f90 <usb_lld_start_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8007f90:	b084      	sub	sp, #16
 8007f92:	9001      	str	r0, [sp, #4]
 8007f94:	460b      	mov	r3, r1
 8007f96:	f88d 3003 	strb.w	r3, [sp, #3]
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8007f9a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007f9e:	9a01      	ldr	r2, [sp, #4]
 8007fa0:	3302      	adds	r3, #2
 8007fa2:	009b      	lsls	r3, r3, #2
 8007fa4:	4413      	add	r3, r2
 8007fa6:	685b      	ldr	r3, [r3, #4]
 8007fa8:	695b      	ldr	r3, [r3, #20]
 8007faa:	9303      	str	r3, [sp, #12]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 8007fac:	9b03      	ldr	r3, [sp, #12]
 8007fae:	681a      	ldr	r2, [r3, #0]
 8007fb0:	9b03      	ldr	r3, [sp, #12]
 8007fb2:	611a      	str	r2, [r3, #16]
  if (isp->txsize == 0) {
 8007fb4:	9b03      	ldr	r3, [sp, #12]
 8007fb6:	681b      	ldr	r3, [r3, #0]
 8007fb8:	2b00      	cmp	r3, #0
 8007fba:	d10b      	bne.n	8007fd4 <usb_lld_start_in+0x44>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8007fbc:	9b01      	ldr	r3, [sp, #4]
 8007fbe:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8007fc0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007fc4:	015b      	lsls	r3, r3, #5
 8007fc6:	4413      	add	r3, r2
 8007fc8:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8007fcc:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8007fd0:	601a      	str	r2, [r3, #0]
 8007fd2:	e031      	b.n	8008038 <usb_lld_start_in+0xa8>
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8007fd4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007fd8:	2b00      	cmp	r3, #0
 8007fda:	d106      	bne.n	8007fea <usb_lld_start_in+0x5a>
 8007fdc:	9b03      	ldr	r3, [sp, #12]
 8007fde:	681b      	ldr	r3, [r3, #0]
 8007fe0:	2b40      	cmp	r3, #64	; 0x40
 8007fe2:	d902      	bls.n	8007fea <usb_lld_start_in+0x5a>
      isp->txsize = EP0_MAX_INSIZE;
 8007fe4:	9b03      	ldr	r3, [sp, #12]
 8007fe6:	2240      	movs	r2, #64	; 0x40
 8007fe8:	601a      	str	r2, [r3, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8007fea:	9b03      	ldr	r3, [sp, #12]
 8007fec:	681a      	ldr	r2, [r3, #0]
 8007fee:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007ff2:	9901      	ldr	r1, [sp, #4]
 8007ff4:	3302      	adds	r3, #2
 8007ff6:	009b      	lsls	r3, r3, #2
 8007ff8:	440b      	add	r3, r1
 8007ffa:	685b      	ldr	r3, [r3, #4]
 8007ffc:	8a1b      	ldrh	r3, [r3, #16]
 8007ffe:	4413      	add	r3, r2
 8008000:	1e5a      	subs	r2, r3, #1
                    usbp->epc[ep]->in_maxsize;
 8008002:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008006:	9901      	ldr	r1, [sp, #4]
 8008008:	3302      	adds	r3, #2
 800800a:	009b      	lsls	r3, r3, #2
 800800c:	440b      	add	r3, r1
 800800e:	685b      	ldr	r3, [r3, #4]
 8008010:	8a1b      	ldrh	r3, [r3, #16]
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8008012:	fbb2 f3f3 	udiv	r3, r2, r3
 8008016:	9302      	str	r3, [sp, #8]
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8008018:	9b02      	ldr	r3, [sp, #8]
 800801a:	04da      	lsls	r2, r3, #19
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
 800801c:	9b03      	ldr	r3, [sp, #12]
 800801e:	681b      	ldr	r3, [r3, #0]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8008020:	431a      	orrs	r2, r3
 8008022:	9b01      	ldr	r3, [sp, #4]
 8008024:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8008026:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800802a:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800802e:	015b      	lsls	r3, r3, #5
 8008030:	440b      	add	r3, r1
 8008032:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8008036:	601a      	str	r2, [r3, #0]
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8008038:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800803c:	9a01      	ldr	r2, [sp, #4]
 800803e:	3302      	adds	r3, #2
 8008040:	009b      	lsls	r3, r3, #2
 8008042:	4413      	add	r3, r2
 8008044:	685b      	ldr	r3, [r3, #4]
 8008046:	681b      	ldr	r3, [r3, #0]
 8008048:	f003 0303 	and.w	r3, r3, #3
 800804c:	2b01      	cmp	r3, #1
 800804e:	d12c      	bne.n	80080aa <usb_lld_start_in+0x11a>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8008050:	9b01      	ldr	r3, [sp, #4]
 8008052:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008054:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8008058:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800805c:	2b00      	cmp	r3, #0
 800805e:	d012      	beq.n	8008086 <usb_lld_start_in+0xf6>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8008060:	9b01      	ldr	r3, [sp, #4]
 8008062:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8008064:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008068:	3348      	adds	r3, #72	; 0x48
 800806a:	015b      	lsls	r3, r3, #5
 800806c:	4413      	add	r3, r2
 800806e:	681a      	ldr	r2, [r3, #0]
 8008070:	9b01      	ldr	r3, [sp, #4]
 8008072:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8008074:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008078:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800807c:	3348      	adds	r3, #72	; 0x48
 800807e:	015b      	lsls	r3, r3, #5
 8008080:	440b      	add	r3, r1
 8008082:	601a      	str	r2, [r3, #0]
 8008084:	e011      	b.n	80080aa <usb_lld_start_in+0x11a>
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8008086:	9b01      	ldr	r3, [sp, #4]
 8008088:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800808a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800808e:	3348      	adds	r3, #72	; 0x48
 8008090:	015b      	lsls	r3, r3, #5
 8008092:	4413      	add	r3, r2
 8008094:	681a      	ldr	r2, [r3, #0]
 8008096:	9b01      	ldr	r3, [sp, #4]
 8008098:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800809a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800809e:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80080a2:	3348      	adds	r3, #72	; 0x48
 80080a4:	015b      	lsls	r3, r3, #5
 80080a6:	440b      	add	r3, r1
 80080a8:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80080aa:	9b01      	ldr	r3, [sp, #4]
 80080ac:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80080ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80080b2:	3348      	adds	r3, #72	; 0x48
 80080b4:	015b      	lsls	r3, r3, #5
 80080b6:	4413      	add	r3, r2
 80080b8:	681a      	ldr	r2, [r3, #0]
 80080ba:	9b01      	ldr	r3, [sp, #4]
 80080bc:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80080be:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80080c2:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80080c6:	3348      	adds	r3, #72	; 0x48
 80080c8:	015b      	lsls	r3, r3, #5
 80080ca:	440b      	add	r3, r1
 80080cc:	601a      	str	r2, [r3, #0]
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80080ce:	9b01      	ldr	r3, [sp, #4]
 80080d0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80080d2:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
 80080d6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80080da:	2201      	movs	r2, #1
 80080dc:	409a      	lsls	r2, r3
 80080de:	9b01      	ldr	r3, [sp, #4]
 80080e0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80080e2:	430a      	orrs	r2, r1
 80080e4:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 80080e8:	b004      	add	sp, #16
 80080ea:	4770      	bx	lr
 80080ec:	0000      	movs	r0, r0
	...

080080f0 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 80080f0:	b082      	sub	sp, #8
 80080f2:	9001      	str	r0, [sp, #4]
 80080f4:	460b      	mov	r3, r1
 80080f6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80080fa:	9b01      	ldr	r3, [sp, #4]
 80080fc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80080fe:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008102:	3358      	adds	r3, #88	; 0x58
 8008104:	015b      	lsls	r3, r3, #5
 8008106:	4413      	add	r3, r2
 8008108:	681a      	ldr	r2, [r3, #0]
 800810a:	9b01      	ldr	r3, [sp, #4]
 800810c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800810e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008112:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8008116:	3358      	adds	r3, #88	; 0x58
 8008118:	015b      	lsls	r3, r3, #5
 800811a:	440b      	add	r3, r1
 800811c:	601a      	str	r2, [r3, #0]
}
 800811e:	b002      	add	sp, #8
 8008120:	4770      	bx	lr
 8008122:	bf00      	nop
	...

08008130 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 8008130:	b082      	sub	sp, #8
 8008132:	9001      	str	r0, [sp, #4]
 8008134:	460b      	mov	r3, r1
 8008136:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800813a:	9b01      	ldr	r3, [sp, #4]
 800813c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800813e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008142:	3348      	adds	r3, #72	; 0x48
 8008144:	015b      	lsls	r3, r3, #5
 8008146:	4413      	add	r3, r2
 8008148:	681a      	ldr	r2, [r3, #0]
 800814a:	9b01      	ldr	r3, [sp, #4]
 800814c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800814e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008152:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8008156:	3348      	adds	r3, #72	; 0x48
 8008158:	015b      	lsls	r3, r3, #5
 800815a:	440b      	add	r3, r1
 800815c:	601a      	str	r2, [r3, #0]
}
 800815e:	b002      	add	sp, #8
 8008160:	4770      	bx	lr
 8008162:	bf00      	nop
	...

08008170 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8008170:	b082      	sub	sp, #8
 8008172:	9001      	str	r0, [sp, #4]
 8008174:	460b      	mov	r3, r1
 8008176:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 800817a:	9b01      	ldr	r3, [sp, #4]
 800817c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800817e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008182:	3358      	adds	r3, #88	; 0x58
 8008184:	015b      	lsls	r3, r3, #5
 8008186:	4413      	add	r3, r2
 8008188:	681a      	ldr	r2, [r3, #0]
 800818a:	9b01      	ldr	r3, [sp, #4]
 800818c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800818e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008192:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8008196:	3358      	adds	r3, #88	; 0x58
 8008198:	015b      	lsls	r3, r3, #5
 800819a:	440b      	add	r3, r1
 800819c:	601a      	str	r2, [r3, #0]
}
 800819e:	b002      	add	sp, #8
 80081a0:	4770      	bx	lr
 80081a2:	bf00      	nop
	...

080081b0 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 80081b0:	b082      	sub	sp, #8
 80081b2:	9001      	str	r0, [sp, #4]
 80081b4:	460b      	mov	r3, r1
 80081b6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 80081ba:	9b01      	ldr	r3, [sp, #4]
 80081bc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80081be:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80081c2:	3348      	adds	r3, #72	; 0x48
 80081c4:	015b      	lsls	r3, r3, #5
 80081c6:	4413      	add	r3, r2
 80081c8:	681a      	ldr	r2, [r3, #0]
 80081ca:	9b01      	ldr	r3, [sp, #4]
 80081cc:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80081ce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80081d2:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80081d6:	3348      	adds	r3, #72	; 0x48
 80081d8:	015b      	lsls	r3, r3, #5
 80081da:	440b      	add	r3, r1
 80081dc:	601a      	str	r2, [r3, #0]
}
 80081de:	b002      	add	sp, #8
 80081e0:	4770      	bx	lr
 80081e2:	bf00      	nop
	...

080081f0 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 80081f0:	b500      	push	{lr}
 80081f2:	b089      	sub	sp, #36	; 0x24
 80081f4:	9001      	str	r0, [sp, #4]
  USBDriver *usbp = (USBDriver *)p;
 80081f6:	9b01      	ldr	r3, [sp, #4]
 80081f8:	9306      	str	r3, [sp, #24]
  stm32_otg_t *otgp = usbp->otg;
 80081fa:	9b06      	ldr	r3, [sp, #24]
 80081fc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80081fe:	9305      	str	r3, [sp, #20]

#if defined(_CHIBIOS_RT_)
  chRegSetThreadName("usb_lld_pump");
 8008200:	483d      	ldr	r0, [pc, #244]	; (80082f8 <usb_lld_pump+0x108>)
 8008202:	f7fe fcc5 	bl	8006b90 <chRegSetThreadName.lto_priv.1>
#endif
  osalSysLock();
 8008206:	f7fe fcd3 	bl	8006bb0 <osalSysLock.lto_priv.235>
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 800820a:	9b06      	ldr	r3, [sp, #24]
 800820c:	781b      	ldrb	r3, [r3, #0]
 800820e:	2b01      	cmp	r3, #1
 8008210:	d009      	beq.n	8008226 <usb_lld_pump+0x36>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 8008212:	9b06      	ldr	r3, [sp, #24]
 8008214:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    if ((usbp->state == USB_STOP) ||
 8008216:	2b00      	cmp	r3, #0
 8008218:	d110      	bne.n	800823c <usb_lld_pump+0x4c>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 800821a:	9b05      	ldr	r3, [sp, #20]
 800821c:	695b      	ldr	r3, [r3, #20]
 800821e:	f003 0310 	and.w	r3, r3, #16
 8008222:	2b00      	cmp	r3, #0
 8008224:	d10a      	bne.n	800823c <usb_lld_pump+0x4c>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 8008226:	9b05      	ldr	r3, [sp, #20]
 8008228:	699b      	ldr	r3, [r3, #24]
 800822a:	f043 0210 	orr.w	r2, r3, #16
 800822e:	9b05      	ldr	r3, [sp, #20]
 8008230:	619a      	str	r2, [r3, #24]
      osalThreadSuspendS(&usbp->wait);
 8008232:	9b06      	ldr	r3, [sp, #24]
 8008234:	337c      	adds	r3, #124	; 0x7c
 8008236:	4618      	mov	r0, r3
 8008238:	f7fe fcea 	bl	8006c10 <osalThreadSuspendS.lto_priv.215>
    }
    osalSysUnlock();
 800823c:	f7fe fcc0 	bl	8006bc0 <osalSysUnlock.lto_priv.226>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008240:	2300      	movs	r3, #0
 8008242:	f88d 301f 	strb.w	r3, [sp, #31]
 8008246:	e04c      	b.n	80082e2 <usb_lld_pump+0xf2>

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
 8008248:	9806      	ldr	r0, [sp, #24]
 800824a:	f7fe fe19 	bl	8006e80 <otg_rxfifo_handler>
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 800824e:	9b05      	ldr	r3, [sp, #20]
 8008250:	695b      	ldr	r3, [r3, #20]
 8008252:	f003 0310 	and.w	r3, r3, #16
 8008256:	2b00      	cmp	r3, #0
 8008258:	d1f6      	bne.n	8008248 <usb_lld_pump+0x58>
      }

      epmask = (1 << ep);
 800825a:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800825e:	2201      	movs	r2, #1
 8008260:	fa02 f303 	lsl.w	r3, r2, r3
 8008264:	9304      	str	r3, [sp, #16]
      if (usbp->txpending & epmask) {
 8008266:	9b06      	ldr	r3, [sp, #24]
 8008268:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800826a:	9b04      	ldr	r3, [sp, #16]
 800826c:	4013      	ands	r3, r2
 800826e:	2b00      	cmp	r3, #0
 8008270:	d032      	beq.n	80082d8 <usb_lld_pump+0xe8>
        bool done;

        osalSysLock();
 8008272:	f7fe fc9d 	bl	8006bb0 <osalSysLock.lto_priv.235>
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8008276:	9b05      	ldr	r3, [sp, #20]
 8008278:	689b      	ldr	r3, [r3, #8]
 800827a:	f023 0201 	bic.w	r2, r3, #1
 800827e:	9b05      	ldr	r3, [sp, #20]
 8008280:	609a      	str	r2, [r3, #8]
        usbp->txpending &= ~epmask;
 8008282:	9b06      	ldr	r3, [sp, #24]
 8008284:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8008286:	9b04      	ldr	r3, [sp, #16]
 8008288:	43db      	mvns	r3, r3
 800828a:	401a      	ands	r2, r3
 800828c:	9b06      	ldr	r3, [sp, #24]
 800828e:	679a      	str	r2, [r3, #120]	; 0x78
        osalSysUnlock();
 8008290:	f7fe fc96 	bl	8006bc0 <osalSysUnlock.lto_priv.226>

        done = otg_txfifo_handler(usbp, ep);
 8008294:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8008298:	4619      	mov	r1, r3
 800829a:	9806      	ldr	r0, [sp, #24]
 800829c:	f7fe fe78 	bl	8006f90 <otg_txfifo_handler>
 80082a0:	4603      	mov	r3, r0
 80082a2:	f88d 300f 	strb.w	r3, [sp, #15]

        osalSysLock();
 80082a6:	f7fe fc83 	bl	8006bb0 <osalSysLock.lto_priv.235>
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 80082aa:	9b05      	ldr	r3, [sp, #20]
 80082ac:	689b      	ldr	r3, [r3, #8]
 80082ae:	f043 0201 	orr.w	r2, r3, #1
 80082b2:	9b05      	ldr	r3, [sp, #20]
 80082b4:	609a      	str	r2, [r3, #8]
        if (!done)
 80082b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80082ba:	f083 0301 	eor.w	r3, r3, #1
 80082be:	b2db      	uxtb	r3, r3
 80082c0:	2b00      	cmp	r3, #0
 80082c2:	d007      	beq.n	80082d4 <usb_lld_pump+0xe4>
          otgp->DIEPEMPMSK |= epmask;
 80082c4:	9b05      	ldr	r3, [sp, #20]
 80082c6:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 80082ca:	9b04      	ldr	r3, [sp, #16]
 80082cc:	431a      	orrs	r2, r3
 80082ce:	9b05      	ldr	r3, [sp, #20]
 80082d0:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
        osalSysUnlock();
 80082d4:	f7fe fc74 	bl	8006bc0 <osalSysUnlock.lto_priv.226>
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80082d8:	f89d 301f 	ldrb.w	r3, [sp, #31]
 80082dc:	3301      	adds	r3, #1
 80082de:	f88d 301f 	strb.w	r3, [sp, #31]
 80082e2:	f89d 201f 	ldrb.w	r2, [sp, #31]
 80082e6:	9b06      	ldr	r3, [sp, #24]
 80082e8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80082ea:	689b      	ldr	r3, [r3, #8]
 80082ec:	429a      	cmp	r2, r3
 80082ee:	d9ae      	bls.n	800824e <usb_lld_pump+0x5e>
      }
    }
    osalSysLock();
 80082f0:	f7fe fc5e 	bl	8006bb0 <osalSysLock.lto_priv.235>
 80082f4:	e789      	b.n	800820a <usb_lld_pump+0x1a>
 80082f6:	bf00      	nop
 80082f8:	0800abd0 	.word	0x0800abd0
 80082fc:	00000000 	.word	0x00000000

08008300 <port_lock.lto_priv.128>:
static inline void port_lock(void) {
 8008300:	b082      	sub	sp, #8
 8008302:	2320      	movs	r3, #32
 8008304:	9301      	str	r3, [sp, #4]
 8008306:	9b01      	ldr	r3, [sp, #4]
 8008308:	f383 8811 	msr	BASEPRI, r3
}
 800830c:	b002      	add	sp, #8
 800830e:	4770      	bx	lr

08008310 <port_unlock.lto_priv.98>:
static inline void port_unlock(void) {
 8008310:	b082      	sub	sp, #8
 8008312:	2300      	movs	r3, #0
 8008314:	9301      	str	r3, [sp, #4]
 8008316:	9b01      	ldr	r3, [sp, #4]
 8008318:	f383 8811 	msr	BASEPRI, r3
}
 800831c:	b002      	add	sp, #8
 800831e:	4770      	bx	lr

08008320 <port_lock_from_isr.lto_priv.191>:
static inline void port_lock_from_isr(void) {
 8008320:	b508      	push	{r3, lr}
  port_lock();
 8008322:	f7ff ffed 	bl	8008300 <port_lock.lto_priv.128>
}
 8008326:	bd08      	pop	{r3, pc}
	...

08008330 <port_unlock_from_isr.lto_priv.178>:
static inline void port_unlock_from_isr(void) {
 8008330:	b508      	push	{r3, lr}
  port_unlock();
 8008332:	f7ff ffed 	bl	8008310 <port_unlock.lto_priv.98>
}
 8008336:	bd08      	pop	{r3, pc}
	...

08008340 <chSysLock.lto_priv.70>:
static inline void chSysLock(void) {
 8008340:	b508      	push	{r3, lr}
  port_lock();
 8008342:	f7ff ffdd 	bl	8008300 <port_lock.lto_priv.128>
  _stats_start_measure_crit_thd();
 8008346:	f7f9 facb 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800834a:	f7f8 fae9 	bl	8000920 <_dbg_check_lock>
}
 800834e:	bd08      	pop	{r3, pc}

08008350 <chSysUnlock.lto_priv.29>:
static inline void chSysUnlock(void) {
 8008350:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8008352:	f7f8 fafd 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8008356:	f7f9 facb 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800835a:	4b09      	ldr	r3, [pc, #36]	; (8008380 <chSysUnlock.lto_priv.29+0x30>)
 800835c:	681b      	ldr	r3, [r3, #0]
 800835e:	4a08      	ldr	r2, [pc, #32]	; (8008380 <chSysUnlock.lto_priv.29+0x30>)
 8008360:	4293      	cmp	r3, r2
 8008362:	d00a      	beq.n	800837a <chSysUnlock.lto_priv.29+0x2a>
 8008364:	4b06      	ldr	r3, [pc, #24]	; (8008380 <chSysUnlock.lto_priv.29+0x30>)
 8008366:	699b      	ldr	r3, [r3, #24]
 8008368:	689a      	ldr	r2, [r3, #8]
 800836a:	4b05      	ldr	r3, [pc, #20]	; (8008380 <chSysUnlock.lto_priv.29+0x30>)
 800836c:	681b      	ldr	r3, [r3, #0]
 800836e:	689b      	ldr	r3, [r3, #8]
 8008370:	429a      	cmp	r2, r3
 8008372:	d202      	bcs.n	800837a <chSysUnlock.lto_priv.29+0x2a>
 8008374:	4803      	ldr	r0, [pc, #12]	; (8008384 <chSysUnlock.lto_priv.29+0x34>)
 8008376:	f7f8 fa4b 	bl	8000810 <chSysHalt>
  port_unlock();
 800837a:	f7ff ffc9 	bl	8008310 <port_unlock.lto_priv.98>
}
 800837e:	bd08      	pop	{r3, pc}
 8008380:	20002128 	.word	0x20002128
 8008384:	0800ac50 	.word	0x0800ac50
	...

08008390 <chSysLockFromISR.lto_priv.165>:
static inline void chSysLockFromISR(void) {
 8008390:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8008392:	f7ff ffc5 	bl	8008320 <port_lock_from_isr.lto_priv.191>
  _stats_start_measure_crit_isr();
 8008396:	f7f9 fab3 	bl	8001900 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800839a:	f7f8 faf1 	bl	8000980 <_dbg_check_lock_from_isr>
}
 800839e:	bd08      	pop	{r3, pc}

080083a0 <chSysUnlockFromISR.lto_priv.155>:
static inline void chSysUnlockFromISR(void) {
 80083a0:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 80083a2:	f7f8 fb05 	bl	80009b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80083a6:	f7f9 fab3 	bl	8001910 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 80083aa:	f7ff ffc1 	bl	8008330 <port_unlock_from_isr.lto_priv.178>
}
 80083ae:	bd08      	pop	{r3, pc}

080083b0 <osalSysLock.lto_priv.236>:
static inline void osalSysLock(void) {
 80083b0:	b508      	push	{r3, lr}
  chSysLock();
 80083b2:	f7ff ffc5 	bl	8008340 <chSysLock.lto_priv.70>
}
 80083b6:	bd08      	pop	{r3, pc}
	...

080083c0 <osalSysUnlock.lto_priv.227>:
static inline void osalSysUnlock(void) {
 80083c0:	b508      	push	{r3, lr}
  chSysUnlock();
 80083c2:	f7ff ffc5 	bl	8008350 <chSysUnlock.lto_priv.29>
}
 80083c6:	bd08      	pop	{r3, pc}
	...

080083d0 <osalSysLockFromISR.lto_priv.145>:
static inline void osalSysLockFromISR(void) {
 80083d0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 80083d2:	f7ff ffdd 	bl	8008390 <chSysLockFromISR.lto_priv.165>
}
 80083d6:	bd08      	pop	{r3, pc}
	...

080083e0 <osalSysUnlockFromISR.lto_priv.137>:
static inline void osalSysUnlockFromISR(void) {
 80083e0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 80083e2:	f7ff ffdd 	bl	80083a0 <chSysUnlockFromISR.lto_priv.155>
}
 80083e6:	bd08      	pop	{r3, pc}
	...

080083f0 <osalThreadSleep.lto_priv.218>:
static inline void osalThreadSleep(systime_t time) {
 80083f0:	b500      	push	{lr}
 80083f2:	b083      	sub	sp, #12
 80083f4:	9001      	str	r0, [sp, #4]
  chThdSleep(time);
 80083f6:	9801      	ldr	r0, [sp, #4]
 80083f8:	f7f9 f84a 	bl	8001490 <chThdSleep>
}
 80083fc:	b003      	add	sp, #12
 80083fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8008402:	bf00      	nop
	...

08008410 <osalThreadSuspendS.lto_priv.216>:
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8008410:	b500      	push	{lr}
 8008412:	b083      	sub	sp, #12
 8008414:	9001      	str	r0, [sp, #4]
  return chThdSuspendS(trp);
 8008416:	9801      	ldr	r0, [sp, #4]
 8008418:	f7f9 f89a 	bl	8001550 <chThdSuspendS>
 800841c:	4603      	mov	r3, r0
}
 800841e:	4618      	mov	r0, r3
 8008420:	b003      	add	sp, #12
 8008422:	f85d fb04 	ldr.w	pc, [sp], #4
 8008426:	bf00      	nop
	...

08008430 <osalThreadResumeI.lto_priv.213>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8008430:	b500      	push	{lr}
 8008432:	b083      	sub	sp, #12
 8008434:	9001      	str	r0, [sp, #4]
 8008436:	9100      	str	r1, [sp, #0]
  chThdResumeI(trp, msg);
 8008438:	9900      	ldr	r1, [sp, #0]
 800843a:	9801      	ldr	r0, [sp, #4]
 800843c:	f7f9 f8a8 	bl	8001590 <chThdResumeI>
}
 8008440:	b003      	add	sp, #12
 8008442:	f85d fb04 	ldr.w	pc, [sp], #4
 8008446:	bf00      	nop
	...

08008450 <sdc_lld_prepare_read_bytes>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_read_bytes(SDCDriver *sdcp,
                                       uint8_t *buf, uint32_t bytes) {
 8008450:	b500      	push	{lr}
 8008452:	b085      	sub	sp, #20
 8008454:	9003      	str	r0, [sp, #12]
 8008456:	9102      	str	r1, [sp, #8]
 8008458:	9201      	str	r2, [sp, #4]
  osalDbgCheck(bytes < 0x1000000);
 800845a:	9b01      	ldr	r3, [sp, #4]
 800845c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8008460:	d302      	bcc.n	8008468 <sdc_lld_prepare_read_bytes+0x18>
 8008462:	4820      	ldr	r0, [pc, #128]	; (80084e4 <sdc_lld_prepare_read_bytes+0x94>)
 8008464:	f7f8 f9d4 	bl	8000810 <chSysHalt>

  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;
 8008468:	9b03      	ldr	r3, [sp, #12]
 800846a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800846c:	4a1e      	ldr	r2, [pc, #120]	; (80084e8 <sdc_lld_prepare_read_bytes+0x98>)
 800846e:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 8008470:	9803      	ldr	r0, [sp, #12]
 8008472:	f7fb fc95 	bl	8003da0 <_sdc_wait_for_transfer_state>
 8008476:	4603      	mov	r3, r0
 8008478:	2b00      	cmp	r3, #0
 800847a:	d001      	beq.n	8008480 <sdc_lld_prepare_read_bytes+0x30>
    return HAL_FAILED;
 800847c:	2301      	movs	r3, #1
 800847e:	e02c      	b.n	80084da <sdc_lld_prepare_read_bytes+0x8a>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 8008480:	9b03      	ldr	r3, [sp, #12]
 8008482:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008484:	681b      	ldr	r3, [r3, #0]
 8008486:	9a02      	ldr	r2, [sp, #8]
 8008488:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
 800848a:	9b03      	ldr	r3, [sp, #12]
 800848c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800848e:	681b      	ldr	r3, [r3, #0]
 8008490:	9a01      	ldr	r2, [sp, #4]
 8008492:	0892      	lsrs	r2, r2, #2
 8008494:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 8008496:	9b03      	ldr	r3, [sp, #12]
 8008498:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800849a:	681b      	ldr	r3, [r3, #0]
 800849c:	9a03      	ldr	r2, [sp, #12]
 800849e:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80084a0:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 80084a2:	9b03      	ldr	r3, [sp, #12]
 80084a4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80084a6:	681b      	ldr	r3, [r3, #0]
 80084a8:	681a      	ldr	r2, [r3, #0]
 80084aa:	9b03      	ldr	r3, [sp, #12]
 80084ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80084ae:	681b      	ldr	r3, [r3, #0]
 80084b0:	f042 0201 	orr.w	r2, r2, #1
 80084b4:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 80084b6:	9b03      	ldr	r3, [sp, #12]
 80084b8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80084ba:	4a0c      	ldr	r2, [pc, #48]	; (80084ec <sdc_lld_prepare_read_bytes+0x9c>)
 80084bc:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 80084be:	9b03      	ldr	r3, [sp, #12]
 80084c0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80084c2:	f240 322a 	movw	r2, #810	; 0x32a
 80084c6:	63da      	str	r2, [r3, #60]	; 0x3c
                      SDIO_MASK_DTIMEOUTIE |
                      SDIO_MASK_STBITERRIE |
                      SDIO_MASK_RXOVERRIE |
                      SDIO_MASK_DATAENDIE;
  sdcp->sdio->DLEN  = bytes;
 80084c8:	9b03      	ldr	r3, [sp, #12]
 80084ca:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80084cc:	9a01      	ldr	r2, [sp, #4]
 80084ce:	629a      	str	r2, [r3, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdio->DCTRL = SDIO_DCTRL_DTDIR |
 80084d0:	9b03      	ldr	r3, [sp, #12]
 80084d2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80084d4:	220f      	movs	r2, #15
 80084d6:	62da      	str	r2, [r3, #44]	; 0x2c
                      SDIO_DCTRL_DTMODE |   /* multibyte data transfer */
                      SDIO_DCTRL_DMAEN |
                      SDIO_DCTRL_DTEN;

  return HAL_SUCCESS;
 80084d8:	2300      	movs	r3, #0
}
 80084da:	4618      	mov	r0, r3
 80084dc:	b005      	add	sp, #20
 80084de:	f85d fb04 	ldr.w	pc, [sp], #4
 80084e2:	bf00      	nop
 80084e4:	0800ac30 	.word	0x0800ac30
 80084e8:	000927c0 	.word	0x000927c0
 80084ec:	00c007ff 	.word	0x00c007ff

080084f0 <sdc_lld_prepare_read>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_read(SDCDriver *sdcp, uint32_t startblk,
                                 uint32_t n, uint32_t *resp) {
 80084f0:	b500      	push	{lr}
 80084f2:	b085      	sub	sp, #20
 80084f4:	9003      	str	r0, [sp, #12]
 80084f6:	9102      	str	r1, [sp, #8]
 80084f8:	9201      	str	r2, [sp, #4]
 80084fa:	9300      	str	r3, [sp, #0]

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 80084fc:	9b03      	ldr	r3, [sp, #12]
 80084fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008500:	f003 0310 	and.w	r3, r3, #16
 8008504:	2b00      	cmp	r3, #0
 8008506:	d102      	bne.n	800850e <sdc_lld_prepare_read+0x1e>
    startblk *= MMCSD_BLOCK_SIZE;
 8008508:	9b02      	ldr	r3, [sp, #8]
 800850a:	025b      	lsls	r3, r3, #9
 800850c:	9302      	str	r3, [sp, #8]

  if (n > 1) {
 800850e:	9b01      	ldr	r3, [sp, #4]
 8008510:	2b01      	cmp	r3, #1
 8008512:	d910      	bls.n	8008536 <sdc_lld_prepare_read+0x46>
    /* Send read multiple blocks command to card.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 8008514:	9b00      	ldr	r3, [sp, #0]
 8008516:	9a02      	ldr	r2, [sp, #8]
 8008518:	2112      	movs	r1, #18
 800851a:	9803      	ldr	r0, [sp, #12]
 800851c:	f000 fa58 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8008520:	4603      	mov	r3, r0
 8008522:	2b00      	cmp	r3, #0
 8008524:	d105      	bne.n	8008532 <sdc_lld_prepare_read+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8008526:	9b00      	ldr	r3, [sp, #0]
 8008528:	681a      	ldr	r2, [r3, #0]
 800852a:	4b0e      	ldr	r3, [pc, #56]	; (8008564 <sdc_lld_prepare_read+0x74>)
 800852c:	4013      	ands	r3, r2
 800852e:	2b00      	cmp	r3, #0
 8008530:	d012      	beq.n	8008558 <sdc_lld_prepare_read+0x68>
      return HAL_FAILED;
 8008532:	2301      	movs	r3, #1
 8008534:	e011      	b.n	800855a <sdc_lld_prepare_read+0x6a>
  }
  else {
    /* Send read single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_SINGLE_BLOCK,
 8008536:	9b00      	ldr	r3, [sp, #0]
 8008538:	9a02      	ldr	r2, [sp, #8]
 800853a:	2111      	movs	r1, #17
 800853c:	9803      	ldr	r0, [sp, #12]
 800853e:	f000 fa47 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8008542:	4603      	mov	r3, r0
 8008544:	2b00      	cmp	r3, #0
 8008546:	d105      	bne.n	8008554 <sdc_lld_prepare_read+0x64>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8008548:	9b00      	ldr	r3, [sp, #0]
 800854a:	681a      	ldr	r2, [r3, #0]
 800854c:	4b05      	ldr	r3, [pc, #20]	; (8008564 <sdc_lld_prepare_read+0x74>)
 800854e:	4013      	ands	r3, r2
 8008550:	2b00      	cmp	r3, #0
 8008552:	d001      	beq.n	8008558 <sdc_lld_prepare_read+0x68>
      return HAL_FAILED;
 8008554:	2301      	movs	r3, #1
 8008556:	e000      	b.n	800855a <sdc_lld_prepare_read+0x6a>
  }

  return HAL_SUCCESS;
 8008558:	2300      	movs	r3, #0
}
 800855a:	4618      	mov	r0, r3
 800855c:	b005      	add	sp, #20
 800855e:	f85d fb04 	ldr.w	pc, [sp], #4
 8008562:	bf00      	nop
 8008564:	fdffe008 	.word	0xfdffe008
	...

08008570 <sdc_lld_prepare_write>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_write(SDCDriver *sdcp, uint32_t startblk,
                                  uint32_t n, uint32_t *resp) {
 8008570:	b500      	push	{lr}
 8008572:	b085      	sub	sp, #20
 8008574:	9003      	str	r0, [sp, #12]
 8008576:	9102      	str	r1, [sp, #8]
 8008578:	9201      	str	r2, [sp, #4]
 800857a:	9300      	str	r3, [sp, #0]

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 800857c:	9b03      	ldr	r3, [sp, #12]
 800857e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008580:	f003 0310 	and.w	r3, r3, #16
 8008584:	2b00      	cmp	r3, #0
 8008586:	d102      	bne.n	800858e <sdc_lld_prepare_write+0x1e>
    startblk *= MMCSD_BLOCK_SIZE;
 8008588:	9b02      	ldr	r3, [sp, #8]
 800858a:	025b      	lsls	r3, r3, #9
 800858c:	9302      	str	r3, [sp, #8]

  if (n > 1) {
 800858e:	9b01      	ldr	r3, [sp, #4]
 8008590:	2b01      	cmp	r3, #1
 8008592:	d910      	bls.n	80085b6 <sdc_lld_prepare_write+0x46>
    /* Write multiple blocks command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 8008594:	9b00      	ldr	r3, [sp, #0]
 8008596:	9a02      	ldr	r2, [sp, #8]
 8008598:	2119      	movs	r1, #25
 800859a:	9803      	ldr	r0, [sp, #12]
 800859c:	f000 fa18 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 80085a0:	4603      	mov	r3, r0
 80085a2:	2b00      	cmp	r3, #0
 80085a4:	d105      	bne.n	80085b2 <sdc_lld_prepare_write+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 80085a6:	9b00      	ldr	r3, [sp, #0]
 80085a8:	681a      	ldr	r2, [r3, #0]
 80085aa:	4b0e      	ldr	r3, [pc, #56]	; (80085e4 <sdc_lld_prepare_write+0x74>)
 80085ac:	4013      	ands	r3, r2
 80085ae:	2b00      	cmp	r3, #0
 80085b0:	d012      	beq.n	80085d8 <sdc_lld_prepare_write+0x68>
      return HAL_FAILED;
 80085b2:	2301      	movs	r3, #1
 80085b4:	e011      	b.n	80085da <sdc_lld_prepare_write+0x6a>
  }
  else {
    /* Write single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_BLOCK,
 80085b6:	9b00      	ldr	r3, [sp, #0]
 80085b8:	9a02      	ldr	r2, [sp, #8]
 80085ba:	2118      	movs	r1, #24
 80085bc:	9803      	ldr	r0, [sp, #12]
 80085be:	f000 fa07 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 80085c2:	4603      	mov	r3, r0
 80085c4:	2b00      	cmp	r3, #0
 80085c6:	d105      	bne.n	80085d4 <sdc_lld_prepare_write+0x64>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 80085c8:	9b00      	ldr	r3, [sp, #0]
 80085ca:	681a      	ldr	r2, [r3, #0]
 80085cc:	4b05      	ldr	r3, [pc, #20]	; (80085e4 <sdc_lld_prepare_write+0x74>)
 80085ce:	4013      	ands	r3, r2
 80085d0:	2b00      	cmp	r3, #0
 80085d2:	d001      	beq.n	80085d8 <sdc_lld_prepare_write+0x68>
      return HAL_FAILED;
 80085d4:	2301      	movs	r3, #1
 80085d6:	e000      	b.n	80085da <sdc_lld_prepare_write+0x6a>
  }

  return HAL_SUCCESS;
 80085d8:	2300      	movs	r3, #0
}
 80085da:	4618      	mov	r0, r3
 80085dc:	b005      	add	sp, #20
 80085de:	f85d fb04 	ldr.w	pc, [sp], #4
 80085e2:	bf00      	nop
 80085e4:	fdffe008 	.word	0xfdffe008
	...

080085f0 <sdc_lld_wait_transaction_end>:
 * @return              The operation status.
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 */
static bool sdc_lld_wait_transaction_end(SDCDriver *sdcp, uint32_t n,
                                         uint32_t *resp) {
 80085f0:	b500      	push	{lr}
 80085f2:	b085      	sub	sp, #20
 80085f4:	9003      	str	r0, [sp, #12]
 80085f6:	9102      	str	r1, [sp, #8]
 80085f8:	9201      	str	r2, [sp, #4]

  /* Note the mask is checked before going to sleep because the interrupt
     may have occurred before reaching the critical zone.*/
  osalSysLock();
 80085fa:	f7ff fed9 	bl	80083b0 <osalSysLock.lto_priv.236>
  if (sdcp->sdio->MASK != 0)
 80085fe:	9b03      	ldr	r3, [sp, #12]
 8008600:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008602:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8008604:	2b00      	cmp	r3, #0
 8008606:	d004      	beq.n	8008612 <sdc_lld_wait_transaction_end+0x22>
    osalThreadSuspendS(&sdcp->thread);
 8008608:	9b03      	ldr	r3, [sp, #12]
 800860a:	333c      	adds	r3, #60	; 0x3c
 800860c:	4618      	mov	r0, r3
 800860e:	f7ff feff 	bl	8008410 <osalThreadSuspendS.lto_priv.216>
  if ((sdcp->sdio->STA & SDIO_STA_DATAEND) == 0) {
 8008612:	9b03      	ldr	r3, [sp, #12]
 8008614:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008616:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008618:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800861c:	2b00      	cmp	r3, #0
 800861e:	d103      	bne.n	8008628 <sdc_lld_wait_transaction_end+0x38>
    osalSysUnlock();
 8008620:	f7ff fece 	bl	80083c0 <osalSysUnlock.lto_priv.227>
    return HAL_FAILED;
 8008624:	2301      	movs	r3, #1
 8008626:	e027      	b.n	8008678 <sdc_lld_wait_transaction_end+0x88>
  }

#if (defined(STM32F4XX) || defined(STM32F2XX))
  /* Wait until DMA channel enabled to be sure that all data transferred.*/
  while (sdcp->dma->stream->CR & STM32_DMA_CR_EN)
 8008628:	9b03      	ldr	r3, [sp, #12]
 800862a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800862c:	681b      	ldr	r3, [r3, #0]
 800862e:	681b      	ldr	r3, [r3, #0]
 8008630:	f003 0301 	and.w	r3, r3, #1
 8008634:	2b00      	cmp	r3, #0
 8008636:	d1f7      	bne.n	8008628 <sdc_lld_wait_transaction_end+0x38>
    ;

  /* DMA event flags must be manually cleared.*/
  dmaStreamClearInterrupt(sdcp->dma);
 8008638:	9b03      	ldr	r3, [sp, #12]
 800863a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800863c:	7a1b      	ldrb	r3, [r3, #8]
 800863e:	4619      	mov	r1, r3
 8008640:	9b03      	ldr	r3, [sp, #12]
 8008642:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008644:	685b      	ldr	r3, [r3, #4]
 8008646:	223d      	movs	r2, #61	; 0x3d
 8008648:	408a      	lsls	r2, r1
 800864a:	601a      	str	r2, [r3, #0]

  sdcp->sdio->ICR = STM32_SDIO_ICR_ALL_FLAGS;
 800864c:	9b03      	ldr	r3, [sp, #12]
 800864e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008650:	4a0b      	ldr	r2, [pc, #44]	; (8008680 <sdc_lld_wait_transaction_end+0x90>)
 8008652:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdio->DCTRL = 0;
 8008654:	9b03      	ldr	r3, [sp, #12]
 8008656:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008658:	2200      	movs	r2, #0
 800865a:	62da      	str	r2, [r3, #44]	; 0x2c
  osalSysUnlock();
 800865c:	f7ff feb0 	bl	80083c0 <osalSysUnlock.lto_priv.227>
  sdcp->sdio->DCTRL = 0;
  osalSysUnlock();
#endif

  /* Finalize transaction.*/
  if (n > 1)
 8008660:	9b02      	ldr	r3, [sp, #8]
 8008662:	2b01      	cmp	r3, #1
 8008664:	d907      	bls.n	8008676 <sdc_lld_wait_transaction_end+0x86>
    return sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 8008666:	9b01      	ldr	r3, [sp, #4]
 8008668:	2200      	movs	r2, #0
 800866a:	210c      	movs	r1, #12
 800866c:	9803      	ldr	r0, [sp, #12]
 800866e:	f000 f9af 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8008672:	4603      	mov	r3, r0
 8008674:	e000      	b.n	8008678 <sdc_lld_wait_transaction_end+0x88>

  return HAL_SUCCESS;
 8008676:	2300      	movs	r3, #0
}
 8008678:	4618      	mov	r0, r3
 800867a:	b005      	add	sp, #20
 800867c:	f85d fb04 	ldr.w	pc, [sp], #4
 8008680:	00c007ff 	.word	0x00c007ff
	...

08008690 <sdc_lld_collect_errors>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] sta       value of the STA register
 *
 * @notapi
 */
static void sdc_lld_collect_errors(SDCDriver *sdcp, uint32_t sta) {
 8008690:	b084      	sub	sp, #16
 8008692:	9001      	str	r0, [sp, #4]
 8008694:	9100      	str	r1, [sp, #0]
  uint32_t errors = SDC_NO_ERROR;
 8008696:	2300      	movs	r3, #0
 8008698:	9303      	str	r3, [sp, #12]

  if (sta & SDIO_STA_CCRCFAIL)
 800869a:	9b00      	ldr	r3, [sp, #0]
 800869c:	f003 0301 	and.w	r3, r3, #1
 80086a0:	2b00      	cmp	r3, #0
 80086a2:	d003      	beq.n	80086ac <sdc_lld_collect_errors+0x1c>
    errors |= SDC_CMD_CRC_ERROR;
 80086a4:	9b03      	ldr	r3, [sp, #12]
 80086a6:	f043 0301 	orr.w	r3, r3, #1
 80086aa:	9303      	str	r3, [sp, #12]
  if (sta & SDIO_STA_DCRCFAIL)
 80086ac:	9b00      	ldr	r3, [sp, #0]
 80086ae:	f003 0302 	and.w	r3, r3, #2
 80086b2:	2b00      	cmp	r3, #0
 80086b4:	d003      	beq.n	80086be <sdc_lld_collect_errors+0x2e>
    errors |= SDC_DATA_CRC_ERROR;
 80086b6:	9b03      	ldr	r3, [sp, #12]
 80086b8:	f043 0302 	orr.w	r3, r3, #2
 80086bc:	9303      	str	r3, [sp, #12]
  if (sta & SDIO_STA_CTIMEOUT)
 80086be:	9b00      	ldr	r3, [sp, #0]
 80086c0:	f003 0304 	and.w	r3, r3, #4
 80086c4:	2b00      	cmp	r3, #0
 80086c6:	d003      	beq.n	80086d0 <sdc_lld_collect_errors+0x40>
    errors |= SDC_COMMAND_TIMEOUT;
 80086c8:	9b03      	ldr	r3, [sp, #12]
 80086ca:	f043 0308 	orr.w	r3, r3, #8
 80086ce:	9303      	str	r3, [sp, #12]
  if (sta & SDIO_STA_DTIMEOUT)
 80086d0:	9b00      	ldr	r3, [sp, #0]
 80086d2:	f003 0308 	and.w	r3, r3, #8
 80086d6:	2b00      	cmp	r3, #0
 80086d8:	d003      	beq.n	80086e2 <sdc_lld_collect_errors+0x52>
    errors |= SDC_DATA_TIMEOUT;
 80086da:	9b03      	ldr	r3, [sp, #12]
 80086dc:	f043 0304 	orr.w	r3, r3, #4
 80086e0:	9303      	str	r3, [sp, #12]
  if (sta & SDIO_STA_TXUNDERR)
 80086e2:	9b00      	ldr	r3, [sp, #0]
 80086e4:	f003 0310 	and.w	r3, r3, #16
 80086e8:	2b00      	cmp	r3, #0
 80086ea:	d003      	beq.n	80086f4 <sdc_lld_collect_errors+0x64>
    errors |= SDC_TX_UNDERRUN;
 80086ec:	9b03      	ldr	r3, [sp, #12]
 80086ee:	f043 0310 	orr.w	r3, r3, #16
 80086f2:	9303      	str	r3, [sp, #12]
  if (sta & SDIO_STA_RXOVERR)
 80086f4:	9b00      	ldr	r3, [sp, #0]
 80086f6:	f003 0320 	and.w	r3, r3, #32
 80086fa:	2b00      	cmp	r3, #0
 80086fc:	d003      	beq.n	8008706 <sdc_lld_collect_errors+0x76>
    errors |= SDC_RX_OVERRUN;
 80086fe:	9b03      	ldr	r3, [sp, #12]
 8008700:	f043 0320 	orr.w	r3, r3, #32
 8008704:	9303      	str	r3, [sp, #12]
  if (sta & SDIO_STA_STBITERR)
 8008706:	9b00      	ldr	r3, [sp, #0]
 8008708:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800870c:	2b00      	cmp	r3, #0
 800870e:	d003      	beq.n	8008718 <sdc_lld_collect_errors+0x88>
    errors |= SDC_STARTBIT_ERROR;
 8008710:	9b03      	ldr	r3, [sp, #12]
 8008712:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008716:	9303      	str	r3, [sp, #12]

  sdcp->errors |= errors;
 8008718:	9b01      	ldr	r3, [sp, #4]
 800871a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800871c:	9b03      	ldr	r3, [sp, #12]
 800871e:	431a      	orrs	r2, r3
 8008720:	9b01      	ldr	r3, [sp, #4]
 8008722:	635a      	str	r2, [r3, #52]	; 0x34
}
 8008724:	b004      	add	sp, #16
 8008726:	4770      	bx	lr
	...

08008730 <sdc_lld_error_cleanup>:
 *
 * @notapi
 */
static void sdc_lld_error_cleanup(SDCDriver *sdcp,
                                  uint32_t n,
                                  uint32_t *resp) {
 8008730:	b500      	push	{lr}
 8008732:	b087      	sub	sp, #28
 8008734:	9003      	str	r0, [sp, #12]
 8008736:	9102      	str	r1, [sp, #8]
 8008738:	9201      	str	r2, [sp, #4]
  uint32_t sta = sdcp->sdio->STA;
 800873a:	9b03      	ldr	r3, [sp, #12]
 800873c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800873e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008740:	9305      	str	r3, [sp, #20]

  dmaStreamClearInterrupt(sdcp->dma);
 8008742:	9b03      	ldr	r3, [sp, #12]
 8008744:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008746:	7a1b      	ldrb	r3, [r3, #8]
 8008748:	4619      	mov	r1, r3
 800874a:	9b03      	ldr	r3, [sp, #12]
 800874c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800874e:	685b      	ldr	r3, [r3, #4]
 8008750:	223d      	movs	r2, #61	; 0x3d
 8008752:	408a      	lsls	r2, r1
 8008754:	601a      	str	r2, [r3, #0]
  dmaStreamDisable(sdcp->dma);
 8008756:	9b03      	ldr	r3, [sp, #12]
 8008758:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800875a:	681b      	ldr	r3, [r3, #0]
 800875c:	681a      	ldr	r2, [r3, #0]
 800875e:	9b03      	ldr	r3, [sp, #12]
 8008760:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008762:	681b      	ldr	r3, [r3, #0]
 8008764:	f022 021f 	bic.w	r2, r2, #31
 8008768:	601a      	str	r2, [r3, #0]
 800876a:	9b03      	ldr	r3, [sp, #12]
 800876c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800876e:	681b      	ldr	r3, [r3, #0]
 8008770:	681b      	ldr	r3, [r3, #0]
 8008772:	f003 0301 	and.w	r3, r3, #1
 8008776:	2b00      	cmp	r3, #0
 8008778:	d1f7      	bne.n	800876a <sdc_lld_error_cleanup+0x3a>
 800877a:	9b03      	ldr	r3, [sp, #12]
 800877c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800877e:	7a1b      	ldrb	r3, [r3, #8]
 8008780:	4619      	mov	r1, r3
 8008782:	9b03      	ldr	r3, [sp, #12]
 8008784:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008786:	685b      	ldr	r3, [r3, #4]
 8008788:	223d      	movs	r2, #61	; 0x3d
 800878a:	408a      	lsls	r2, r1
 800878c:	601a      	str	r2, [r3, #0]
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 800878e:	9b03      	ldr	r3, [sp, #12]
 8008790:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008792:	4a0d      	ldr	r2, [pc, #52]	; (80087c8 <sdc_lld_error_cleanup+0x98>)
 8008794:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdio->MASK  = 0;
 8008796:	9b03      	ldr	r3, [sp, #12]
 8008798:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800879a:	2200      	movs	r2, #0
 800879c:	63da      	str	r2, [r3, #60]	; 0x3c
  sdcp->sdio->DCTRL = 0;
 800879e:	9b03      	ldr	r3, [sp, #12]
 80087a0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80087a2:	2200      	movs	r2, #0
 80087a4:	62da      	str	r2, [r3, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 80087a6:	9905      	ldr	r1, [sp, #20]
 80087a8:	9803      	ldr	r0, [sp, #12]
 80087aa:	f7ff ff71 	bl	8008690 <sdc_lld_collect_errors>
  if (n > 1)
 80087ae:	9b02      	ldr	r3, [sp, #8]
 80087b0:	2b01      	cmp	r3, #1
 80087b2:	d905      	bls.n	80087c0 <sdc_lld_error_cleanup+0x90>
    sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 80087b4:	9b01      	ldr	r3, [sp, #4]
 80087b6:	2200      	movs	r2, #0
 80087b8:	210c      	movs	r1, #12
 80087ba:	9803      	ldr	r0, [sp, #12]
 80087bc:	f000 f908 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
}
 80087c0:	b007      	add	sp, #28
 80087c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80087c6:	bf00      	nop
 80087c8:	00c007ff 	.word	0x00c007ff
 80087cc:	00000000 	.word	0x00000000

080087d0 <Vector104>:
 * @details It just wakes transaction thread. All error  handling performs in
 *          that thread.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SDIO_HANDLER) {
 80087d0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80087d2:	f7f9 f855 	bl	8001880 <_stats_increase_irq>
 80087d6:	f7f8 f903 	bl	80009e0 <_dbg_check_enter_isr>

  osalSysLockFromISR();
 80087da:	f7ff fdf9 	bl	80083d0 <osalSysLockFromISR.lto_priv.145>

  /* Disables the source but the status flags are not reset because the
     read/write functions needs to check them.*/
  SDIO->MASK = 0;
 80087de:	4b07      	ldr	r3, [pc, #28]	; (80087fc <Vector104+0x2c>)
 80087e0:	2200      	movs	r2, #0
 80087e2:	63da      	str	r2, [r3, #60]	; 0x3c

  osalThreadResumeI(&SDCD1.thread, MSG_OK);
 80087e4:	2100      	movs	r1, #0
 80087e6:	4806      	ldr	r0, [pc, #24]	; (8008800 <Vector104+0x30>)
 80087e8:	f7ff fe22 	bl	8008430 <osalThreadResumeI.lto_priv.213>

  osalSysUnlockFromISR();
 80087ec:	f7ff fdf8 	bl	80083e0 <osalSysUnlockFromISR.lto_priv.137>

  OSAL_IRQ_EPILOGUE();
 80087f0:	f7f8 f916 	bl	8000a20 <_dbg_check_leave_isr>
 80087f4:	f7fa f914 	bl	8002a20 <_port_irq_epilogue>
}
 80087f8:	bd08      	pop	{r3, pc}
 80087fa:	bf00      	nop
 80087fc:	40012c00 	.word	0x40012c00
 8008800:	20002738 	.word	0x20002738
	...

08008810 <sdc_lld_init>:
/**
 * @brief   Low level SDC driver initialization.
 *
 * @notapi
 */
void sdc_lld_init(void) {
 8008810:	b508      	push	{r3, lr}

  sdcObjectInit(&SDCD1);
 8008812:	4806      	ldr	r0, [pc, #24]	; (800882c <sdc_lld_init+0x1c>)
 8008814:	f7fb fafc 	bl	8003e10 <sdcObjectInit>
  SDCD1.thread = NULL;
 8008818:	4b04      	ldr	r3, [pc, #16]	; (800882c <sdc_lld_init+0x1c>)
 800881a:	2200      	movs	r2, #0
 800881c:	63da      	str	r2, [r3, #60]	; 0x3c
  SDCD1.dma    = STM32_DMA_STREAM(STM32_SDC_SDIO_DMA_STREAM);
 800881e:	4b03      	ldr	r3, [pc, #12]	; (800882c <sdc_lld_init+0x1c>)
 8008820:	4a03      	ldr	r2, [pc, #12]	; (8008830 <sdc_lld_init+0x20>)
 8008822:	645a      	str	r2, [r3, #68]	; 0x44
  SDCD1.sdio   = SDIO;
 8008824:	4b01      	ldr	r3, [pc, #4]	; (800882c <sdc_lld_init+0x1c>)
 8008826:	4a03      	ldr	r2, [pc, #12]	; (8008834 <sdc_lld_init+0x24>)
 8008828:	649a      	str	r2, [r3, #72]	; 0x48
}
 800882a:	bd08      	pop	{r3, pc}
 800882c:	200026fc 	.word	0x200026fc
 8008830:	0800ab54 	.word	0x0800ab54
 8008834:	40012c00 	.word	0x40012c00
	...

08008840 <sdc_lld_start_clk>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_start_clk(SDCDriver *sdcp) {
 8008840:	b500      	push	{lr}
 8008842:	b083      	sub	sp, #12
 8008844:	9001      	str	r0, [sp, #4]

  /* Initial clock setting: 400kHz, 1bit mode.*/
  sdcp->sdio->CLKCR  = STM32_SDIO_DIV_LS;
 8008846:	9b01      	ldr	r3, [sp, #4]
 8008848:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800884a:	2278      	movs	r2, #120	; 0x78
 800884c:	605a      	str	r2, [r3, #4]
  sdcp->sdio->POWER |= SDIO_POWER_PWRCTRL_0 | SDIO_POWER_PWRCTRL_1;
 800884e:	9b01      	ldr	r3, [sp, #4]
 8008850:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008852:	681a      	ldr	r2, [r3, #0]
 8008854:	9b01      	ldr	r3, [sp, #4]
 8008856:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008858:	f042 0203 	orr.w	r2, r2, #3
 800885c:	601a      	str	r2, [r3, #0]
  sdcp->sdio->CLKCR |= SDIO_CLKCR_CLKEN;
 800885e:	9b01      	ldr	r3, [sp, #4]
 8008860:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008862:	685a      	ldr	r2, [r3, #4]
 8008864:	9b01      	ldr	r3, [sp, #4]
 8008866:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008868:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800886c:	605a      	str	r2, [r3, #4]

  /* Clock activation delay.*/
  osalThreadSleep(OSAL_MS2ST(STM32_SDC_CLOCK_ACTIVATION_DELAY));
 800886e:	2064      	movs	r0, #100	; 0x64
 8008870:	f7ff fdbe 	bl	80083f0 <osalThreadSleep.lto_priv.218>
}
 8008874:	b003      	add	sp, #12
 8008876:	f85d fb04 	ldr.w	pc, [sp], #4
 800887a:	bf00      	nop
 800887c:	0000      	movs	r0, r0
	...

08008880 <sdc_lld_set_data_clk>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] clk       the clock mode
 *
 * @notapi
 */
void sdc_lld_set_data_clk(SDCDriver *sdcp, sdcbusclk_t clk) {
 8008880:	b082      	sub	sp, #8
 8008882:	9001      	str	r0, [sp, #4]
 8008884:	460b      	mov	r3, r1
 8008886:	f88d 3003 	strb.w	r3, [sp, #3]
  else
    sdcp->sdio->CLKCR = (sdcp->sdio->CLKCR & 0xFFFFFF00U) | STM32_SDIO_DIV_HS;
#else
  (void)clk;

  sdcp->sdio->CLKCR = (sdcp->sdio->CLKCR & 0xFFFFFF00U) | STM32_SDIO_DIV_HS;
 800888a:	9b01      	ldr	r3, [sp, #4]
 800888c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800888e:	685a      	ldr	r2, [r3, #4]
 8008890:	9b01      	ldr	r3, [sp, #4]
 8008892:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008894:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8008898:	605a      	str	r2, [r3, #4]
#endif
}
 800889a:	b002      	add	sp, #8
 800889c:	4770      	bx	lr
 800889e:	bf00      	nop

080088a0 <sdc_lld_stop_clk>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_stop_clk(SDCDriver *sdcp) {
 80088a0:	b082      	sub	sp, #8
 80088a2:	9001      	str	r0, [sp, #4]

  sdcp->sdio->CLKCR = 0;
 80088a4:	9b01      	ldr	r3, [sp, #4]
 80088a6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80088a8:	2200      	movs	r2, #0
 80088aa:	605a      	str	r2, [r3, #4]
  sdcp->sdio->POWER = 0;
 80088ac:	9b01      	ldr	r3, [sp, #4]
 80088ae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80088b0:	2200      	movs	r2, #0
 80088b2:	601a      	str	r2, [r3, #0]
}
 80088b4:	b002      	add	sp, #8
 80088b6:	4770      	bx	lr
	...

080088c0 <sdc_lld_set_bus_mode>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] mode      bus mode
 *
 * @notapi
 */
void sdc_lld_set_bus_mode(SDCDriver *sdcp, sdcbusmode_t mode) {
 80088c0:	b084      	sub	sp, #16
 80088c2:	9001      	str	r0, [sp, #4]
 80088c4:	460b      	mov	r3, r1
 80088c6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t clk = sdcp->sdio->CLKCR & ~SDIO_CLKCR_WIDBUS;
 80088ca:	9b01      	ldr	r3, [sp, #4]
 80088cc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80088ce:	685b      	ldr	r3, [r3, #4]
 80088d0:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
 80088d4:	9303      	str	r3, [sp, #12]

  switch (mode) {
 80088d6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088da:	2b01      	cmp	r3, #1
 80088dc:	d008      	beq.n	80088f0 <sdc_lld_set_bus_mode+0x30>
 80088de:	2b02      	cmp	r3, #2
 80088e0:	d00d      	beq.n	80088fe <sdc_lld_set_bus_mode+0x3e>
 80088e2:	2b00      	cmp	r3, #0
 80088e4:	d111      	bne.n	800890a <sdc_lld_set_bus_mode+0x4a>
  case SDC_MODE_1BIT:
    sdcp->sdio->CLKCR = clk;
 80088e6:	9b01      	ldr	r3, [sp, #4]
 80088e8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80088ea:	9a03      	ldr	r2, [sp, #12]
 80088ec:	605a      	str	r2, [r3, #4]
 80088ee:	e00c      	b.n	800890a <sdc_lld_set_bus_mode+0x4a>
    break;
  case SDC_MODE_4BIT:
    sdcp->sdio->CLKCR = clk | SDIO_CLKCR_WIDBUS_0;
 80088f0:	9b01      	ldr	r3, [sp, #4]
 80088f2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80088f4:	9a03      	ldr	r2, [sp, #12]
 80088f6:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80088fa:	605a      	str	r2, [r3, #4]
 80088fc:	e005      	b.n	800890a <sdc_lld_set_bus_mode+0x4a>
    break;
  case SDC_MODE_8BIT:
    sdcp->sdio->CLKCR = clk | SDIO_CLKCR_WIDBUS_1;
 80088fe:	9b01      	ldr	r3, [sp, #4]
 8008900:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008902:	9a03      	ldr	r2, [sp, #12]
 8008904:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8008908:	605a      	str	r2, [r3, #4]
    break;
  }
}
 800890a:	b004      	add	sp, #16
 800890c:	4770      	bx	lr
 800890e:	bf00      	nop

08008910 <sdc_lld_send_cmd_none>:
 * @param[in] cmd       card command
 * @param[in] arg       command argument
 *
 * @notapi
 */
void sdc_lld_send_cmd_none(SDCDriver *sdcp, uint8_t cmd, uint32_t arg) {
 8008910:	b084      	sub	sp, #16
 8008912:	9003      	str	r0, [sp, #12]
 8008914:	460b      	mov	r3, r1
 8008916:	9201      	str	r2, [sp, #4]
 8008918:	f88d 300b 	strb.w	r3, [sp, #11]

  sdcp->sdio->ARG = arg;
 800891c:	9b03      	ldr	r3, [sp, #12]
 800891e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008920:	9a01      	ldr	r2, [sp, #4]
 8008922:	609a      	str	r2, [r3, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_CPSMEN;
 8008924:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8008928:	9b03      	ldr	r3, [sp, #12]
 800892a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800892c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8008930:	60da      	str	r2, [r3, #12]
  while ((sdcp->sdio->STA & SDIO_STA_CMDSENT) == 0)
 8008932:	9b03      	ldr	r3, [sp, #12]
 8008934:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008936:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008938:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800893c:	2b00      	cmp	r3, #0
 800893e:	d0f8      	beq.n	8008932 <sdc_lld_send_cmd_none+0x22>
    ;
  sdcp->sdio->ICR = SDIO_ICR_CMDSENTC;
 8008940:	9b03      	ldr	r3, [sp, #12]
 8008942:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008944:	2280      	movs	r2, #128	; 0x80
 8008946:	639a      	str	r2, [r3, #56]	; 0x38
}
 8008948:	b004      	add	sp, #16
 800894a:	4770      	bx	lr
 800894c:	0000      	movs	r0, r0
	...

08008950 <sdc_lld_send_cmd_short>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                            uint32_t *resp) {
 8008950:	b500      	push	{lr}
 8008952:	b087      	sub	sp, #28
 8008954:	9003      	str	r0, [sp, #12]
 8008956:	9201      	str	r2, [sp, #4]
 8008958:	9300      	str	r3, [sp, #0]
 800895a:	460b      	mov	r3, r1
 800895c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  sdcp->sdio->ARG = arg;
 8008960:	9b03      	ldr	r3, [sp, #12]
 8008962:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008964:	9a01      	ldr	r2, [sp, #4]
 8008966:	609a      	str	r2, [r3, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 8008968:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800896c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008970:	b2db      	uxtb	r3, r3
 8008972:	461a      	mov	r2, r3
 8008974:	9b03      	ldr	r3, [sp, #12]
 8008976:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008978:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800897c:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 800897e:	9b03      	ldr	r3, [sp, #12]
 8008980:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008982:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008984:	9305      	str	r3, [sp, #20]
 8008986:	9b05      	ldr	r3, [sp, #20]
 8008988:	f003 0345 	and.w	r3, r3, #69	; 0x45
 800898c:	2b00      	cmp	r3, #0
 800898e:	d0f6      	beq.n	800897e <sdc_lld_send_cmd_short+0x2e>
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 8008990:	9b03      	ldr	r3, [sp, #12]
 8008992:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008994:	9a05      	ldr	r2, [sp, #20]
 8008996:	f002 0245 	and.w	r2, r2, #69	; 0x45
 800899a:	639a      	str	r2, [r3, #56]	; 0x38
                           SDIO_STA_CCRCFAIL);
  if ((sta & (SDIO_STA_CTIMEOUT)) != 0) {
 800899c:	9b05      	ldr	r3, [sp, #20]
 800899e:	f003 0304 	and.w	r3, r3, #4
 80089a2:	2b00      	cmp	r3, #0
 80089a4:	d005      	beq.n	80089b2 <sdc_lld_send_cmd_short+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 80089a6:	9905      	ldr	r1, [sp, #20]
 80089a8:	9803      	ldr	r0, [sp, #12]
 80089aa:	f7ff fe71 	bl	8008690 <sdc_lld_collect_errors>
    return HAL_FAILED;
 80089ae:	2301      	movs	r3, #1
 80089b0:	e005      	b.n	80089be <sdc_lld_send_cmd_short+0x6e>
  }
  *resp = sdcp->sdio->RESP1;
 80089b2:	9b03      	ldr	r3, [sp, #12]
 80089b4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80089b6:	695a      	ldr	r2, [r3, #20]
 80089b8:	9b00      	ldr	r3, [sp, #0]
 80089ba:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 80089bc:	2300      	movs	r3, #0
}
 80089be:	4618      	mov	r0, r3
 80089c0:	b007      	add	sp, #28
 80089c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80089c6:	bf00      	nop
	...

080089d0 <sdc_lld_send_cmd_short_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                                uint32_t *resp) {
 80089d0:	b500      	push	{lr}
 80089d2:	b087      	sub	sp, #28
 80089d4:	9003      	str	r0, [sp, #12]
 80089d6:	9201      	str	r2, [sp, #4]
 80089d8:	9300      	str	r3, [sp, #0]
 80089da:	460b      	mov	r3, r1
 80089dc:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  sdcp->sdio->ARG = arg;
 80089e0:	9b03      	ldr	r3, [sp, #12]
 80089e2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80089e4:	9a01      	ldr	r2, [sp, #4]
 80089e6:	609a      	str	r2, [r3, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 80089e8:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80089ec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80089f0:	b2db      	uxtb	r3, r3
 80089f2:	461a      	mov	r2, r3
 80089f4:	9b03      	ldr	r3, [sp, #12]
 80089f6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80089f8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80089fc:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 80089fe:	9b03      	ldr	r3, [sp, #12]
 8008a00:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008a02:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008a04:	9305      	str	r3, [sp, #20]
 8008a06:	9b05      	ldr	r3, [sp, #20]
 8008a08:	f003 0345 	and.w	r3, r3, #69	; 0x45
 8008a0c:	2b00      	cmp	r3, #0
 8008a0e:	d0f6      	beq.n	80089fe <sdc_lld_send_cmd_short_crc+0x2e>
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT | SDIO_STA_CCRCFAIL);
 8008a10:	9b03      	ldr	r3, [sp, #12]
 8008a12:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008a14:	9a05      	ldr	r2, [sp, #20]
 8008a16:	f002 0245 	and.w	r2, r2, #69	; 0x45
 8008a1a:	639a      	str	r2, [r3, #56]	; 0x38
  if ((sta & (SDIO_STA_CTIMEOUT | SDIO_STA_CCRCFAIL)) != 0) {
 8008a1c:	9b05      	ldr	r3, [sp, #20]
 8008a1e:	f003 0305 	and.w	r3, r3, #5
 8008a22:	2b00      	cmp	r3, #0
 8008a24:	d005      	beq.n	8008a32 <sdc_lld_send_cmd_short_crc+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 8008a26:	9905      	ldr	r1, [sp, #20]
 8008a28:	9803      	ldr	r0, [sp, #12]
 8008a2a:	f7ff fe31 	bl	8008690 <sdc_lld_collect_errors>
    return HAL_FAILED;
 8008a2e:	2301      	movs	r3, #1
 8008a30:	e005      	b.n	8008a3e <sdc_lld_send_cmd_short_crc+0x6e>
  }
  *resp = sdcp->sdio->RESP1;
 8008a32:	9b03      	ldr	r3, [sp, #12]
 8008a34:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008a36:	695a      	ldr	r2, [r3, #20]
 8008a38:	9b00      	ldr	r3, [sp, #0]
 8008a3a:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 8008a3c:	2300      	movs	r3, #0
}
 8008a3e:	4618      	mov	r0, r3
 8008a40:	b007      	add	sp, #28
 8008a42:	f85d fb04 	ldr.w	pc, [sp], #4
 8008a46:	bf00      	nop
	...

08008a50 <sdc_lld_send_cmd_long_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_long_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                               uint32_t *resp) {
 8008a50:	b500      	push	{lr}
 8008a52:	b087      	sub	sp, #28
 8008a54:	9003      	str	r0, [sp, #12]
 8008a56:	9201      	str	r2, [sp, #4]
 8008a58:	9300      	str	r3, [sp, #0]
 8008a5a:	460b      	mov	r3, r1
 8008a5c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  (void)sdcp;

  sdcp->sdio->ARG = arg;
 8008a60:	9b03      	ldr	r3, [sp, #12]
 8008a62:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008a64:	9a01      	ldr	r2, [sp, #4]
 8008a66:	609a      	str	r2, [r3, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_WAITRESP_1 |
 8008a68:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8008a6c:	f063 033f 	orn	r3, r3, #63	; 0x3f
 8008a70:	b2db      	uxtb	r3, r3
 8008a72:	461a      	mov	r2, r3
 8008a74:	9b03      	ldr	r3, [sp, #12]
 8008a76:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008a78:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8008a7c:	60da      	str	r2, [r3, #12]
                                    SDIO_CMD_CPSMEN;
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 8008a7e:	9b03      	ldr	r3, [sp, #12]
 8008a80:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008a82:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008a84:	9305      	str	r3, [sp, #20]
 8008a86:	9b05      	ldr	r3, [sp, #20]
 8008a88:	f003 0345 	and.w	r3, r3, #69	; 0x45
 8008a8c:	2b00      	cmp	r3, #0
 8008a8e:	d0f6      	beq.n	8008a7e <sdc_lld_send_cmd_long_crc+0x2e>
                                     SDIO_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 8008a90:	9b03      	ldr	r3, [sp, #12]
 8008a92:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008a94:	9a05      	ldr	r2, [sp, #20]
 8008a96:	f002 0245 	and.w	r2, r2, #69	; 0x45
 8008a9a:	639a      	str	r2, [r3, #56]	; 0x38
                           SDIO_STA_CCRCFAIL);
  if ((sta & (STM32_SDIO_STA_ERROR_MASK)) != 0) {
 8008a9c:	9b05      	ldr	r3, [sp, #20]
 8008a9e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8008aa2:	2b00      	cmp	r3, #0
 8008aa4:	d005      	beq.n	8008ab2 <sdc_lld_send_cmd_long_crc+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 8008aa6:	9905      	ldr	r1, [sp, #20]
 8008aa8:	9803      	ldr	r0, [sp, #12]
 8008aaa:	f7ff fdf1 	bl	8008690 <sdc_lld_collect_errors>
    return HAL_FAILED;
 8008aae:	2301      	movs	r3, #1
 8008ab0:	e01a      	b.n	8008ae8 <sdc_lld_send_cmd_long_crc+0x98>
  }
  /* Save bytes in reverse order because MSB in response comes first.*/
  *resp++ = sdcp->sdio->RESP4;
 8008ab2:	9b03      	ldr	r3, [sp, #12]
 8008ab4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8008ab6:	9b00      	ldr	r3, [sp, #0]
 8008ab8:	1d19      	adds	r1, r3, #4
 8008aba:	9100      	str	r1, [sp, #0]
 8008abc:	6a12      	ldr	r2, [r2, #32]
 8008abe:	601a      	str	r2, [r3, #0]
  *resp++ = sdcp->sdio->RESP3;
 8008ac0:	9b03      	ldr	r3, [sp, #12]
 8008ac2:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8008ac4:	9b00      	ldr	r3, [sp, #0]
 8008ac6:	1d19      	adds	r1, r3, #4
 8008ac8:	9100      	str	r1, [sp, #0]
 8008aca:	69d2      	ldr	r2, [r2, #28]
 8008acc:	601a      	str	r2, [r3, #0]
  *resp++ = sdcp->sdio->RESP2;
 8008ace:	9b03      	ldr	r3, [sp, #12]
 8008ad0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8008ad2:	9b00      	ldr	r3, [sp, #0]
 8008ad4:	1d19      	adds	r1, r3, #4
 8008ad6:	9100      	str	r1, [sp, #0]
 8008ad8:	6992      	ldr	r2, [r2, #24]
 8008ada:	601a      	str	r2, [r3, #0]
  *resp   = sdcp->sdio->RESP1;
 8008adc:	9b03      	ldr	r3, [sp, #12]
 8008ade:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008ae0:	695a      	ldr	r2, [r3, #20]
 8008ae2:	9b00      	ldr	r3, [sp, #0]
 8008ae4:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 8008ae6:	2300      	movs	r3, #0
}
 8008ae8:	4618      	mov	r0, r3
 8008aea:	b007      	add	sp, #28
 8008aec:	f85d fb04 	ldr.w	pc, [sp], #4

08008af0 <sdc_lld_read_special>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_special(SDCDriver *sdcp, uint8_t *buf, size_t bytes,
                          uint8_t cmd, uint32_t arg) {
 8008af0:	b500      	push	{lr}
 8008af2:	b087      	sub	sp, #28
 8008af4:	9003      	str	r0, [sp, #12]
 8008af6:	9102      	str	r1, [sp, #8]
 8008af8:	9201      	str	r2, [sp, #4]
 8008afa:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t resp[1];

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
 8008afe:	9a01      	ldr	r2, [sp, #4]
 8008b00:	9902      	ldr	r1, [sp, #8]
 8008b02:	9803      	ldr	r0, [sp, #12]
 8008b04:	f7ff fca4 	bl	8008450 <sdc_lld_prepare_read_bytes>
 8008b08:	4603      	mov	r3, r0
 8008b0a:	2b00      	cmp	r3, #0
 8008b0c:	d119      	bne.n	8008b42 <sdc_lld_read_special+0x52>
    goto error;

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 8008b0e:	ab05      	add	r3, sp, #20
 8008b10:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8008b14:	9a08      	ldr	r2, [sp, #32]
 8008b16:	9803      	ldr	r0, [sp, #12]
 8008b18:	f7ff ff5a 	bl	80089d0 <sdc_lld_send_cmd_short_crc>
 8008b1c:	4603      	mov	r3, r0
 8008b1e:	2b00      	cmp	r3, #0
 8008b20:	d10f      	bne.n	8008b42 <sdc_lld_read_special+0x52>
                                 || MMCSD_R1_ERROR(resp[0]))
 8008b22:	9a05      	ldr	r2, [sp, #20]
 8008b24:	4b0c      	ldr	r3, [pc, #48]	; (8008b58 <sdc_lld_read_special+0x68>)
 8008b26:	4013      	ands	r3, r2
 8008b28:	2b00      	cmp	r3, #0
 8008b2a:	d10a      	bne.n	8008b42 <sdc_lld_read_special+0x52>
    goto error;

  if (sdc_lld_wait_transaction_end(sdcp, 1, resp))
 8008b2c:	ab05      	add	r3, sp, #20
 8008b2e:	461a      	mov	r2, r3
 8008b30:	2101      	movs	r1, #1
 8008b32:	9803      	ldr	r0, [sp, #12]
 8008b34:	f7ff fd5c 	bl	80085f0 <sdc_lld_wait_transaction_end>
 8008b38:	4603      	mov	r3, r0
 8008b3a:	2b00      	cmp	r3, #0
 8008b3c:	d101      	bne.n	8008b42 <sdc_lld_read_special+0x52>
    goto error;

  return HAL_SUCCESS;
 8008b3e:	2300      	movs	r3, #0
 8008b40:	e006      	b.n	8008b50 <sdc_lld_read_special+0x60>

error:
  sdc_lld_error_cleanup(sdcp, 1, resp);
 8008b42:	ab05      	add	r3, sp, #20
 8008b44:	461a      	mov	r2, r3
 8008b46:	2101      	movs	r1, #1
 8008b48:	9803      	ldr	r0, [sp, #12]
 8008b4a:	f7ff fdf1 	bl	8008730 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 8008b4e:	2301      	movs	r3, #1
}
 8008b50:	4618      	mov	r0, r3
 8008b52:	b007      	add	sp, #28
 8008b54:	f85d fb04 	ldr.w	pc, [sp], #4
 8008b58:	fdffe008 	.word	0xfdffe008
 8008b5c:	00000000 	.word	0x00000000

08008b60 <sdc_lld_read_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
                          uint8_t *buf, uint32_t blocks) {
 8008b60:	b500      	push	{lr}
 8008b62:	b087      	sub	sp, #28
 8008b64:	9003      	str	r0, [sp, #12]
 8008b66:	9102      	str	r1, [sp, #8]
 8008b68:	9201      	str	r2, [sp, #4]
 8008b6a:	9300      	str	r3, [sp, #0]
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);
 8008b6c:	9b00      	ldr	r3, [sp, #0]
 8008b6e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8008b72:	d302      	bcc.n	8008b7a <sdc_lld_read_aligned+0x1a>
 8008b74:	482d      	ldr	r0, [pc, #180]	; (8008c2c <sdc_lld_read_aligned+0xcc>)
 8008b76:	f7f7 fe4b 	bl	8000810 <chSysHalt>

  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;
 8008b7a:	9b03      	ldr	r3, [sp, #12]
 8008b7c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008b7e:	4a2c      	ldr	r2, [pc, #176]	; (8008c30 <sdc_lld_read_aligned+0xd0>)
 8008b80:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 8008b82:	9803      	ldr	r0, [sp, #12]
 8008b84:	f7fb f90c 	bl	8003da0 <_sdc_wait_for_transfer_state>
 8008b88:	4603      	mov	r3, r0
 8008b8a:	2b00      	cmp	r3, #0
 8008b8c:	d001      	beq.n	8008b92 <sdc_lld_read_aligned+0x32>
    return HAL_FAILED;
 8008b8e:	2301      	movs	r3, #1
 8008b90:	e048      	b.n	8008c24 <sdc_lld_read_aligned+0xc4>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 8008b92:	9b03      	ldr	r3, [sp, #12]
 8008b94:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008b96:	681b      	ldr	r3, [r3, #0]
 8008b98:	9a01      	ldr	r2, [sp, #4]
 8008b9a:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 8008b9c:	9b00      	ldr	r3, [sp, #0]
 8008b9e:	025a      	lsls	r2, r3, #9
 8008ba0:	9b03      	ldr	r3, [sp, #12]
 8008ba2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008ba4:	681b      	ldr	r3, [r3, #0]
 8008ba6:	0892      	lsrs	r2, r2, #2
 8008ba8:	605a      	str	r2, [r3, #4]
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 8008baa:	9b03      	ldr	r3, [sp, #12]
 8008bac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008bae:	681b      	ldr	r3, [r3, #0]
 8008bb0:	9a03      	ldr	r2, [sp, #12]
 8008bb2:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8008bb4:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 8008bb6:	9b03      	ldr	r3, [sp, #12]
 8008bb8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008bba:	681b      	ldr	r3, [r3, #0]
 8008bbc:	681a      	ldr	r2, [r3, #0]
 8008bbe:	9b03      	ldr	r3, [sp, #12]
 8008bc0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008bc2:	681b      	ldr	r3, [r3, #0]
 8008bc4:	f042 0201 	orr.w	r2, r2, #1
 8008bc8:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 8008bca:	9b03      	ldr	r3, [sp, #12]
 8008bcc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008bce:	4a19      	ldr	r2, [pc, #100]	; (8008c34 <sdc_lld_read_aligned+0xd4>)
 8008bd0:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 8008bd2:	9b03      	ldr	r3, [sp, #12]
 8008bd4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008bd6:	f240 322a 	movw	r2, #810	; 0x32a
 8008bda:	63da      	str	r2, [r3, #60]	; 0x3c
                      SDIO_MASK_DTIMEOUTIE |
                      SDIO_MASK_STBITERRIE |
                      SDIO_MASK_RXOVERRIE |
                      SDIO_MASK_DATAENDIE;
  sdcp->sdio->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 8008bdc:	9b03      	ldr	r3, [sp, #12]
 8008bde:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008be0:	9a00      	ldr	r2, [sp, #0]
 8008be2:	0252      	lsls	r2, r2, #9
 8008be4:	629a      	str	r2, [r3, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdio->DCTRL = SDIO_DCTRL_DTDIR |
 8008be6:	9b03      	ldr	r3, [sp, #12]
 8008be8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008bea:	229b      	movs	r2, #155	; 0x9b
 8008bec:	62da      	str	r2, [r3, #44]	; 0x2c
                      SDIO_DCTRL_DBLOCKSIZE_3 |
                      SDIO_DCTRL_DBLOCKSIZE_0 |
                      SDIO_DCTRL_DMAEN |
                      SDIO_DCTRL_DTEN;

  if (sdc_lld_prepare_read(sdcp, startblk, blocks, resp) == TRUE)
 8008bee:	ab05      	add	r3, sp, #20
 8008bf0:	9a00      	ldr	r2, [sp, #0]
 8008bf2:	9902      	ldr	r1, [sp, #8]
 8008bf4:	9803      	ldr	r0, [sp, #12]
 8008bf6:	f7ff fc7b 	bl	80084f0 <sdc_lld_prepare_read>
 8008bfa:	4603      	mov	r3, r0
 8008bfc:	2b00      	cmp	r3, #0
 8008bfe:	d10a      	bne.n	8008c16 <sdc_lld_read_aligned+0xb6>
    goto error;

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == TRUE)
 8008c00:	ab05      	add	r3, sp, #20
 8008c02:	461a      	mov	r2, r3
 8008c04:	9900      	ldr	r1, [sp, #0]
 8008c06:	9803      	ldr	r0, [sp, #12]
 8008c08:	f7ff fcf2 	bl	80085f0 <sdc_lld_wait_transaction_end>
 8008c0c:	4603      	mov	r3, r0
 8008c0e:	2b00      	cmp	r3, #0
 8008c10:	d101      	bne.n	8008c16 <sdc_lld_read_aligned+0xb6>
    goto error;

  return HAL_SUCCESS;
 8008c12:	2300      	movs	r3, #0
 8008c14:	e006      	b.n	8008c24 <sdc_lld_read_aligned+0xc4>

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 8008c16:	ab05      	add	r3, sp, #20
 8008c18:	461a      	mov	r2, r3
 8008c1a:	9900      	ldr	r1, [sp, #0]
 8008c1c:	9803      	ldr	r0, [sp, #12]
 8008c1e:	f7ff fd87 	bl	8008730 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 8008c22:	2301      	movs	r3, #1
}
 8008c24:	4618      	mov	r0, r3
 8008c26:	b007      	add	sp, #28
 8008c28:	f85d fb04 	ldr.w	pc, [sp], #4
 8008c2c:	0800ac60 	.word	0x0800ac60
 8008c30:	000927c0 	.word	0x000927c0
 8008c34:	00c007ff 	.word	0x00c007ff
	...

08008c40 <sdc_lld_write_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
                           const uint8_t *buf, uint32_t blocks) {
 8008c40:	b500      	push	{lr}
 8008c42:	b087      	sub	sp, #28
 8008c44:	9003      	str	r0, [sp, #12]
 8008c46:	9102      	str	r1, [sp, #8]
 8008c48:	9201      	str	r2, [sp, #4]
 8008c4a:	9300      	str	r3, [sp, #0]
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);
 8008c4c:	9b00      	ldr	r3, [sp, #0]
 8008c4e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8008c52:	d302      	bcc.n	8008c5a <sdc_lld_write_aligned+0x1a>
 8008c54:	482e      	ldr	r0, [pc, #184]	; (8008d10 <sdc_lld_write_aligned+0xd0>)
 8008c56:	f7f7 fddb 	bl	8000810 <chSysHalt>

  sdcp->sdio->DTIMER = STM32_SDC_WRITE_TIMEOUT;
 8008c5a:	9b03      	ldr	r3, [sp, #12]
 8008c5c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008c5e:	4a2d      	ldr	r2, [pc, #180]	; (8008d14 <sdc_lld_write_aligned+0xd4>)
 8008c60:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 8008c62:	9803      	ldr	r0, [sp, #12]
 8008c64:	f7fb f89c 	bl	8003da0 <_sdc_wait_for_transfer_state>
 8008c68:	4603      	mov	r3, r0
 8008c6a:	2b00      	cmp	r3, #0
 8008c6c:	d001      	beq.n	8008c72 <sdc_lld_write_aligned+0x32>
    return HAL_FAILED;
 8008c6e:	2301      	movs	r3, #1
 8008c70:	e04a      	b.n	8008d08 <sdc_lld_write_aligned+0xc8>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 8008c72:	9b03      	ldr	r3, [sp, #12]
 8008c74:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008c76:	681b      	ldr	r3, [r3, #0]
 8008c78:	9a01      	ldr	r2, [sp, #4]
 8008c7a:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 8008c7c:	9b00      	ldr	r3, [sp, #0]
 8008c7e:	025a      	lsls	r2, r3, #9
 8008c80:	9b03      	ldr	r3, [sp, #12]
 8008c82:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008c84:	681b      	ldr	r3, [r3, #0]
 8008c86:	0892      	lsrs	r2, r2, #2
 8008c88:	605a      	str	r2, [r3, #4]
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
 8008c8a:	9b03      	ldr	r3, [sp, #12]
 8008c8c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8008c8e:	9b03      	ldr	r3, [sp, #12]
 8008c90:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008c92:	681b      	ldr	r3, [r3, #0]
 8008c94:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8008c98:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 8008c9a:	9b03      	ldr	r3, [sp, #12]
 8008c9c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008c9e:	681b      	ldr	r3, [r3, #0]
 8008ca0:	681a      	ldr	r2, [r3, #0]
 8008ca2:	9b03      	ldr	r3, [sp, #12]
 8008ca4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008ca6:	681b      	ldr	r3, [r3, #0]
 8008ca8:	f042 0201 	orr.w	r2, r2, #1
 8008cac:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 8008cae:	9b03      	ldr	r3, [sp, #12]
 8008cb0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008cb2:	4a19      	ldr	r2, [pc, #100]	; (8008d18 <sdc_lld_write_aligned+0xd8>)
 8008cb4:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 8008cb6:	9b03      	ldr	r3, [sp, #12]
 8008cb8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008cba:	f240 321a 	movw	r2, #794	; 0x31a
 8008cbe:	63da      	str	r2, [r3, #60]	; 0x3c
                      SDIO_MASK_DTIMEOUTIE |
                      SDIO_MASK_STBITERRIE |
                      SDIO_MASK_TXUNDERRIE |
                      SDIO_MASK_DATAENDIE;
  sdcp->sdio->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 8008cc0:	9b03      	ldr	r3, [sp, #12]
 8008cc2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008cc4:	9a00      	ldr	r2, [sp, #0]
 8008cc6:	0252      	lsls	r2, r2, #9
 8008cc8:	629a      	str	r2, [r3, #40]	; 0x28

  /* Talk to card what we want from it.*/
  if (sdc_lld_prepare_write(sdcp, startblk, blocks, resp) == TRUE)
 8008cca:	ab05      	add	r3, sp, #20
 8008ccc:	9a00      	ldr	r2, [sp, #0]
 8008cce:	9902      	ldr	r1, [sp, #8]
 8008cd0:	9803      	ldr	r0, [sp, #12]
 8008cd2:	f7ff fc4d 	bl	8008570 <sdc_lld_prepare_write>
 8008cd6:	4603      	mov	r3, r0
 8008cd8:	2b00      	cmp	r3, #0
 8008cda:	d10e      	bne.n	8008cfa <sdc_lld_write_aligned+0xba>
    goto error;

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdio->DCTRL = SDIO_DCTRL_DBLOCKSIZE_3 |
 8008cdc:	9b03      	ldr	r3, [sp, #12]
 8008cde:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008ce0:	2299      	movs	r2, #153	; 0x99
 8008ce2:	62da      	str	r2, [r3, #44]	; 0x2c
                      SDIO_DCTRL_DBLOCKSIZE_0 |
                      SDIO_DCTRL_DMAEN |
                      SDIO_DCTRL_DTEN;

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == TRUE)
 8008ce4:	ab05      	add	r3, sp, #20
 8008ce6:	461a      	mov	r2, r3
 8008ce8:	9900      	ldr	r1, [sp, #0]
 8008cea:	9803      	ldr	r0, [sp, #12]
 8008cec:	f7ff fc80 	bl	80085f0 <sdc_lld_wait_transaction_end>
 8008cf0:	4603      	mov	r3, r0
 8008cf2:	2b00      	cmp	r3, #0
 8008cf4:	d101      	bne.n	8008cfa <sdc_lld_write_aligned+0xba>
    goto error;

  return HAL_SUCCESS;
 8008cf6:	2300      	movs	r3, #0
 8008cf8:	e006      	b.n	8008d08 <sdc_lld_write_aligned+0xc8>

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 8008cfa:	ab05      	add	r3, sp, #20
 8008cfc:	461a      	mov	r2, r3
 8008cfe:	9900      	ldr	r1, [sp, #0]
 8008d00:	9803      	ldr	r0, [sp, #12]
 8008d02:	f7ff fd15 	bl	8008730 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 8008d06:	2301      	movs	r3, #1
}
 8008d08:	4618      	mov	r0, r3
 8008d0a:	b007      	add	sp, #28
 8008d0c:	f85d fb04 	ldr.w	pc, [sp], #4
 8008d10:	0800ac80 	.word	0x0800ac80
 8008d14:	005b8d80 	.word	0x005b8d80
 8008d18:	00c007ff 	.word	0x00c007ff
 8008d1c:	00000000 	.word	0x00000000

08008d20 <sdc_lld_read>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read(SDCDriver *sdcp, uint32_t startblk,
                  uint8_t *buf, uint32_t blocks) {
 8008d20:	b500      	push	{lr}
 8008d22:	b087      	sub	sp, #28
 8008d24:	9003      	str	r0, [sp, #12]
 8008d26:	9102      	str	r1, [sp, #8]
 8008d28:	9201      	str	r2, [sp, #4]
 8008d2a:	9300      	str	r3, [sp, #0]

#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 8008d2c:	9b01      	ldr	r3, [sp, #4]
 8008d2e:	f003 0303 	and.w	r3, r3, #3
 8008d32:	2b00      	cmp	r3, #0
 8008d34:	d026      	beq.n	8008d84 <sdc_lld_read+0x64>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 8008d36:	2300      	movs	r3, #0
 8008d38:	9305      	str	r3, [sp, #20]
 8008d3a:	e01d      	b.n	8008d78 <sdc_lld_read+0x58>
      if (sdc_lld_read_aligned(sdcp, startblk, u.buf, 1))
 8008d3c:	2301      	movs	r3, #1
 8008d3e:	4a17      	ldr	r2, [pc, #92]	; (8008d9c <sdc_lld_read+0x7c>)
 8008d40:	9902      	ldr	r1, [sp, #8]
 8008d42:	9803      	ldr	r0, [sp, #12]
 8008d44:	f7ff ff0c 	bl	8008b60 <sdc_lld_read_aligned>
 8008d48:	4603      	mov	r3, r0
 8008d4a:	2b00      	cmp	r3, #0
 8008d4c:	d001      	beq.n	8008d52 <sdc_lld_read+0x32>
        return HAL_FAILED;
 8008d4e:	2301      	movs	r3, #1
 8008d50:	e01f      	b.n	8008d92 <sdc_lld_read+0x72>
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
 8008d52:	9b01      	ldr	r3, [sp, #4]
 8008d54:	4a11      	ldr	r2, [pc, #68]	; (8008d9c <sdc_lld_read+0x7c>)
 8008d56:	4618      	mov	r0, r3
 8008d58:	4611      	mov	r1, r2
 8008d5a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008d5e:	461a      	mov	r2, r3
 8008d60:	f7f7 fade 	bl	8000320 <memcpy>
      buf += MMCSD_BLOCK_SIZE;
 8008d64:	9b01      	ldr	r3, [sp, #4]
 8008d66:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8008d6a:	9301      	str	r3, [sp, #4]
      startblk++;
 8008d6c:	9b02      	ldr	r3, [sp, #8]
 8008d6e:	3301      	adds	r3, #1
 8008d70:	9302      	str	r3, [sp, #8]
    for (i = 0; i < blocks; i++) {
 8008d72:	9b05      	ldr	r3, [sp, #20]
 8008d74:	3301      	adds	r3, #1
 8008d76:	9305      	str	r3, [sp, #20]
 8008d78:	9a05      	ldr	r2, [sp, #20]
 8008d7a:	9b00      	ldr	r3, [sp, #0]
 8008d7c:	429a      	cmp	r2, r3
 8008d7e:	d3dd      	bcc.n	8008d3c <sdc_lld_read+0x1c>
    }
    return HAL_SUCCESS;
 8008d80:	2300      	movs	r3, #0
 8008d82:	e006      	b.n	8008d92 <sdc_lld_read+0x72>
  }
#endif /* STM32_SDC_SDIO_UNALIGNED_SUPPORT */
  return sdc_lld_read_aligned(sdcp, startblk, buf, blocks);
 8008d84:	9b00      	ldr	r3, [sp, #0]
 8008d86:	9a01      	ldr	r2, [sp, #4]
 8008d88:	9902      	ldr	r1, [sp, #8]
 8008d8a:	9803      	ldr	r0, [sp, #12]
 8008d8c:	f7ff fee8 	bl	8008b60 <sdc_lld_read_aligned>
 8008d90:	4603      	mov	r3, r0
}
 8008d92:	4618      	mov	r0, r3
 8008d94:	b007      	add	sp, #28
 8008d96:	f85d fb04 	ldr.w	pc, [sp], #4
 8008d9a:	bf00      	nop
 8008d9c:	20002748 	.word	0x20002748

08008da0 <sdc_lld_write>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write(SDCDriver *sdcp, uint32_t startblk,
                   const uint8_t *buf, uint32_t blocks) {
 8008da0:	b500      	push	{lr}
 8008da2:	b087      	sub	sp, #28
 8008da4:	9003      	str	r0, [sp, #12]
 8008da6:	9102      	str	r1, [sp, #8]
 8008da8:	9201      	str	r2, [sp, #4]
 8008daa:	9300      	str	r3, [sp, #0]

#if STM32_SDC_SDIO_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 8008dac:	9b01      	ldr	r3, [sp, #4]
 8008dae:	f003 0303 	and.w	r3, r3, #3
 8008db2:	2b00      	cmp	r3, #0
 8008db4:	d026      	beq.n	8008e04 <sdc_lld_write+0x64>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 8008db6:	2300      	movs	r3, #0
 8008db8:	9305      	str	r3, [sp, #20]
 8008dba:	e01d      	b.n	8008df8 <sdc_lld_write+0x58>
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
 8008dbc:	4a17      	ldr	r2, [pc, #92]	; (8008e1c <sdc_lld_write+0x7c>)
 8008dbe:	9b01      	ldr	r3, [sp, #4]
 8008dc0:	4610      	mov	r0, r2
 8008dc2:	4619      	mov	r1, r3
 8008dc4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008dc8:	461a      	mov	r2, r3
 8008dca:	f7f7 faa9 	bl	8000320 <memcpy>
      buf += MMCSD_BLOCK_SIZE;
 8008dce:	9b01      	ldr	r3, [sp, #4]
 8008dd0:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8008dd4:	9301      	str	r3, [sp, #4]
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
 8008dd6:	2301      	movs	r3, #1
 8008dd8:	4a10      	ldr	r2, [pc, #64]	; (8008e1c <sdc_lld_write+0x7c>)
 8008dda:	9902      	ldr	r1, [sp, #8]
 8008ddc:	9803      	ldr	r0, [sp, #12]
 8008dde:	f7ff ff2f 	bl	8008c40 <sdc_lld_write_aligned>
 8008de2:	4603      	mov	r3, r0
 8008de4:	2b00      	cmp	r3, #0
 8008de6:	d001      	beq.n	8008dec <sdc_lld_write+0x4c>
        return HAL_FAILED;
 8008de8:	2301      	movs	r3, #1
 8008dea:	e012      	b.n	8008e12 <sdc_lld_write+0x72>
      startblk++;
 8008dec:	9b02      	ldr	r3, [sp, #8]
 8008dee:	3301      	adds	r3, #1
 8008df0:	9302      	str	r3, [sp, #8]
    for (i = 0; i < blocks; i++) {
 8008df2:	9b05      	ldr	r3, [sp, #20]
 8008df4:	3301      	adds	r3, #1
 8008df6:	9305      	str	r3, [sp, #20]
 8008df8:	9a05      	ldr	r2, [sp, #20]
 8008dfa:	9b00      	ldr	r3, [sp, #0]
 8008dfc:	429a      	cmp	r2, r3
 8008dfe:	d3dd      	bcc.n	8008dbc <sdc_lld_write+0x1c>
    }
    return HAL_SUCCESS;
 8008e00:	2300      	movs	r3, #0
 8008e02:	e006      	b.n	8008e12 <sdc_lld_write+0x72>
  }
#endif /* STM32_SDC_SDIO_UNALIGNED_SUPPORT */
  return sdc_lld_write_aligned(sdcp, startblk, buf, blocks);
 8008e04:	9b00      	ldr	r3, [sp, #0]
 8008e06:	9a01      	ldr	r2, [sp, #4]
 8008e08:	9902      	ldr	r1, [sp, #8]
 8008e0a:	9803      	ldr	r0, [sp, #12]
 8008e0c:	f7ff ff18 	bl	8008c40 <sdc_lld_write_aligned>
 8008e10:	4603      	mov	r3, r0
}
 8008e12:	4618      	mov	r0, r3
 8008e14:	b007      	add	sp, #28
 8008e16:	f85d fb04 	ldr.w	pc, [sp], #4
 8008e1a:	bf00      	nop
 8008e1c:	20002748 	.word	0x20002748

08008e20 <sdc_lld_sync>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdc_lld_sync(SDCDriver *sdcp) {
 8008e20:	b082      	sub	sp, #8
 8008e22:	9001      	str	r0, [sp, #4]

  /* TODO: Implement.*/
  (void)sdcp;
  return HAL_SUCCESS;
 8008e24:	2300      	movs	r3, #0
}
 8008e26:	4618      	mov	r0, r3
 8008e28:	b002      	add	sp, #8
 8008e2a:	4770      	bx	lr
 8008e2c:	0000      	movs	r0, r0
	...

08008e30 <port_lock.lto_priv.129>:
static inline void port_lock(void) {
 8008e30:	b082      	sub	sp, #8
 8008e32:	2320      	movs	r3, #32
 8008e34:	9301      	str	r3, [sp, #4]
 8008e36:	9b01      	ldr	r3, [sp, #4]
 8008e38:	f383 8811 	msr	BASEPRI, r3
}
 8008e3c:	b002      	add	sp, #8
 8008e3e:	4770      	bx	lr

08008e40 <port_unlock.lto_priv.99>:
static inline void port_unlock(void) {
 8008e40:	b082      	sub	sp, #8
 8008e42:	2300      	movs	r3, #0
 8008e44:	9301      	str	r3, [sp, #4]
 8008e46:	9b01      	ldr	r3, [sp, #4]
 8008e48:	f383 8811 	msr	BASEPRI, r3
}
 8008e4c:	b002      	add	sp, #8
 8008e4e:	4770      	bx	lr

08008e50 <port_lock_from_isr.lto_priv.192>:
static inline void port_lock_from_isr(void) {
 8008e50:	b508      	push	{r3, lr}
  port_lock();
 8008e52:	f7ff ffed 	bl	8008e30 <port_lock.lto_priv.129>
}
 8008e56:	bd08      	pop	{r3, pc}
	...

08008e60 <port_unlock_from_isr.lto_priv.179>:
static inline void port_unlock_from_isr(void) {
 8008e60:	b508      	push	{r3, lr}
  port_unlock();
 8008e62:	f7ff ffed 	bl	8008e40 <port_unlock.lto_priv.99>
}
 8008e66:	bd08      	pop	{r3, pc}
	...

08008e70 <chSysLockFromISR.lto_priv.166>:
static inline void chSysLockFromISR(void) {
 8008e70:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8008e72:	f7ff ffed 	bl	8008e50 <port_lock_from_isr.lto_priv.192>
  _stats_start_measure_crit_isr();
 8008e76:	f7f8 fd43 	bl	8001900 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8008e7a:	f7f7 fd81 	bl	8000980 <_dbg_check_lock_from_isr>
}
 8008e7e:	bd08      	pop	{r3, pc}

08008e80 <chSysUnlockFromISR.lto_priv.156>:
static inline void chSysUnlockFromISR(void) {
 8008e80:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 8008e82:	f7f7 fd95 	bl	80009b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8008e86:	f7f8 fd43 	bl	8001910 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 8008e8a:	f7ff ffe9 	bl	8008e60 <port_unlock_from_isr.lto_priv.179>
}
 8008e8e:	bd08      	pop	{r3, pc}

08008e90 <chOQIsEmptyI.lto_priv.207>:
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8008e90:	b500      	push	{lr}
 8008e92:	b083      	sub	sp, #12
 8008e94:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8008e96:	f7f7 fde3 	bl	8000a60 <chDbgCheckClassI>
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8008e9a:	9b01      	ldr	r3, [sp, #4]
 8008e9c:	695a      	ldr	r2, [r3, #20]
 8008e9e:	9b01      	ldr	r3, [sp, #4]
 8008ea0:	699b      	ldr	r3, [r3, #24]
 8008ea2:	429a      	cmp	r2, r3
 8008ea4:	d105      	bne.n	8008eb2 <chOQIsEmptyI.lto_priv.207+0x22>
 8008ea6:	9b01      	ldr	r3, [sp, #4]
 8008ea8:	689b      	ldr	r3, [r3, #8]
 8008eaa:	2b00      	cmp	r3, #0
 8008eac:	d001      	beq.n	8008eb2 <chOQIsEmptyI.lto_priv.207+0x22>
 8008eae:	2301      	movs	r3, #1
 8008eb0:	e000      	b.n	8008eb4 <chOQIsEmptyI.lto_priv.207+0x24>
 8008eb2:	2300      	movs	r3, #0
 8008eb4:	f003 0301 	and.w	r3, r3, #1
 8008eb8:	b2db      	uxtb	r3, r3
}
 8008eba:	4618      	mov	r0, r3
 8008ebc:	b003      	add	sp, #12
 8008ebe:	f85d fb04 	ldr.w	pc, [sp], #4
 8008ec2:	bf00      	nop
	...

08008ed0 <osalSysLockFromISR.lto_priv.146>:
static inline void osalSysLockFromISR(void) {
 8008ed0:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8008ed2:	f7ff ffcd 	bl	8008e70 <chSysLockFromISR.lto_priv.166>
}
 8008ed6:	bd08      	pop	{r3, pc}
	...

08008ee0 <osalSysUnlockFromISR.lto_priv.138>:
static inline void osalSysUnlockFromISR(void) {
 8008ee0:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8008ee2:	f7ff ffcd 	bl	8008e80 <chSysUnlockFromISR.lto_priv.156>
}
 8008ee6:	bd08      	pop	{r3, pc}
	...

08008ef0 <osalEventBroadcastFlagsI.lto_priv.205>:
                                            eventflags_t flags) {
 8008ef0:	b500      	push	{lr}
 8008ef2:	b083      	sub	sp, #12
 8008ef4:	9001      	str	r0, [sp, #4]
 8008ef6:	9100      	str	r1, [sp, #0]
  chEvtBroadcastFlagsI(esp, flags);
 8008ef8:	9900      	ldr	r1, [sp, #0]
 8008efa:	9801      	ldr	r0, [sp, #4]
 8008efc:	f7f8 fee8 	bl	8001cd0 <chEvtBroadcastFlagsI>
}
 8008f00:	b003      	add	sp, #12
 8008f02:	f85d fb04 	ldr.w	pc, [sp], #4
 8008f06:	bf00      	nop
	...

08008f10 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 8008f10:	b084      	sub	sp, #16
 8008f12:	9001      	str	r0, [sp, #4]
 8008f14:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 8008f16:	9b01      	ldr	r3, [sp, #4]
 8008f18:	f8d3 3254 	ldr.w	r3, [r3, #596]	; 0x254
 8008f1c:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8008f1e:	9b01      	ldr	r3, [sp, #4]
 8008f20:	f8d3 3254 	ldr.w	r3, [r3, #596]	; 0x254
 8008f24:	4a1d      	ldr	r2, [pc, #116]	; (8008f9c <usart_init+0x8c>)
 8008f26:	4293      	cmp	r3, r2
 8008f28:	d005      	beq.n	8008f36 <usart_init+0x26>
 8008f2a:	9b01      	ldr	r3, [sp, #4]
 8008f2c:	f8d3 3254 	ldr.w	r3, [r3, #596]	; 0x254
 8008f30:	4a1b      	ldr	r2, [pc, #108]	; (8008fa0 <usart_init+0x90>)
 8008f32:	4293      	cmp	r3, r2
 8008f34:	d107      	bne.n	8008f46 <usart_init+0x36>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8008f36:	9b00      	ldr	r3, [sp, #0]
 8008f38:	681b      	ldr	r3, [r3, #0]
 8008f3a:	4a1a      	ldr	r2, [pc, #104]	; (8008fa4 <usart_init+0x94>)
 8008f3c:	fbb2 f2f3 	udiv	r2, r2, r3
 8008f40:	9b03      	ldr	r3, [sp, #12]
 8008f42:	609a      	str	r2, [r3, #8]
 8008f44:	e006      	b.n	8008f54 <usart_init+0x44>
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8008f46:	9b00      	ldr	r3, [sp, #0]
 8008f48:	681b      	ldr	r3, [r3, #0]
 8008f4a:	4a17      	ldr	r2, [pc, #92]	; (8008fa8 <usart_init+0x98>)
 8008f4c:	fbb2 f2f3 	udiv	r2, r2, r3
 8008f50:	9b03      	ldr	r3, [sp, #12]
 8008f52:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8008f54:	9b00      	ldr	r3, [sp, #0]
 8008f56:	88db      	ldrh	r3, [r3, #6]
 8008f58:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008f5c:	b29b      	uxth	r3, r3
 8008f5e:	461a      	mov	r2, r3
 8008f60:	9b03      	ldr	r3, [sp, #12]
 8008f62:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8008f64:	9b00      	ldr	r3, [sp, #0]
 8008f66:	891b      	ldrh	r3, [r3, #8]
 8008f68:	f043 0301 	orr.w	r3, r3, #1
 8008f6c:	b29b      	uxth	r3, r3
 8008f6e:	461a      	mov	r2, r3
 8008f70:	9b03      	ldr	r3, [sp, #12]
 8008f72:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8008f74:	9b00      	ldr	r3, [sp, #0]
 8008f76:	889b      	ldrh	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8008f78:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
 8008f7c:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 8008f80:	b29b      	uxth	r3, r3
 8008f82:	461a      	mov	r2, r3
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8008f84:	9b03      	ldr	r3, [sp, #12]
 8008f86:	60da      	str	r2, [r3, #12]
                         USART_CR1_RE;
  u->SR = 0;
 8008f88:	9b03      	ldr	r3, [sp, #12]
 8008f8a:	2200      	movs	r2, #0
 8008f8c:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8008f8e:	9b03      	ldr	r3, [sp, #12]
 8008f90:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8008f92:	9b03      	ldr	r3, [sp, #12]
 8008f94:	685b      	ldr	r3, [r3, #4]
}
 8008f96:	b004      	add	sp, #16
 8008f98:	4770      	bx	lr
 8008f9a:	bf00      	nop
 8008f9c:	40011000 	.word	0x40011000
 8008fa0:	40011400 	.word	0x40011400
 8008fa4:	0501bd00 	.word	0x0501bd00
 8008fa8:	0280de80 	.word	0x0280de80
 8008fac:	00000000 	.word	0x00000000

08008fb0 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
 8008fb0:	b500      	push	{lr}
 8008fb2:	b085      	sub	sp, #20
 8008fb4:	9001      	str	r0, [sp, #4]
 8008fb6:	460b      	mov	r3, r1
 8008fb8:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
 8008fbc:	2300      	movs	r3, #0
 8008fbe:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
 8008fc0:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8008fc4:	f003 0308 	and.w	r3, r3, #8
 8008fc8:	2b00      	cmp	r3, #0
 8008fca:	d003      	beq.n	8008fd4 <set_error+0x24>
    sts |= SD_OVERRUN_ERROR;
 8008fcc:	9b03      	ldr	r3, [sp, #12]
 8008fce:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8008fd2:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
 8008fd4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8008fd8:	f003 0301 	and.w	r3, r3, #1
 8008fdc:	2b00      	cmp	r3, #0
 8008fde:	d003      	beq.n	8008fe8 <set_error+0x38>
    sts |= SD_PARITY_ERROR;
 8008fe0:	9b03      	ldr	r3, [sp, #12]
 8008fe2:	f043 0320 	orr.w	r3, r3, #32
 8008fe6:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
 8008fe8:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8008fec:	f003 0302 	and.w	r3, r3, #2
 8008ff0:	2b00      	cmp	r3, #0
 8008ff2:	d003      	beq.n	8008ffc <set_error+0x4c>
    sts |= SD_FRAMING_ERROR;
 8008ff4:	9b03      	ldr	r3, [sp, #12]
 8008ff6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008ffa:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
 8008ffc:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8009000:	f003 0304 	and.w	r3, r3, #4
 8009004:	2b00      	cmp	r3, #0
 8009006:	d003      	beq.n	8009010 <set_error+0x60>
    sts |= SD_NOISE_ERROR;
 8009008:	9b03      	ldr	r3, [sp, #12]
 800900a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800900e:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
 8009010:	9b01      	ldr	r3, [sp, #4]
 8009012:	3304      	adds	r3, #4
 8009014:	9903      	ldr	r1, [sp, #12]
 8009016:	4618      	mov	r0, r3
 8009018:	f7ff ff6a 	bl	8008ef0 <osalEventBroadcastFlagsI.lto_priv.205>
}
 800901c:	b005      	add	sp, #20
 800901e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009022:	bf00      	nop
	...

08009030 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8009030:	b500      	push	{lr}
 8009032:	b089      	sub	sp, #36	; 0x24
 8009034:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8009036:	9b01      	ldr	r3, [sp, #4]
 8009038:	f8d3 3254 	ldr.w	r3, [r3, #596]	; 0x254
 800903c:	9306      	str	r3, [sp, #24]
  uint16_t cr1 = u->CR1;
 800903e:	9b06      	ldr	r3, [sp, #24]
 8009040:	68db      	ldr	r3, [r3, #12]
 8009042:	f8ad 3016 	strh.w	r3, [sp, #22]
  uint16_t sr = u->SR;
 8009046:	9b06      	ldr	r3, [sp, #24]
 8009048:	681b      	ldr	r3, [r3, #0]
 800904a:	f8ad 301e 	strh.w	r3, [sp, #30]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 800904e:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8009052:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8009056:	2b00      	cmp	r3, #0
 8009058:	d00e      	beq.n	8009078 <serve_interrupt+0x48>
    osalSysLockFromISR();
 800905a:	f7ff ff39 	bl	8008ed0 <osalSysLockFromISR.lto_priv.146>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 800905e:	9b01      	ldr	r3, [sp, #4]
 8009060:	3304      	adds	r3, #4
 8009062:	f44f 7100 	mov.w	r1, #512	; 0x200
 8009066:	4618      	mov	r0, r3
 8009068:	f7ff ff42 	bl	8008ef0 <osalEventBroadcastFlagsI.lto_priv.205>
    u->SR = ~USART_SR_LBD;
 800906c:	9b06      	ldr	r3, [sp, #24]
 800906e:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8009072:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8009074:	f7ff ff34 	bl	8008ee0 <osalSysUnlockFromISR.lto_priv.138>
  }

  /* Data available.*/
  osalSysLockFromISR();
 8009078:	f7ff ff2a 	bl	8008ed0 <osalSysLockFromISR.lto_priv.146>
 800907c:	e01f      	b.n	80090be <serve_interrupt+0x8e>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 800907e:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8009082:	f003 030f 	and.w	r3, r3, #15
 8009086:	2b00      	cmp	r3, #0
 8009088:	d005      	beq.n	8009096 <serve_interrupt+0x66>
      set_error(sdp, sr);
 800908a:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 800908e:	4619      	mov	r1, r3
 8009090:	9801      	ldr	r0, [sp, #4]
 8009092:	f7ff ff8d 	bl	8008fb0 <set_error>
    b = u->DR;
 8009096:	9b06      	ldr	r3, [sp, #24]
 8009098:	685b      	ldr	r3, [r3, #4]
 800909a:	f88d 300f 	strb.w	r3, [sp, #15]
    if (sr & USART_SR_RXNE)
 800909e:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 80090a2:	f003 0320 	and.w	r3, r3, #32
 80090a6:	2b00      	cmp	r3, #0
 80090a8:	d005      	beq.n	80090b6 <serve_interrupt+0x86>
      sdIncomingDataI(sdp, b);
 80090aa:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80090ae:	4619      	mov	r1, r3
 80090b0:	9801      	ldr	r0, [sp, #4]
 80090b2:	f7fb fa55 	bl	8004560 <sdIncomingDataI>
    sr = u->SR;
 80090b6:	9b06      	ldr	r3, [sp, #24]
 80090b8:	681b      	ldr	r3, [r3, #0]
 80090ba:	f8ad 301e 	strh.w	r3, [sp, #30]
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80090be:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 80090c2:	f003 032f 	and.w	r3, r3, #47	; 0x2f
 80090c6:	2b00      	cmp	r3, #0
 80090c8:	d1d9      	bne.n	800907e <serve_interrupt+0x4e>
  }
  osalSysUnlockFromISR();
 80090ca:	f7ff ff09 	bl	8008ee0 <osalSysUnlockFromISR.lto_priv.138>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 80090ce:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 80090d2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80090d6:	2b00      	cmp	r3, #0
 80090d8:	d024      	beq.n	8009124 <serve_interrupt+0xf4>
 80090da:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 80090de:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80090e2:	2b00      	cmp	r3, #0
 80090e4:	d01e      	beq.n	8009124 <serve_interrupt+0xf4>
    msg_t b;
    osalSysLockFromISR();
 80090e6:	f7ff fef3 	bl	8008ed0 <osalSysLockFromISR.lto_priv.146>
    b = oqGetI(&sdp->oqueue);
 80090ea:	9b01      	ldr	r3, [sp, #4]
 80090ec:	3330      	adds	r3, #48	; 0x30
 80090ee:	4618      	mov	r0, r3
 80090f0:	f7f9 fa26 	bl	8002540 <chOQGetI>
 80090f4:	9004      	str	r0, [sp, #16]
    if (b < Q_OK) {
 80090f6:	9b04      	ldr	r3, [sp, #16]
 80090f8:	2b00      	cmp	r3, #0
 80090fa:	da0e      	bge.n	800911a <serve_interrupt+0xea>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 80090fc:	9b01      	ldr	r3, [sp, #4]
 80090fe:	3304      	adds	r3, #4
 8009100:	2108      	movs	r1, #8
 8009102:	4618      	mov	r0, r3
 8009104:	f7ff fef4 	bl	8008ef0 <osalEventBroadcastFlagsI.lto_priv.205>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8009108:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800910c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8009110:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8009114:	9b06      	ldr	r3, [sp, #24]
 8009116:	60da      	str	r2, [r3, #12]
 8009118:	e002      	b.n	8009120 <serve_interrupt+0xf0>
    }
    else
      u->DR = b;
 800911a:	9a04      	ldr	r2, [sp, #16]
 800911c:	9b06      	ldr	r3, [sp, #24]
 800911e:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
 8009120:	f7ff fede 	bl	8008ee0 <osalSysUnlockFromISR.lto_priv.138>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8009124:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 8009128:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800912c:	2b00      	cmp	r3, #0
 800912e:	d01b      	beq.n	8009168 <serve_interrupt+0x138>
    osalSysLockFromISR();
 8009130:	f7ff fece 	bl	8008ed0 <osalSysLockFromISR.lto_priv.146>
    if (oqIsEmptyI(&sdp->oqueue))
 8009134:	9b01      	ldr	r3, [sp, #4]
 8009136:	3330      	adds	r3, #48	; 0x30
 8009138:	4618      	mov	r0, r3
 800913a:	f7ff fea9 	bl	8008e90 <chOQIsEmptyI.lto_priv.207>
 800913e:	4603      	mov	r3, r0
 8009140:	2b00      	cmp	r3, #0
 8009142:	d005      	beq.n	8009150 <serve_interrupt+0x120>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8009144:	9b01      	ldr	r3, [sp, #4]
 8009146:	3304      	adds	r3, #4
 8009148:	2110      	movs	r1, #16
 800914a:	4618      	mov	r0, r3
 800914c:	f7ff fed0 	bl	8008ef0 <osalEventBroadcastFlagsI.lto_priv.205>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8009150:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8009154:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8009158:	9b06      	ldr	r3, [sp, #24]
 800915a:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
 800915c:	9b06      	ldr	r3, [sp, #24]
 800915e:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8009162:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8009164:	f7ff febc 	bl	8008ee0 <osalSysUnlockFromISR.lto_priv.138>
  }
}
 8009168:	b009      	add	sp, #36	; 0x24
 800916a:	f85d fb04 	ldr.w	pc, [sp], #4
 800916e:	bf00      	nop

08009170 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
 8009170:	b082      	sub	sp, #8
 8009172:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8009174:	4b03      	ldr	r3, [pc, #12]	; (8009184 <notify1+0x14>)
 8009176:	68db      	ldr	r3, [r3, #12]
 8009178:	4a02      	ldr	r2, [pc, #8]	; (8009184 <notify1+0x14>)
 800917a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800917e:	60d3      	str	r3, [r2, #12]
}
 8009180:	b002      	add	sp, #8
 8009182:	4770      	bx	lr
 8009184:	40011000 	.word	0x40011000
	...

08009190 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8009190:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8009192:	f7f8 fb75 	bl	8001880 <_stats_increase_irq>
 8009196:	f7f7 fc23 	bl	80009e0 <_dbg_check_enter_isr>

  serve_interrupt(&SD1);
 800919a:	4804      	ldr	r0, [pc, #16]	; (80091ac <VectorD4+0x1c>)
 800919c:	f7ff ff48 	bl	8009030 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 80091a0:	f7f7 fc3e 	bl	8000a20 <_dbg_check_leave_isr>
 80091a4:	f7f9 fc3c 	bl	8002a20 <_port_irq_epilogue>
}
 80091a8:	bd08      	pop	{r3, pc}
 80091aa:	bf00      	nop
 80091ac:	20002948 	.word	0x20002948

080091b0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 80091b0:	b508      	push	{r3, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 80091b2:	4a05      	ldr	r2, [pc, #20]	; (80091c8 <sd_lld_init+0x18>)
 80091b4:	2100      	movs	r1, #0
 80091b6:	4805      	ldr	r0, [pc, #20]	; (80091cc <sd_lld_init+0x1c>)
 80091b8:	f7fb f97a 	bl	80044b0 <sdObjectInit>
  SD1.usart = USART1;
 80091bc:	4b03      	ldr	r3, [pc, #12]	; (80091cc <sd_lld_init+0x1c>)
 80091be:	4a04      	ldr	r2, [pc, #16]	; (80091d0 <sd_lld_init+0x20>)
 80091c0:	f8c3 2254 	str.w	r2, [r3, #596]	; 0x254

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
 80091c4:	bd08      	pop	{r3, pc}
 80091c6:	bf00      	nop
 80091c8:	08009171 	.word	0x08009171
 80091cc:	20002948 	.word	0x20002948
 80091d0:	40011000 	.word	0x40011000
	...

080091e0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 80091e0:	b500      	push	{lr}
 80091e2:	b083      	sub	sp, #12
 80091e4:	9001      	str	r0, [sp, #4]
 80091e6:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 80091e8:	9b00      	ldr	r3, [sp, #0]
 80091ea:	2b00      	cmp	r3, #0
 80091ec:	d101      	bne.n	80091f2 <sd_lld_start+0x12>
    config = &default_config;
 80091ee:	4b0d      	ldr	r3, [pc, #52]	; (8009224 <sd_lld_start+0x44>)
 80091f0:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 80091f2:	9b01      	ldr	r3, [sp, #4]
 80091f4:	7a1b      	ldrb	r3, [r3, #8]
 80091f6:	2b01      	cmp	r3, #1
 80091f8:	d10d      	bne.n	8009216 <sd_lld_start+0x36>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 80091fa:	9b01      	ldr	r3, [sp, #4]
 80091fc:	4a0a      	ldr	r2, [pc, #40]	; (8009228 <sd_lld_start+0x48>)
 80091fe:	4293      	cmp	r3, r2
 8009200:	d109      	bne.n	8009216 <sd_lld_start+0x36>
      rccEnableUSART1(FALSE);
 8009202:	4b0a      	ldr	r3, [pc, #40]	; (800922c <sd_lld_start+0x4c>)
 8009204:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009206:	4a09      	ldr	r2, [pc, #36]	; (800922c <sd_lld_start+0x4c>)
 8009208:	f043 0310 	orr.w	r3, r3, #16
 800920c:	6453      	str	r3, [r2, #68]	; 0x44
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 800920e:	210c      	movs	r1, #12
 8009210:	2025      	movs	r0, #37	; 0x25
 8009212:	f7fc fd55 	bl	8005cc0 <nvicEnableVector>
      rccEnableUART8(FALSE);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
 8009216:	9900      	ldr	r1, [sp, #0]
 8009218:	9801      	ldr	r0, [sp, #4]
 800921a:	f7ff fe79 	bl	8008f10 <usart_init>
}
 800921e:	b003      	add	sp, #12
 8009220:	f85d fb04 	ldr.w	pc, [sp], #4
 8009224:	0800aca0 	.word	0x0800aca0
 8009228:	20002948 	.word	0x20002948
 800922c:	40023800 	.word	0x40023800

08009230 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8009230:	b508      	push	{r3, lr}

  stm32_clock_init();
 8009232:	f7fc fded 	bl	8005e10 <stm32_clock_init>
}
 8009236:	bd08      	pop	{r3, pc}
	...

08009240 <sdc_lld_is_card_inserted>:

#if HAL_USE_SDC || defined(__DOXYGEN__)
/**
 * @brief   SDC card detection.
 */
bool sdc_lld_is_card_inserted(SDCDriver *sdcp) {
 8009240:	b082      	sub	sp, #8
 8009242:	9001      	str	r0, [sp, #4]

  (void)sdcp;
  return true;
 8009244:	2301      	movs	r3, #1
}
 8009246:	4618      	mov	r0, r3
 8009248:	b002      	add	sp, #8
 800924a:	4770      	bx	lr
 800924c:	0000      	movs	r0, r0
	...

08009250 <sdc_lld_is_write_protected>:

/**
 * @brief   SDC card write protection detection.
 */
bool sdc_lld_is_write_protected(SDCDriver *sdcp) {
 8009250:	b082      	sub	sp, #8
 8009252:	9001      	str	r0, [sp, #4]

  (void)sdcp;
  return false;
 8009254:	2300      	movs	r3, #0
}
 8009256:	4618      	mov	r0, r3
 8009258:	b002      	add	sp, #8
 800925a:	4770      	bx	lr
 800925c:	0000      	movs	r0, r0
	...

08009260 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8009260:	4770      	bx	lr
 8009262:	bf00      	nop
	...

08009270 <main>:
#include "cs2100.h"
#include "gps.h"
#include "usb_serial_link.h"


int main(void) {
 8009270:	b508      	push	{r3, lr}

    /* Allow debug access during WFI sleep */
    DBGMCU->CR |= DBGMCU_CR_DBG_SLEEP;
 8009272:	4b10      	ldr	r3, [pc, #64]	; (80092b4 <main+0x44>)
 8009274:	685b      	ldr	r3, [r3, #4]
 8009276:	4a0f      	ldr	r2, [pc, #60]	; (80092b4 <main+0x44>)
 8009278:	f043 0301 	orr.w	r3, r3, #1
 800927c:	6053      	str	r3, [r2, #4]

    /* Initialise ChibiOS */
    halInit();
 800927e:	f7f9 fc17 	bl	8002ab0 <halInit>
    chSysInit();
 8009282:	f7f7 fa75 	bl	8000770 <chSysInit>

    /* Start USB System */
    usb_serial_init();
 8009286:	f000 ffc3 	bl	800a210 <usb_serial_init>
    
    /* Let USB Connect */
    chThdSleepMilliseconds(3000);
 800928a:	f247 5030 	movw	r0, #30000	; 0x7530
 800928e:	f7f8 f8ff 	bl	8001490 <chThdSleep>
    
    /* Configure GPS to Produce 4MHz Signal */
    gps_init(&SD1, true, false, true);
 8009292:	2301      	movs	r3, #1
 8009294:	2200      	movs	r2, #0
 8009296:	2101      	movs	r1, #1
 8009298:	4807      	ldr	r0, [pc, #28]	; (80092b8 <main+0x48>)
 800929a:	f000 fd69 	bl	8009d70 <gps_init>

    /* Configure CS2100 */
    //cs2100_configure(&I2CD1);
    
    /* Start GPS State Machine */
    gps_thd_init();
 800929e:	f000 fddf 	bl	8009e60 <gps_thd_init>

    /* Turn on STAT LED */
    set_status(STATUS_GOOD);
 80092a2:	2001      	movs	r0, #1
 80092a4:	f000 fdf4 	bl	8009e90 <set_status>

    /* Main Loop */
    while (true) {

        /* Do nothing */
        chThdSleepMilliseconds(1000);
 80092a8:	f242 7010 	movw	r0, #10000	; 0x2710
 80092ac:	f7f8 f8f0 	bl	8001490 <chThdSleep>
 80092b0:	e7fa      	b.n	80092a8 <main+0x38>
 80092b2:	bf00      	nop
 80092b4:	e0042000 	.word	0xe0042000
 80092b8:	20002948 	.word	0x20002948
 80092bc:	00000000 	.word	0x00000000

080092c0 <chRegSetThreadName.lto_priv.2>:
static inline void chRegSetThreadName(const char *name) {
 80092c0:	b082      	sub	sp, #8
 80092c2:	9001      	str	r0, [sp, #4]
  ch.rlist.r_current->p_name = name;
 80092c4:	4b02      	ldr	r3, [pc, #8]	; (80092d0 <chRegSetThreadName.lto_priv.2+0x10>)
 80092c6:	699b      	ldr	r3, [r3, #24]
 80092c8:	9a01      	ldr	r2, [sp, #4]
 80092ca:	619a      	str	r2, [r3, #24]
}
 80092cc:	b002      	add	sp, #8
 80092ce:	4770      	bx	lr
 80092d0:	20002128 	.word	0x20002128
	...

080092e0 <chIQGet>:
static inline msg_t chIQGet(input_queue_t *iqp) {
 80092e0:	b500      	push	{lr}
 80092e2:	b083      	sub	sp, #12
 80092e4:	9001      	str	r0, [sp, #4]
  return chIQGetTimeout(iqp, TIME_INFINITE);
 80092e6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80092ea:	9801      	ldr	r0, [sp, #4]
 80092ec:	f7f9 f810 	bl	8002310 <chIQGetTimeout>
 80092f0:	4603      	mov	r3, r0
}
 80092f2:	4618      	mov	r0, r3
 80092f4:	b003      	add	sp, #12
 80092f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80092fa:	bf00      	nop
 80092fc:	0000      	movs	r0, r0
	...

08009300 <gps_fletcher_8>:
} ubx_state;


/* Run the Fletcher-8 checksum, initialised to chk, over n bytes of buf */
static uint16_t gps_fletcher_8(uint16_t chk, uint8_t *buf, uint8_t n)
{
 8009300:	b084      	sub	sp, #16
 8009302:	4603      	mov	r3, r0
 8009304:	9100      	str	r1, [sp, #0]
 8009306:	f8ad 3006 	strh.w	r3, [sp, #6]
 800930a:	4613      	mov	r3, r2
 800930c:	f88d 3005 	strb.w	r3, [sp, #5]
    int i;
    uint8_t ck_a = chk & 0xff, ck_b = chk>>8;
 8009310:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8009314:	f88d 300b 	strb.w	r3, [sp, #11]
 8009318:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800931c:	0a1b      	lsrs	r3, r3, #8
 800931e:	b29b      	uxth	r3, r3
 8009320:	f88d 300a 	strb.w	r3, [sp, #10]

    /* Run Fletcher-8 algorithm */
    for(i=0; i<n; i++) {
 8009324:	2300      	movs	r3, #0
 8009326:	9303      	str	r3, [sp, #12]
 8009328:	e012      	b.n	8009350 <gps_fletcher_8+0x50>
        ck_a += buf[i];
 800932a:	9b03      	ldr	r3, [sp, #12]
 800932c:	9a00      	ldr	r2, [sp, #0]
 800932e:	4413      	add	r3, r2
 8009330:	781a      	ldrb	r2, [r3, #0]
 8009332:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8009336:	4413      	add	r3, r2
 8009338:	f88d 300b 	strb.w	r3, [sp, #11]
        ck_b += ck_a;
 800933c:	f89d 200a 	ldrb.w	r2, [sp, #10]
 8009340:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8009344:	4413      	add	r3, r2
 8009346:	f88d 300a 	strb.w	r3, [sp, #10]
    for(i=0; i<n; i++) {
 800934a:	9b03      	ldr	r3, [sp, #12]
 800934c:	3301      	adds	r3, #1
 800934e:	9303      	str	r3, [sp, #12]
 8009350:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8009354:	9a03      	ldr	r2, [sp, #12]
 8009356:	429a      	cmp	r2, r3
 8009358:	dbe7      	blt.n	800932a <gps_fletcher_8+0x2a>
    }

    return (ck_b<<8) | (ck_a);
 800935a:	f89d 300a 	ldrb.w	r3, [sp, #10]
 800935e:	021b      	lsls	r3, r3, #8
 8009360:	b21a      	sxth	r2, r3
 8009362:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8009366:	b21b      	sxth	r3, r3
 8009368:	4313      	orrs	r3, r2
 800936a:	b21b      	sxth	r3, r3
 800936c:	b29b      	uxth	r3, r3
}
 800936e:	4618      	mov	r0, r3
 8009370:	b004      	add	sp, #16
 8009372:	4770      	bx	lr
	...

08009380 <gps_checksum>:

/* Computes the Fletcher-8 checksum over buf, using its length fields
 * to determine how much to read, returning the new checksum.
 */
static void gps_checksum(uint8_t *buf)
{
 8009380:	b500      	push	{lr}
 8009382:	b085      	sub	sp, #20
 8009384:	9001      	str	r0, [sp, #4]
    uint16_t plen;

    /* Check SYNC bytes are correct */
    if(buf[0] != UBX_SYNC1 && buf[1] != UBX_SYNC2)
 8009386:	9b01      	ldr	r3, [sp, #4]
 8009388:	781b      	ldrb	r3, [r3, #0]
 800938a:	2bb5      	cmp	r3, #181	; 0xb5
 800938c:	d004      	beq.n	8009398 <gps_checksum+0x18>
 800938e:	9b01      	ldr	r3, [sp, #4]
 8009390:	3301      	adds	r3, #1
 8009392:	781b      	ldrb	r3, [r3, #0]
 8009394:	2b62      	cmp	r3, #98	; 0x62
 8009396:	d125      	bne.n	80093e4 <gps_checksum+0x64>
        return;

    /* Extract payload length */
    plen = ((uint16_t*)buf)[2];
 8009398:	9b01      	ldr	r3, [sp, #4]
 800939a:	889b      	ldrh	r3, [r3, #4]
 800939c:	f8ad 300e 	strh.w	r3, [sp, #14]

    uint16_t ck = gps_fletcher_8(0, &buf[2], plen+4);
 80093a0:	9b01      	ldr	r3, [sp, #4]
 80093a2:	1c99      	adds	r1, r3, #2
 80093a4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 80093a8:	b2db      	uxtb	r3, r3
 80093aa:	3304      	adds	r3, #4
 80093ac:	b2db      	uxtb	r3, r3
 80093ae:	461a      	mov	r2, r3
 80093b0:	2000      	movs	r0, #0
 80093b2:	f7ff ffa5 	bl	8009300 <gps_fletcher_8>
 80093b6:	4603      	mov	r3, r0
 80093b8:	f8ad 300c 	strh.w	r3, [sp, #12]

    /* Write new checksum to the buffer */
    buf[plen+6] = ck;
 80093bc:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 80093c0:	3306      	adds	r3, #6
 80093c2:	9a01      	ldr	r2, [sp, #4]
 80093c4:	4413      	add	r3, r2
 80093c6:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 80093ca:	b2d2      	uxtb	r2, r2
 80093cc:	701a      	strb	r2, [r3, #0]
    buf[plen+7] = ck >> 8;
 80093ce:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80093d2:	0a1b      	lsrs	r3, r3, #8
 80093d4:	b299      	uxth	r1, r3
 80093d6:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 80093da:	3307      	adds	r3, #7
 80093dc:	9a01      	ldr	r2, [sp, #4]
 80093de:	4413      	add	r3, r2
 80093e0:	b2ca      	uxtb	r2, r1
 80093e2:	701a      	strb	r2, [r3, #0]
}
 80093e4:	b005      	add	sp, #20
 80093e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80093ea:	bf00      	nop
 80093ec:	0000      	movs	r0, r0
	...

080093f0 <gps_transmit>:
/* Transmit a UBX message over the Serial.
 * Message length is determined from the UBX length field.
 * Checksum is added automatically.
 */
static bool gps_transmit(uint8_t *buf)
{
 80093f0:	b500      	push	{lr}
 80093f2:	b087      	sub	sp, #28
 80093f4:	9001      	str	r0, [sp, #4]
    size_t n, nwritten;
    systime_t timeout;

    /* Add checksum to outgoing message */
    gps_checksum(buf);
 80093f6:	9801      	ldr	r0, [sp, #4]
 80093f8:	f7ff ffc2 	bl	8009380 <gps_checksum>

    /* Determine length and thus suitable timeout in systicks (ms) */
    n = 8 + ((uint16_t*)buf)[2];
 80093fc:	9b01      	ldr	r3, [sp, #4]
 80093fe:	3304      	adds	r3, #4
 8009400:	881b      	ldrh	r3, [r3, #0]
 8009402:	3308      	adds	r3, #8
 8009404:	9305      	str	r3, [sp, #20]
    timeout = MS2ST(n*2);
 8009406:	9b05      	ldr	r3, [sp, #20]
 8009408:	f644 6220 	movw	r2, #20000	; 0x4e20
 800940c:	fb02 f303 	mul.w	r3, r2, r3
 8009410:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 8009414:	4a0c      	ldr	r2, [pc, #48]	; (8009448 <gps_transmit+0x58>)
 8009416:	fba2 2303 	umull	r2, r3, r2, r3
 800941a:	099b      	lsrs	r3, r3, #6
 800941c:	9304      	str	r3, [sp, #16]

    /* Transmit message */
    nwritten = sdWriteTimeout(gps_seriald, buf, n, timeout);
 800941e:	4b0b      	ldr	r3, [pc, #44]	; (800944c <gps_transmit+0x5c>)
 8009420:	681b      	ldr	r3, [r3, #0]
 8009422:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8009426:	9b04      	ldr	r3, [sp, #16]
 8009428:	9a05      	ldr	r2, [sp, #20]
 800942a:	9901      	ldr	r1, [sp, #4]
 800942c:	f7f9 f8b8 	bl	80025a0 <chOQWriteTimeout>
 8009430:	9003      	str	r0, [sp, #12]
    return nwritten == n;
 8009432:	9a03      	ldr	r2, [sp, #12]
 8009434:	9b05      	ldr	r3, [sp, #20]
 8009436:	429a      	cmp	r2, r3
 8009438:	bf0c      	ite	eq
 800943a:	2301      	moveq	r3, #1
 800943c:	2300      	movne	r3, #0
 800943e:	b2db      	uxtb	r3, r3
}
 8009440:	4618      	mov	r0, r3
 8009442:	b007      	add	sp, #28
 8009444:	f85d fb04 	ldr.w	pc, [sp], #4
 8009448:	10624dd3 	.word	0x10624dd3
 800944c:	20002ba0 	.word	0x20002ba0

08009450 <gps_tx_ack>:

/* Transmits a UBX message and blocks 
 * until a ACK/NAK is recieved in response
 */
static bool gps_tx_ack(uint8_t *buf)
{
 8009450:	b500      	push	{lr}
 8009452:	b085      	sub	sp, #20
 8009454:	9001      	str	r0, [sp, #4]
    if(!gps_transmit(buf)) {
 8009456:	9801      	ldr	r0, [sp, #4]
 8009458:	f7ff ffca 	bl	80093f0 <gps_transmit>
 800945c:	4603      	mov	r3, r0
 800945e:	f083 0301 	eor.w	r3, r3, #1
 8009462:	b2db      	uxtb	r3, r3
 8009464:	2b00      	cmp	r3, #0
 8009466:	d001      	beq.n	800946c <gps_tx_ack+0x1c>
        return false;
 8009468:	2300      	movs	r3, #0
 800946a:	e01f      	b.n	80094ac <gps_tx_ack+0x5c>
    }

    enum ublox_result r;
    do {
        r = ublox_state_machine(sdGet(gps_seriald));
 800946c:	4b11      	ldr	r3, [pc, #68]	; (80094b4 <gps_tx_ack+0x64>)
 800946e:	681b      	ldr	r3, [r3, #0]
 8009470:	330c      	adds	r3, #12
 8009472:	4618      	mov	r0, r3
 8009474:	f7ff ff34 	bl	80092e0 <chIQGet>
 8009478:	4603      	mov	r3, r0
 800947a:	b2db      	uxtb	r3, r3
 800947c:	4618      	mov	r0, r3
 800947e:	f000 f81f 	bl	80094c0 <ublox_state_machine>
 8009482:	4603      	mov	r3, r0
 8009484:	f88d 300f 	strb.w	r3, [sp, #15]
    } while( (r != UBLOX_ACK) && (r != UBLOX_NAK) );
 8009488:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800948c:	2b03      	cmp	r3, #3
 800948e:	d003      	beq.n	8009498 <gps_tx_ack+0x48>
 8009490:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8009494:	2b04      	cmp	r3, #4
 8009496:	d1e9      	bne.n	800946c <gps_tx_ack+0x1c>

    if(r == UBLOX_NAK){
 8009498:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800949c:	2b04      	cmp	r3, #4
 800949e:	d104      	bne.n	80094aa <gps_tx_ack+0x5a>
        set_status(STATUS_ERROR);
 80094a0:	2002      	movs	r0, #2
 80094a2:	f000 fcf5 	bl	8009e90 <set_status>
        return false;
 80094a6:	2300      	movs	r3, #0
 80094a8:	e000      	b.n	80094ac <gps_tx_ack+0x5c>
    }
    return true;
 80094aa:	2301      	movs	r3, #1
}
 80094ac:	4618      	mov	r0, r3
 80094ae:	b005      	add	sp, #20
 80094b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80094b4:	20002ba0 	.word	0x20002ba0
	...

080094c0 <ublox_state_machine>:
/* Run new byte b through the UBX decoding state machine. Note that this
 * function preserves static state and processes new messages as appropriate
 * once received.
 */
static enum ublox_result ublox_state_machine(uint8_t b)
{
 80094c0:	b500      	push	{lr}
 80094c2:	b0ab      	sub	sp, #172	; 0xac
 80094c4:	4603      	mov	r3, r0
 80094c6:	f88d 3007 	strb.w	r3, [sp, #7]
    ubx_cfg_nav5_t cfg_nav5;
    ublox_posecef_t posecef;
    ublox_pvt_t pvt_data;
    

    switch(state) {
 80094ca:	4bab      	ldr	r3, [pc, #684]	; (8009778 <ublox_state_machine+0x2b8>)
 80094cc:	781b      	ldrb	r3, [r3, #0]
 80094ce:	2b08      	cmp	r3, #8
 80094d0:	f200 8143 	bhi.w	800975a <ublox_state_machine+0x29a>
 80094d4:	a201      	add	r2, pc, #4	; (adr r2, 80094dc <ublox_state_machine+0x1c>)
 80094d6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80094da:	bf00      	nop
 80094dc:	08009501 	.word	0x08009501
 80094e0:	08009513 	.word	0x08009513
 80094e4:	0800952b 	.word	0x0800952b
 80094e8:	0800953b 	.word	0x0800953b
 80094ec:	0800954b 	.word	0x0800954b
 80094f0:	0800955d 	.word	0x0800955d
 80094f4:	0800975b 	.word	0x0800975b
 80094f8:	0800959d 	.word	0x0800959d
 80094fc:	080095d3 	.word	0x080095d3
        case STATE_IDLE:
            if(b == UBX_SYNC1)
 8009500:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009504:	2bb5      	cmp	r3, #181	; 0xb5
 8009506:	f040 8130 	bne.w	800976a <ublox_state_machine+0x2aa>
                state = STATE_SYNC1;
 800950a:	4b9b      	ldr	r3, [pc, #620]	; (8009778 <ublox_state_machine+0x2b8>)
 800950c:	2201      	movs	r2, #1
 800950e:	701a      	strb	r2, [r3, #0]
 8009510:	e12c      	b.n	800976c <ublox_state_machine+0x2ac>
            break;

        case STATE_SYNC1:
            if(b == UBX_SYNC2)
 8009512:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009516:	2b62      	cmp	r3, #98	; 0x62
 8009518:	d103      	bne.n	8009522 <ublox_state_machine+0x62>
                state = STATE_SYNC2;
 800951a:	4b97      	ldr	r3, [pc, #604]	; (8009778 <ublox_state_machine+0x2b8>)
 800951c:	2202      	movs	r2, #2
 800951e:	701a      	strb	r2, [r3, #0]
            else
                state = STATE_IDLE;
 8009520:	e124      	b.n	800976c <ublox_state_machine+0x2ac>
 8009522:	4b95      	ldr	r3, [pc, #596]	; (8009778 <ublox_state_machine+0x2b8>)
 8009524:	2200      	movs	r2, #0
 8009526:	701a      	strb	r2, [r3, #0]
 8009528:	e120      	b.n	800976c <ublox_state_machine+0x2ac>
            break;

        case STATE_SYNC2:
            class = b;
 800952a:	4a94      	ldr	r2, [pc, #592]	; (800977c <ublox_state_machine+0x2bc>)
 800952c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009530:	7013      	strb	r3, [r2, #0]
            state = STATE_CLASS;
 8009532:	4b91      	ldr	r3, [pc, #580]	; (8009778 <ublox_state_machine+0x2b8>)
 8009534:	2203      	movs	r2, #3
 8009536:	701a      	strb	r2, [r3, #0]
 8009538:	e118      	b.n	800976c <ublox_state_machine+0x2ac>
            break;

        case STATE_CLASS:
            id = b;
 800953a:	4a91      	ldr	r2, [pc, #580]	; (8009780 <ublox_state_machine+0x2c0>)
 800953c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009540:	7013      	strb	r3, [r2, #0]
            state = STATE_ID;
 8009542:	4b8d      	ldr	r3, [pc, #564]	; (8009778 <ublox_state_machine+0x2b8>)
 8009544:	2204      	movs	r2, #4
 8009546:	701a      	strb	r2, [r3, #0]
 8009548:	e110      	b.n	800976c <ublox_state_machine+0x2ac>
            break;

        case STATE_ID:
            length = (uint16_t)b;
 800954a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800954e:	b29a      	uxth	r2, r3
 8009550:	4b8c      	ldr	r3, [pc, #560]	; (8009784 <ublox_state_machine+0x2c4>)
 8009552:	801a      	strh	r2, [r3, #0]
            state = STATE_L1;
 8009554:	4b88      	ldr	r3, [pc, #544]	; (8009778 <ublox_state_machine+0x2b8>)
 8009556:	2205      	movs	r2, #5
 8009558:	701a      	strb	r2, [r3, #0]
 800955a:	e107      	b.n	800976c <ublox_state_machine+0x2ac>
            break;

        case STATE_L1:
            length |= (uint16_t)b << 8;
 800955c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009560:	021b      	lsls	r3, r3, #8
 8009562:	b21a      	sxth	r2, r3
 8009564:	4b87      	ldr	r3, [pc, #540]	; (8009784 <ublox_state_machine+0x2c4>)
 8009566:	881b      	ldrh	r3, [r3, #0]
 8009568:	b21b      	sxth	r3, r3
 800956a:	4313      	orrs	r3, r2
 800956c:	b21b      	sxth	r3, r3
 800956e:	b29a      	uxth	r2, r3
 8009570:	4b84      	ldr	r3, [pc, #528]	; (8009784 <ublox_state_machine+0x2c4>)
 8009572:	801a      	strh	r2, [r3, #0]
            if(length >= 128) {
 8009574:	4b83      	ldr	r3, [pc, #524]	; (8009784 <ublox_state_machine+0x2c4>)
 8009576:	881b      	ldrh	r3, [r3, #0]
 8009578:	2b7f      	cmp	r3, #127	; 0x7f
 800957a:	d907      	bls.n	800958c <ublox_state_machine+0xcc>
                set_status(STATUS_ERROR);
 800957c:	2002      	movs	r0, #2
 800957e:	f000 fc87 	bl	8009e90 <set_status>
                state = STATE_IDLE;
 8009582:	4b7d      	ldr	r3, [pc, #500]	; (8009778 <ublox_state_machine+0x2b8>)
 8009584:	2200      	movs	r2, #0
 8009586:	701a      	strb	r2, [r3, #0]
                return UBLOX_RXLEN_TOO_LONG;
 8009588:	2301      	movs	r3, #1
 800958a:	e0f0      	b.n	800976e <ublox_state_machine+0x2ae>
            }
            length_remaining = length;
 800958c:	4b7d      	ldr	r3, [pc, #500]	; (8009784 <ublox_state_machine+0x2c4>)
 800958e:	881a      	ldrh	r2, [r3, #0]
 8009590:	4b7d      	ldr	r3, [pc, #500]	; (8009788 <ublox_state_machine+0x2c8>)
 8009592:	801a      	strh	r2, [r3, #0]
            state = STATE_PAYLOAD;
 8009594:	4b78      	ldr	r3, [pc, #480]	; (8009778 <ublox_state_machine+0x2b8>)
 8009596:	2207      	movs	r2, #7
 8009598:	701a      	strb	r2, [r3, #0]
 800959a:	e0e7      	b.n	800976c <ublox_state_machine+0x2ac>
            break;

        case STATE_PAYLOAD:
            if(length_remaining) {
 800959c:	4b7a      	ldr	r3, [pc, #488]	; (8009788 <ublox_state_machine+0x2c8>)
 800959e:	881b      	ldrh	r3, [r3, #0]
 80095a0:	2b00      	cmp	r3, #0
 80095a2:	d00e      	beq.n	80095c2 <ublox_state_machine+0x102>
                payload[length - length_remaining--] = b;
 80095a4:	4b77      	ldr	r3, [pc, #476]	; (8009784 <ublox_state_machine+0x2c4>)
 80095a6:	881b      	ldrh	r3, [r3, #0]
 80095a8:	4619      	mov	r1, r3
 80095aa:	4b77      	ldr	r3, [pc, #476]	; (8009788 <ublox_state_machine+0x2c8>)
 80095ac:	881b      	ldrh	r3, [r3, #0]
 80095ae:	1e5a      	subs	r2, r3, #1
 80095b0:	b290      	uxth	r0, r2
 80095b2:	4a75      	ldr	r2, [pc, #468]	; (8009788 <ublox_state_machine+0x2c8>)
 80095b4:	8010      	strh	r0, [r2, #0]
 80095b6:	1acb      	subs	r3, r1, r3
 80095b8:	4974      	ldr	r1, [pc, #464]	; (800978c <ublox_state_machine+0x2cc>)
 80095ba:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80095be:	54ca      	strb	r2, [r1, r3]
            } else {
                ck_a = b;
                state = STATE_CK_A;
 80095c0:	e0d4      	b.n	800976c <ublox_state_machine+0x2ac>
                ck_a = b;
 80095c2:	4a73      	ldr	r2, [pc, #460]	; (8009790 <ublox_state_machine+0x2d0>)
 80095c4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80095c8:	7013      	strb	r3, [r2, #0]
                state = STATE_CK_A;
 80095ca:	4b6b      	ldr	r3, [pc, #428]	; (8009778 <ublox_state_machine+0x2b8>)
 80095cc:	2208      	movs	r2, #8
 80095ce:	701a      	strb	r2, [r3, #0]
 80095d0:	e0cc      	b.n	800976c <ublox_state_machine+0x2ac>
            }
            break;

        case STATE_CK_A:
            ck_b = b;
 80095d2:	4a70      	ldr	r2, [pc, #448]	; (8009794 <ublox_state_machine+0x2d4>)
 80095d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80095d8:	7013      	strb	r3, [r2, #0]
            state = STATE_IDLE;
 80095da:	4b67      	ldr	r3, [pc, #412]	; (8009778 <ublox_state_machine+0x2b8>)
 80095dc:	2200      	movs	r2, #0
 80095de:	701a      	strb	r2, [r3, #0]

            /* Verify checksum */
            ck = gps_fletcher_8(0, &class, 1);
 80095e0:	2201      	movs	r2, #1
 80095e2:	4966      	ldr	r1, [pc, #408]	; (800977c <ublox_state_machine+0x2bc>)
 80095e4:	2000      	movs	r0, #0
 80095e6:	f7ff fe8b 	bl	8009300 <gps_fletcher_8>
 80095ea:	4603      	mov	r3, r0
 80095ec:	461a      	mov	r2, r3
 80095ee:	4b6a      	ldr	r3, [pc, #424]	; (8009798 <ublox_state_machine+0x2d8>)
 80095f0:	801a      	strh	r2, [r3, #0]
            ck = gps_fletcher_8(ck, &id, 1);
 80095f2:	4b69      	ldr	r3, [pc, #420]	; (8009798 <ublox_state_machine+0x2d8>)
 80095f4:	881b      	ldrh	r3, [r3, #0]
 80095f6:	2201      	movs	r2, #1
 80095f8:	4961      	ldr	r1, [pc, #388]	; (8009780 <ublox_state_machine+0x2c0>)
 80095fa:	4618      	mov	r0, r3
 80095fc:	f7ff fe80 	bl	8009300 <gps_fletcher_8>
 8009600:	4603      	mov	r3, r0
 8009602:	461a      	mov	r2, r3
 8009604:	4b64      	ldr	r3, [pc, #400]	; (8009798 <ublox_state_machine+0x2d8>)
 8009606:	801a      	strh	r2, [r3, #0]
            ck = gps_fletcher_8(ck, (uint8_t*)&length, 2);
 8009608:	4b63      	ldr	r3, [pc, #396]	; (8009798 <ublox_state_machine+0x2d8>)
 800960a:	881b      	ldrh	r3, [r3, #0]
 800960c:	2202      	movs	r2, #2
 800960e:	495d      	ldr	r1, [pc, #372]	; (8009784 <ublox_state_machine+0x2c4>)
 8009610:	4618      	mov	r0, r3
 8009612:	f7ff fe75 	bl	8009300 <gps_fletcher_8>
 8009616:	4603      	mov	r3, r0
 8009618:	461a      	mov	r2, r3
 800961a:	4b5f      	ldr	r3, [pc, #380]	; (8009798 <ublox_state_machine+0x2d8>)
 800961c:	801a      	strh	r2, [r3, #0]
            ck = gps_fletcher_8(ck, payload, length);
 800961e:	4b5e      	ldr	r3, [pc, #376]	; (8009798 <ublox_state_machine+0x2d8>)
 8009620:	8818      	ldrh	r0, [r3, #0]
 8009622:	4b58      	ldr	r3, [pc, #352]	; (8009784 <ublox_state_machine+0x2c4>)
 8009624:	881b      	ldrh	r3, [r3, #0]
 8009626:	b2db      	uxtb	r3, r3
 8009628:	461a      	mov	r2, r3
 800962a:	4958      	ldr	r1, [pc, #352]	; (800978c <ublox_state_machine+0x2cc>)
 800962c:	f7ff fe68 	bl	8009300 <gps_fletcher_8>
 8009630:	4603      	mov	r3, r0
 8009632:	461a      	mov	r2, r3
 8009634:	4b58      	ldr	r3, [pc, #352]	; (8009798 <ublox_state_machine+0x2d8>)
 8009636:	801a      	strh	r2, [r3, #0]
            if(ck_a != (ck&0xFF) || ck_b != (ck>>8)) {
 8009638:	4b55      	ldr	r3, [pc, #340]	; (8009790 <ublox_state_machine+0x2d0>)
 800963a:	781b      	ldrb	r3, [r3, #0]
 800963c:	461a      	mov	r2, r3
 800963e:	4b56      	ldr	r3, [pc, #344]	; (8009798 <ublox_state_machine+0x2d8>)
 8009640:	881b      	ldrh	r3, [r3, #0]
 8009642:	b2db      	uxtb	r3, r3
 8009644:	429a      	cmp	r2, r3
 8009646:	d108      	bne.n	800965a <ublox_state_machine+0x19a>
 8009648:	4b52      	ldr	r3, [pc, #328]	; (8009794 <ublox_state_machine+0x2d4>)
 800964a:	781b      	ldrb	r3, [r3, #0]
 800964c:	b29a      	uxth	r2, r3
 800964e:	4b52      	ldr	r3, [pc, #328]	; (8009798 <ublox_state_machine+0x2d8>)
 8009650:	881b      	ldrh	r3, [r3, #0]
 8009652:	0a1b      	lsrs	r3, r3, #8
 8009654:	b29b      	uxth	r3, r3
 8009656:	429a      	cmp	r2, r3
 8009658:	d007      	beq.n	800966a <ublox_state_machine+0x1aa>
                set_status(STATUS_ERROR);
 800965a:	2002      	movs	r0, #2
 800965c:	f000 fc18 	bl	8009e90 <set_status>
                state=STATE_IDLE;
 8009660:	4b45      	ldr	r3, [pc, #276]	; (8009778 <ublox_state_machine+0x2b8>)
 8009662:	2200      	movs	r2, #0
 8009664:	701a      	strb	r2, [r3, #0]
                return UBLOX_BAD_CHECKSUM;
 8009666:	2302      	movs	r3, #2
 8009668:	e081      	b.n	800976e <ublox_state_machine+0x2ae>
            }

            /* Handle Payload */
            switch(class) {
 800966a:	4b44      	ldr	r3, [pc, #272]	; (800977c <ublox_state_machine+0x2bc>)
 800966c:	781b      	ldrb	r3, [r3, #0]
 800966e:	2b05      	cmp	r3, #5
 8009670:	d004      	beq.n	800967c <ublox_state_machine+0x1bc>
 8009672:	2b06      	cmp	r3, #6
 8009674:	d054      	beq.n	8009720 <ublox_state_machine+0x260>
 8009676:	2b01      	cmp	r3, #1
 8009678:	d014      	beq.n	80096a4 <ublox_state_machine+0x1e4>
 800967a:	e06c      	b.n	8009756 <ublox_state_machine+0x296>

                /* Acknowledge */
                case UBX_ACK:
                    if(id == UBX_ACK_NAK) {
 800967c:	4b40      	ldr	r3, [pc, #256]	; (8009780 <ublox_state_machine+0x2c0>)
 800967e:	781b      	ldrb	r3, [r3, #0]
 8009680:	2b00      	cmp	r3, #0
 8009682:	d104      	bne.n	800968e <ublox_state_machine+0x1ce>
                        /* NAK */
                        set_status(STATUS_ERROR);
 8009684:	2002      	movs	r0, #2
 8009686:	f000 fc03 	bl	8009e90 <set_status>
                        return UBLOX_NAK;
 800968a:	2304      	movs	r3, #4
 800968c:	e06f      	b.n	800976e <ublox_state_machine+0x2ae>
                    } else if(id == UBX_ACK_ACK) {
 800968e:	4b3c      	ldr	r3, [pc, #240]	; (8009780 <ublox_state_machine+0x2c0>)
 8009690:	781b      	ldrb	r3, [r3, #0]
 8009692:	2b01      	cmp	r3, #1
 8009694:	d101      	bne.n	800969a <ublox_state_machine+0x1da>
                        /* ACK - Do Nothing */
                        return UBLOX_ACK;
 8009696:	2303      	movs	r3, #3
 8009698:	e069      	b.n	800976e <ublox_state_machine+0x2ae>
                    } else {
                        set_status(STATUS_ERROR);
 800969a:	2002      	movs	r0, #2
 800969c:	f000 fbf8 	bl	8009e90 <set_status>
                        return UBLOX_UNHANDLED;
 80096a0:	230a      	movs	r3, #10
 80096a2:	e064      	b.n	800976e <ublox_state_machine+0x2ae>
                    }
                    break;

                /* Nav Payload */
                case UBX_NAV:
                    if(id == UBX_NAV_PVT) {
 80096a4:	4b36      	ldr	r3, [pc, #216]	; (8009780 <ublox_state_machine+0x2c0>)
 80096a6:	781b      	ldrb	r3, [r3, #0]
 80096a8:	2b07      	cmp	r3, #7
 80096aa:	d123      	bne.n	80096f4 <ublox_state_machine+0x234>

                        /* Extract NAV-PVT Payload */
                        memcpy(&pvt_data, payload, length);
 80096ac:	4b35      	ldr	r3, [pc, #212]	; (8009784 <ublox_state_machine+0x2c4>)
 80096ae:	881b      	ldrh	r3, [r3, #0]
 80096b0:	461a      	mov	r2, r3
 80096b2:	ab03      	add	r3, sp, #12
 80096b4:	4935      	ldr	r1, [pc, #212]	; (800978c <ublox_state_machine+0x2cc>)
 80096b6:	4618      	mov	r0, r3
 80096b8:	f7f6 fe32 	bl	8000320 <memcpy>
                                                
                        /* Generate Position Packet */
	                    chMtxLock(&pos_pkt_mutex);
 80096bc:	4837      	ldr	r0, [pc, #220]	; (800979c <ublox_state_machine+0x2dc>)
 80096be:	f7f8 f9ff 	bl	8001ac0 <chMtxLock>
	                    
	                    pos_pkt.lon = pvt_data.lon;
 80096c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80096c4:	4a36      	ldr	r2, [pc, #216]	; (80097a0 <ublox_state_machine+0x2e0>)
 80096c6:	6013      	str	r3, [r2, #0]
	                    pos_pkt.lat = pvt_data.lat;
 80096c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80096ca:	4a35      	ldr	r2, [pc, #212]	; (80097a0 <ublox_state_machine+0x2e0>)
 80096cc:	6053      	str	r3, [r2, #4]
	                    pos_pkt.height = pvt_data.height;
 80096ce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80096d0:	4a33      	ldr	r2, [pc, #204]	; (80097a0 <ublox_state_machine+0x2e0>)
 80096d2:	6093      	str	r3, [r2, #8]
	                    pos_pkt.num_sat = pvt_data.num_sv;
 80096d4:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
 80096d8:	4b31      	ldr	r3, [pc, #196]	; (80097a0 <ublox_state_machine+0x2e0>)
 80096da:	731a      	strb	r2, [r3, #12]
                        pos_pkt.fix_type = pvt_data.fix_type;
 80096dc:	f89d 2020 	ldrb.w	r2, [sp, #32]
 80096e0:	4b2f      	ldr	r3, [pc, #188]	; (80097a0 <ublox_state_machine+0x2e0>)
 80096e2:	735a      	strb	r2, [r3, #13]
                        
                        upload_position_packet(&pos_pkt);
 80096e4:	482e      	ldr	r0, [pc, #184]	; (80097a0 <ublox_state_machine+0x2e0>)
 80096e6:	f000 fdd3 	bl	800a290 <upload_position_packet>
        
	                    chMtxUnlock(&pos_pkt_mutex);
 80096ea:	482c      	ldr	r0, [pc, #176]	; (800979c <ublox_state_machine+0x2dc>)
 80096ec:	f7f8 fa78 	bl	8001be0 <chMtxUnlock>
	                    
                        return UBLOX_NAV_PVT;
 80096f0:	2305      	movs	r3, #5
 80096f2:	e03c      	b.n	800976e <ublox_state_machine+0x2ae>

                    } else if(id == UBX_NAV_POSECEF){
 80096f4:	4b22      	ldr	r3, [pc, #136]	; (8009780 <ublox_state_machine+0x2c0>)
 80096f6:	781b      	ldrb	r3, [r3, #0]
 80096f8:	2b01      	cmp	r3, #1
 80096fa:	d10c      	bne.n	8009716 <ublox_state_machine+0x256>

                        /* Extract NAV-POSECEF Payload */
                        memcpy(&posecef, payload, length);
 80096fc:	4b21      	ldr	r3, [pc, #132]	; (8009784 <ublox_state_machine+0x2c4>)
 80096fe:	881b      	ldrh	r3, [r3, #0]
 8009700:	461a      	mov	r2, r3
 8009702:	ab1a      	add	r3, sp, #104	; 0x68
 8009704:	4921      	ldr	r1, [pc, #132]	; (800978c <ublox_state_machine+0x2cc>)
 8009706:	4618      	mov	r0, r3
 8009708:	f7f6 fe0a 	bl	8000320 <memcpy>

                        set_status(STATUS_GOOD);
 800970c:	2001      	movs	r0, #1
 800970e:	f000 fbbf 	bl	8009e90 <set_status>
                        return UBLOX_NAV_POSECEF;
 8009712:	2306      	movs	r3, #6
 8009714:	e02b      	b.n	800976e <ublox_state_machine+0x2ae>

                    } else {
                        set_status(STATUS_ERROR);
 8009716:	2002      	movs	r0, #2
 8009718:	f000 fbba 	bl	8009e90 <set_status>
                        return UBLOX_UNHANDLED;
 800971c:	230a      	movs	r3, #10
 800971e:	e026      	b.n	800976e <ublox_state_machine+0x2ae>
                    }
                    break;

                /* Config Payload */
                case UBX_CFG:
                    if(id == UBX_CFG_NAV5) {
 8009720:	4b17      	ldr	r3, [pc, #92]	; (8009780 <ublox_state_machine+0x2c0>)
 8009722:	781b      	ldrb	r3, [r3, #0]
 8009724:	2b24      	cmp	r3, #36	; 0x24
 8009726:	d111      	bne.n	800974c <ublox_state_machine+0x28c>

                        /* NAV5 */
                        memcpy(cfg_nav5.payload, payload, length);
 8009728:	4b16      	ldr	r3, [pc, #88]	; (8009784 <ublox_state_machine+0x2c4>)
 800972a:	881b      	ldrh	r3, [r3, #0]
 800972c:	461a      	mov	r2, r3
 800972e:	ab1f      	add	r3, sp, #124	; 0x7c
 8009730:	3306      	adds	r3, #6
 8009732:	4916      	ldr	r1, [pc, #88]	; (800978c <ublox_state_machine+0x2cc>)
 8009734:	4618      	mov	r0, r3
 8009736:	f7f6 fdf3 	bl	8000320 <memcpy>
                        if(cfg_nav5.dyn_model != 2) {
 800973a:	f89d 3084 	ldrb.w	r3, [sp, #132]	; 0x84
 800973e:	2b02      	cmp	r3, #2
 8009740:	d002      	beq.n	8009748 <ublox_state_machine+0x288>
                            set_status(STATUS_ERROR);
 8009742:	2002      	movs	r0, #2
 8009744:	f000 fba4 	bl	8009e90 <set_status>
                        }
                        return UBLOX_CFG_NAV5;
 8009748:	2309      	movs	r3, #9
 800974a:	e010      	b.n	800976e <ublox_state_machine+0x2ae>
                    } else {
                        set_status(STATUS_ERROR);
 800974c:	2002      	movs	r0, #2
 800974e:	f000 fb9f 	bl	8009e90 <set_status>
                        return UBLOX_UNHANDLED;
 8009752:	230a      	movs	r3, #10
 8009754:	e00b      	b.n	800976e <ublox_state_machine+0x2ae>
                    }
                    break;

                /* Unhandled */
                default:
                    return UBLOX_UNHANDLED;
 8009756:	230a      	movs	r3, #10
 8009758:	e009      	b.n	800976e <ublox_state_machine+0x2ae>
            }
            break;

        default:
            state = STATE_IDLE;
 800975a:	4b07      	ldr	r3, [pc, #28]	; (8009778 <ublox_state_machine+0x2b8>)
 800975c:	2200      	movs	r2, #0
 800975e:	701a      	strb	r2, [r3, #0]

            set_status(STATUS_ERROR);
 8009760:	2002      	movs	r0, #2
 8009762:	f000 fb95 	bl	8009e90 <set_status>
            return UBLOX_ERROR;
 8009766:	230b      	movs	r3, #11
 8009768:	e001      	b.n	800976e <ublox_state_machine+0x2ae>
                state = STATE_SYNC1;
 800976a:	bf00      	nop
    }
    return UBLOX_WAIT;
 800976c:	2300      	movs	r3, #0
}
 800976e:	4618      	mov	r0, r3
 8009770:	b02b      	add	sp, #172	; 0xac
 8009772:	f85d fb04 	ldr.w	pc, [sp], #4
 8009776:	bf00      	nop
 8009778:	20002f28 	.word	0x20002f28
 800977c:	20002f29 	.word	0x20002f29
 8009780:	20002f2a 	.word	0x20002f2a
 8009784:	20002f2c 	.word	0x20002f2c
 8009788:	20002f2e 	.word	0x20002f2e
 800978c:	20002f30 	.word	0x20002f30
 8009790:	20002fb0 	.word	0x20002fb0
 8009794:	20002fb1 	.word	0x20002fb1
 8009798:	20002fb2 	.word	0x20002fb2
 800979c:	20000008 	.word	0x20000008
 80097a0:	20002ba8 	.word	0x20002ba8
	...

080097b0 <gps_configure>:


/* Configure uBlox GPS */
static bool gps_configure(bool nav_pvt, bool nav_posecef, bool rising_edge) {
 80097b0:	b510      	push	{r4, lr}
 80097b2:	b0c4      	sub	sp, #272	; 0x110
 80097b4:	4604      	mov	r4, r0
 80097b6:	4608      	mov	r0, r1
 80097b8:	4611      	mov	r1, r2
 80097ba:	f10d 0307 	add.w	r3, sp, #7
 80097be:	4622      	mov	r2, r4
 80097c0:	701a      	strb	r2, [r3, #0]
 80097c2:	f10d 0306 	add.w	r3, sp, #6
 80097c6:	4602      	mov	r2, r0
 80097c8:	701a      	strb	r2, [r3, #0]
 80097ca:	f10d 0305 	add.w	r3, sp, #5
 80097ce:	460a      	mov	r2, r1
 80097d0:	701a      	strb	r2, [r3, #0]

    gps_configured = true;
 80097d2:	4bc3      	ldr	r3, [pc, #780]	; (8009ae0 <gps_configure+0x330>)
 80097d4:	2201      	movs	r2, #1
 80097d6:	701a      	strb	r2, [r3, #0]
    ubx_cfg_gnss_t gnss;
    ubx_cfg_tp5_t tp5_1;
    ubx_cfg_tp5_t tp5_2;

    /* Disable NMEA on UART */
    prt.sync1 = UBX_SYNC1;
 80097d8:	23b5      	movs	r3, #181	; 0xb5
 80097da:	f88d 30f4 	strb.w	r3, [sp, #244]	; 0xf4
    prt.sync2 = UBX_SYNC2;
 80097de:	2362      	movs	r3, #98	; 0x62
 80097e0:	f88d 30f5 	strb.w	r3, [sp, #245]	; 0xf5
    prt.class = UBX_CFG;
 80097e4:	2306      	movs	r3, #6
 80097e6:	f88d 30f6 	strb.w	r3, [sp, #246]	; 0xf6
    prt.id = UBX_CFG_PRT;
 80097ea:	2300      	movs	r3, #0
 80097ec:	f88d 30f7 	strb.w	r3, [sp, #247]	; 0xf7
    prt.length = sizeof(prt.payload);
 80097f0:	2314      	movs	r3, #20
 80097f2:	f8ad 30f8 	strh.w	r3, [sp, #248]	; 0xf8
    /* Program UART1 */
    prt.port_id = 1;
 80097f6:	2301      	movs	r3, #1
 80097f8:	f88d 30fa 	strb.w	r3, [sp, #250]	; 0xfa
    /* Don't use TXReady GPIO */
    prt.tx_ready = 0;
 80097fc:	2300      	movs	r3, #0
 80097fe:	f8ad 30fc 	strh.w	r3, [sp, #252]	; 0xfc
    /* 8 bits, no polarity, 1 stop bit */
    prt.mode = (1<<4) | (3<<6) | (4<<9);
 8009802:	2300      	movs	r3, #0
 8009804:	f443 630d 	orr.w	r3, r3, #2256	; 0x8d0
 8009808:	f8ad 30fe 	strh.w	r3, [sp, #254]	; 0xfe
 800980c:	2300      	movs	r3, #0
 800980e:	f8ad 3100 	strh.w	r3, [sp, #256]	; 0x100
    /* 9600 baud */
    prt.baud_rate = 9600;
 8009812:	2300      	movs	r3, #0
 8009814:	f443 5316 	orr.w	r3, r3, #9600	; 0x2580
 8009818:	f8ad 3102 	strh.w	r3, [sp, #258]	; 0x102
 800981c:	2300      	movs	r3, #0
 800981e:	f8ad 3104 	strh.w	r3, [sp, #260]	; 0x104
    /* only receive UBX protocol */
    prt.in_proto_mask = (1<<0);
 8009822:	2301      	movs	r3, #1
 8009824:	f8ad 3106 	strh.w	r3, [sp, #262]	; 0x106
    /* only send UBX protocol */
    prt.out_proto_mask = (1<<0);
 8009828:	2301      	movs	r3, #1
 800982a:	f8ad 3108 	strh.w	r3, [sp, #264]	; 0x108
    /* no weird timeout */
    prt.flags = 0;
 800982e:	2300      	movs	r3, #0
 8009830:	f8ad 310a 	strh.w	r3, [sp, #266]	; 0x10a
    /* must be 0 */
    prt.reserved5 = 0;
 8009834:	2300      	movs	r3, #0
 8009836:	f8ad 310c 	strh.w	r3, [sp, #268]	; 0x10c
    gps_configured &= gps_transmit((uint8_t*)&prt);
 800983a:	ab3d      	add	r3, sp, #244	; 0xf4
 800983c:	4618      	mov	r0, r3
 800983e:	f7ff fdd7 	bl	80093f0 <gps_transmit>
 8009842:	4603      	mov	r3, r0
 8009844:	4619      	mov	r1, r3
 8009846:	4ba6      	ldr	r3, [pc, #664]	; (8009ae0 <gps_configure+0x330>)
 8009848:	781b      	ldrb	r3, [r3, #0]
 800984a:	461a      	mov	r2, r3
 800984c:	460b      	mov	r3, r1
 800984e:	4013      	ands	r3, r2
 8009850:	2b00      	cmp	r3, #0
 8009852:	bf14      	ite	ne
 8009854:	2301      	movne	r3, #1
 8009856:	2300      	moveq	r3, #0
 8009858:	b2da      	uxtb	r2, r3
 800985a:	4ba1      	ldr	r3, [pc, #644]	; (8009ae0 <gps_configure+0x330>)
 800985c:	701a      	strb	r2, [r3, #0]
    if(!gps_configured) return false;
 800985e:	4ba0      	ldr	r3, [pc, #640]	; (8009ae0 <gps_configure+0x330>)
 8009860:	781b      	ldrb	r3, [r3, #0]
 8009862:	f083 0301 	eor.w	r3, r3, #1
 8009866:	b2db      	uxtb	r3, r3
 8009868:	2b00      	cmp	r3, #0
 800986a:	d001      	beq.n	8009870 <gps_configure+0xc0>
 800986c:	2300      	movs	r3, #0
 800986e:	e276      	b.n	8009d5e <gps_configure+0x5ae>

    /* Wait for it to stop barfing NMEA */
    chThdSleepMilliseconds(300);
 8009870:	f640 30b8 	movw	r0, #3000	; 0xbb8
 8009874:	f7f7 fe0c 	bl	8001490 <chThdSleep>

    /* Clear the read buffer */
    while(sdGetTimeout(gps_seriald, TIME_IMMEDIATE) != Q_TIMEOUT);
 8009878:	4b9a      	ldr	r3, [pc, #616]	; (8009ae4 <gps_configure+0x334>)
 800987a:	681b      	ldr	r3, [r3, #0]
 800987c:	330c      	adds	r3, #12
 800987e:	2100      	movs	r1, #0
 8009880:	4618      	mov	r0, r3
 8009882:	f7f8 fd45 	bl	8002310 <chIQGetTimeout>
 8009886:	4603      	mov	r3, r0
 8009888:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800988c:	d1f4      	bne.n	8009878 <gps_configure+0xc8>
    
    /* Disable non GPS systems */
    gnss.sync1 = UBX_SYNC1;
 800988e:	23b5      	movs	r3, #181	; 0xb5
 8009890:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
    gnss.sync2 = UBX_SYNC2;
 8009894:	2362      	movs	r3, #98	; 0x62
 8009896:	f88d 305d 	strb.w	r3, [sp, #93]	; 0x5d
    gnss.class = UBX_CFG;
 800989a:	2306      	movs	r3, #6
 800989c:	f88d 305e 	strb.w	r3, [sp, #94]	; 0x5e
    gnss.id = UBX_CFG_GNSS;
 80098a0:	233e      	movs	r3, #62	; 0x3e
 80098a2:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
    gnss.length = sizeof(gnss.payload);
 80098a6:	232c      	movs	r3, #44	; 0x2c
 80098a8:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60

    gnss.msg_ver = 0;
 80098ac:	2300      	movs	r3, #0
 80098ae:	f88d 3062 	strb.w	r3, [sp, #98]	; 0x62
    gnss.num_trk_ch_hw = 32;
 80098b2:	2320      	movs	r3, #32
 80098b4:	f88d 3063 	strb.w	r3, [sp, #99]	; 0x63
    gnss.num_trk_ch_use = 32;
 80098b8:	2320      	movs	r3, #32
 80098ba:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
    gnss.num_config_blocks = 5;
 80098be:	2305      	movs	r3, #5
 80098c0:	f88d 3065 	strb.w	r3, [sp, #101]	; 0x65

    /* Enable GPS, use all-1 channels */
    gnss.gps_gnss_id = 0;
 80098c4:	2300      	movs	r3, #0
 80098c6:	f88d 3066 	strb.w	r3, [sp, #102]	; 0x66
    gnss.gps_res_trk_ch = 31;
 80098ca:	231f      	movs	r3, #31
 80098cc:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
    gnss.gps_max_trk_ch = 31;
 80098d0:	231f      	movs	r3, #31
 80098d2:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
    gnss.gps_flags = 1+(1<<16);
 80098d6:	2300      	movs	r3, #0
 80098d8:	f043 0301 	orr.w	r3, r3, #1
 80098dc:	f8ad 306a 	strh.w	r3, [sp, #106]	; 0x6a
 80098e0:	2300      	movs	r3, #0
 80098e2:	f043 0301 	orr.w	r3, r3, #1
 80098e6:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c

    /* Enable QZSS as per protocol spec */
    gnss.qzss_gnss_id = 5;
 80098ea:	2305      	movs	r3, #5
 80098ec:	f88d 307e 	strb.w	r3, [sp, #126]	; 0x7e
    gnss.qzss_res_trk_ch = 1;
 80098f0:	2301      	movs	r3, #1
 80098f2:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
    gnss.qzss_max_trk_ch = 1;
 80098f6:	2301      	movs	r3, #1
 80098f8:	f88d 3080 	strb.w	r3, [sp, #128]	; 0x80
    gnss.qzss_flags = 1+(1<<16);
 80098fc:	2300      	movs	r3, #0
 80098fe:	f043 0301 	orr.w	r3, r3, #1
 8009902:	f8ad 3082 	strh.w	r3, [sp, #130]	; 0x82
 8009906:	2300      	movs	r3, #0
 8009908:	f043 0301 	orr.w	r3, r3, #1
 800990c:	f8ad 3084 	strh.w	r3, [sp, #132]	; 0x84

    /* Leave all other GNSS systems disabled */
    gnss.sbas_gnss_id = 1;
 8009910:	2301      	movs	r3, #1
 8009912:	f88d 306e 	strb.w	r3, [sp, #110]	; 0x6e
    gnss.beidou_gnss_id = 3;
 8009916:	2303      	movs	r3, #3
 8009918:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
    gnss.glonass_gnss_id = 6;
 800991c:	2306      	movs	r3, #6
 800991e:	f88d 3086 	strb.w	r3, [sp, #134]	; 0x86
    gps_configured &= gps_tx_ack((uint8_t*)&gnss);
 8009922:	ab17      	add	r3, sp, #92	; 0x5c
 8009924:	4618      	mov	r0, r3
 8009926:	f7ff fd93 	bl	8009450 <gps_tx_ack>
 800992a:	4603      	mov	r3, r0
 800992c:	4619      	mov	r1, r3
 800992e:	4b6c      	ldr	r3, [pc, #432]	; (8009ae0 <gps_configure+0x330>)
 8009930:	781b      	ldrb	r3, [r3, #0]
 8009932:	461a      	mov	r2, r3
 8009934:	460b      	mov	r3, r1
 8009936:	4013      	ands	r3, r2
 8009938:	2b00      	cmp	r3, #0
 800993a:	bf14      	ite	ne
 800993c:	2301      	movne	r3, #1
 800993e:	2300      	moveq	r3, #0
 8009940:	b2da      	uxtb	r2, r3
 8009942:	4b67      	ldr	r3, [pc, #412]	; (8009ae0 <gps_configure+0x330>)
 8009944:	701a      	strb	r2, [r3, #0]
    if(!gps_configured) return false;
 8009946:	4b66      	ldr	r3, [pc, #408]	; (8009ae0 <gps_configure+0x330>)
 8009948:	781b      	ldrb	r3, [r3, #0]
 800994a:	f083 0301 	eor.w	r3, r3, #1
 800994e:	b2db      	uxtb	r3, r3
 8009950:	2b00      	cmp	r3, #0
 8009952:	d001      	beq.n	8009958 <gps_configure+0x1a8>
 8009954:	2300      	movs	r3, #0
 8009956:	e202      	b.n	8009d5e <gps_configure+0x5ae>

    /* Wait for reset */
    chThdSleepMilliseconds(500);    
 8009958:	f241 3088 	movw	r0, #5000	; 0x1388
 800995c:	f7f7 fd98 	bl	8001490 <chThdSleep>
    
    
    /* Re-disable NMEA Output */
    gps_configured &= gps_transmit((uint8_t*)&prt);
 8009960:	ab3d      	add	r3, sp, #244	; 0xf4
 8009962:	4618      	mov	r0, r3
 8009964:	f7ff fd44 	bl	80093f0 <gps_transmit>
 8009968:	4603      	mov	r3, r0
 800996a:	4619      	mov	r1, r3
 800996c:	4b5c      	ldr	r3, [pc, #368]	; (8009ae0 <gps_configure+0x330>)
 800996e:	781b      	ldrb	r3, [r3, #0]
 8009970:	461a      	mov	r2, r3
 8009972:	460b      	mov	r3, r1
 8009974:	4013      	ands	r3, r2
 8009976:	2b00      	cmp	r3, #0
 8009978:	bf14      	ite	ne
 800997a:	2301      	movne	r3, #1
 800997c:	2300      	moveq	r3, #0
 800997e:	b2da      	uxtb	r2, r3
 8009980:	4b57      	ldr	r3, [pc, #348]	; (8009ae0 <gps_configure+0x330>)
 8009982:	701a      	strb	r2, [r3, #0]
    if(!gps_configured) return false;
 8009984:	4b56      	ldr	r3, [pc, #344]	; (8009ae0 <gps_configure+0x330>)
 8009986:	781b      	ldrb	r3, [r3, #0]
 8009988:	f083 0301 	eor.w	r3, r3, #1
 800998c:	b2db      	uxtb	r3, r3
 800998e:	2b00      	cmp	r3, #0
 8009990:	d001      	beq.n	8009996 <gps_configure+0x1e6>
 8009992:	2300      	movs	r3, #0
 8009994:	e1e3      	b.n	8009d5e <gps_configure+0x5ae>
    
    /* Wait for it to stop barfing NMEA */
    chThdSleepMilliseconds(300);
 8009996:	f640 30b8 	movw	r0, #3000	; 0xbb8
 800999a:	f7f7 fd79 	bl	8001490 <chThdSleep>
    
    /* Clear the read buffer */
    while(sdGetTimeout(gps_seriald, TIME_IMMEDIATE) != Q_TIMEOUT);
 800999e:	4b51      	ldr	r3, [pc, #324]	; (8009ae4 <gps_configure+0x334>)
 80099a0:	681b      	ldr	r3, [r3, #0]
 80099a2:	330c      	adds	r3, #12
 80099a4:	2100      	movs	r1, #0
 80099a6:	4618      	mov	r0, r3
 80099a8:	f7f8 fcb2 	bl	8002310 <chIQGetTimeout>
 80099ac:	4603      	mov	r3, r0
 80099ae:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80099b2:	d1f4      	bne.n	800999e <gps_configure+0x1ee>

    
    /* Set to Stationary mode */
    nav5.sync1 = UBX_SYNC1;
 80099b4:	23b5      	movs	r3, #181	; 0xb5
 80099b6:	f88d 30c8 	strb.w	r3, [sp, #200]	; 0xc8
    nav5.sync2 = UBX_SYNC2;
 80099ba:	2362      	movs	r3, #98	; 0x62
 80099bc:	f88d 30c9 	strb.w	r3, [sp, #201]	; 0xc9
    nav5.class = UBX_CFG;
 80099c0:	2306      	movs	r3, #6
 80099c2:	f88d 30ca 	strb.w	r3, [sp, #202]	; 0xca
    nav5.id = UBX_CFG_NAV5;
 80099c6:	2324      	movs	r3, #36	; 0x24
 80099c8:	f88d 30cb 	strb.w	r3, [sp, #203]	; 0xcb
    nav5.length = sizeof(nav5.payload);
 80099cc:	2324      	movs	r3, #36	; 0x24
 80099ce:	f8ad 30cc 	strh.w	r3, [sp, #204]	; 0xcc

    nav5.mask = 1 | (1<<10);
 80099d2:	f240 4301 	movw	r3, #1025	; 0x401
 80099d6:	f8ad 30ce 	strh.w	r3, [sp, #206]	; 0xce
    nav5.dyn_model = 2;
 80099da:	2302      	movs	r3, #2
 80099dc:	f88d 30d0 	strb.w	r3, [sp, #208]	; 0xd0
    nav5.utc_standard = 3;  // USNO
 80099e0:	2303      	movs	r3, #3
 80099e2:	f88d 30ec 	strb.w	r3, [sp, #236]	; 0xec

    gps_configured &= gps_tx_ack((uint8_t*)&nav5);
 80099e6:	ab32      	add	r3, sp, #200	; 0xc8
 80099e8:	4618      	mov	r0, r3
 80099ea:	f7ff fd31 	bl	8009450 <gps_tx_ack>
 80099ee:	4603      	mov	r3, r0
 80099f0:	4619      	mov	r1, r3
 80099f2:	4b3b      	ldr	r3, [pc, #236]	; (8009ae0 <gps_configure+0x330>)
 80099f4:	781b      	ldrb	r3, [r3, #0]
 80099f6:	461a      	mov	r2, r3
 80099f8:	460b      	mov	r3, r1
 80099fa:	4013      	ands	r3, r2
 80099fc:	2b00      	cmp	r3, #0
 80099fe:	bf14      	ite	ne
 8009a00:	2301      	movne	r3, #1
 8009a02:	2300      	moveq	r3, #0
 8009a04:	b2da      	uxtb	r2, r3
 8009a06:	4b36      	ldr	r3, [pc, #216]	; (8009ae0 <gps_configure+0x330>)
 8009a08:	701a      	strb	r2, [r3, #0]
    if(!gps_configured) return false;
 8009a0a:	4b35      	ldr	r3, [pc, #212]	; (8009ae0 <gps_configure+0x330>)
 8009a0c:	781b      	ldrb	r3, [r3, #0]
 8009a0e:	f083 0301 	eor.w	r3, r3, #1
 8009a12:	b2db      	uxtb	r3, r3
 8009a14:	2b00      	cmp	r3, #0
 8009a16:	d001      	beq.n	8009a1c <gps_configure+0x26c>
 8009a18:	2300      	movs	r3, #0
 8009a1a:	e1a0      	b.n	8009d5e <gps_configure+0x5ae>

    /* Set solution rate to 1Hz */
    rate.sync1 = UBX_SYNC1;
 8009a1c:	23b5      	movs	r3, #181	; 0xb5
 8009a1e:	f88d 30a0 	strb.w	r3, [sp, #160]	; 0xa0
    rate.sync2 = UBX_SYNC2;
 8009a22:	2362      	movs	r3, #98	; 0x62
 8009a24:	f88d 30a1 	strb.w	r3, [sp, #161]	; 0xa1
    rate.class = UBX_CFG;
 8009a28:	2306      	movs	r3, #6
 8009a2a:	f88d 30a2 	strb.w	r3, [sp, #162]	; 0xa2
    rate.id = UBX_CFG_RATE;
 8009a2e:	2308      	movs	r3, #8
 8009a30:	f88d 30a3 	strb.w	r3, [sp, #163]	; 0xa3
    rate.length = sizeof(rate.payload);
 8009a34:	2306      	movs	r3, #6
 8009a36:	f8ad 30a4 	strh.w	r3, [sp, #164]	; 0xa4

    rate.meas_rate = 1000;
 8009a3a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8009a3e:	f8ad 30a6 	strh.w	r3, [sp, #166]	; 0xa6
    rate.nav_rate = 1;
 8009a42:	2301      	movs	r3, #1
 8009a44:	f8ad 30a8 	strh.w	r3, [sp, #168]	; 0xa8
    rate.time_ref = 0;  // UTC
 8009a48:	2300      	movs	r3, #0
 8009a4a:	f8ad 30aa 	strh.w	r3, [sp, #170]	; 0xaa
    
    gps_configured &= gps_tx_ack((uint8_t*)&rate);
 8009a4e:	ab28      	add	r3, sp, #160	; 0xa0
 8009a50:	4618      	mov	r0, r3
 8009a52:	f7ff fcfd 	bl	8009450 <gps_tx_ack>
 8009a56:	4603      	mov	r3, r0
 8009a58:	4619      	mov	r1, r3
 8009a5a:	4b21      	ldr	r3, [pc, #132]	; (8009ae0 <gps_configure+0x330>)
 8009a5c:	781b      	ldrb	r3, [r3, #0]
 8009a5e:	461a      	mov	r2, r3
 8009a60:	460b      	mov	r3, r1
 8009a62:	4013      	ands	r3, r2
 8009a64:	2b00      	cmp	r3, #0
 8009a66:	bf14      	ite	ne
 8009a68:	2301      	movne	r3, #1
 8009a6a:	2300      	moveq	r3, #0
 8009a6c:	b2da      	uxtb	r2, r3
 8009a6e:	4b1c      	ldr	r3, [pc, #112]	; (8009ae0 <gps_configure+0x330>)
 8009a70:	701a      	strb	r2, [r3, #0]
    if(!gps_configured) return false;
 8009a72:	4b1b      	ldr	r3, [pc, #108]	; (8009ae0 <gps_configure+0x330>)
 8009a74:	781b      	ldrb	r3, [r3, #0]
 8009a76:	f083 0301 	eor.w	r3, r3, #1
 8009a7a:	b2db      	uxtb	r3, r3
 8009a7c:	2b00      	cmp	r3, #0
 8009a7e:	d001      	beq.n	8009a84 <gps_configure+0x2d4>
 8009a80:	2300      	movs	r3, #0
 8009a82:	e16c      	b.n	8009d5e <gps_configure+0x5ae>


    /* Disable sbas */
    sbas.sync1 = UBX_SYNC1;
 8009a84:	23b5      	movs	r3, #181	; 0xb5
 8009a86:	f88d 3090 	strb.w	r3, [sp, #144]	; 0x90
    sbas.sync2 = UBX_SYNC2;
 8009a8a:	2362      	movs	r3, #98	; 0x62
 8009a8c:	f88d 3091 	strb.w	r3, [sp, #145]	; 0x91
    sbas.class = UBX_CFG;
 8009a90:	2306      	movs	r3, #6
 8009a92:	f88d 3092 	strb.w	r3, [sp, #146]	; 0x92
    sbas.id = UBX_CFG_SBAS;
 8009a96:	2316      	movs	r3, #22
 8009a98:	f88d 3093 	strb.w	r3, [sp, #147]	; 0x93
    sbas.length = sizeof(sbas.payload);
 8009a9c:	2308      	movs	r3, #8
 8009a9e:	f8ad 3094 	strh.w	r3, [sp, #148]	; 0x94
    sbas.mode = 0;
 8009aa2:	2300      	movs	r3, #0
 8009aa4:	f88d 3096 	strb.w	r3, [sp, #150]	; 0x96
    
    gps_configured &= gps_tx_ack((uint8_t*)&sbas);
 8009aa8:	ab24      	add	r3, sp, #144	; 0x90
 8009aaa:	4618      	mov	r0, r3
 8009aac:	f7ff fcd0 	bl	8009450 <gps_tx_ack>
 8009ab0:	4603      	mov	r3, r0
 8009ab2:	4619      	mov	r1, r3
 8009ab4:	4b0a      	ldr	r3, [pc, #40]	; (8009ae0 <gps_configure+0x330>)
 8009ab6:	781b      	ldrb	r3, [r3, #0]
 8009ab8:	461a      	mov	r2, r3
 8009aba:	460b      	mov	r3, r1
 8009abc:	4013      	ands	r3, r2
 8009abe:	2b00      	cmp	r3, #0
 8009ac0:	bf14      	ite	ne
 8009ac2:	2301      	movne	r3, #1
 8009ac4:	2300      	moveq	r3, #0
 8009ac6:	b2da      	uxtb	r2, r3
 8009ac8:	4b05      	ldr	r3, [pc, #20]	; (8009ae0 <gps_configure+0x330>)
 8009aca:	701a      	strb	r2, [r3, #0]
    if(!gps_configured) return false;
 8009acc:	4b04      	ldr	r3, [pc, #16]	; (8009ae0 <gps_configure+0x330>)
 8009ace:	781b      	ldrb	r3, [r3, #0]
 8009ad0:	f083 0301 	eor.w	r3, r3, #1
 8009ad4:	b2db      	uxtb	r3, r3
 8009ad6:	2b00      	cmp	r3, #0
 8009ad8:	d006      	beq.n	8009ae8 <gps_configure+0x338>
 8009ada:	2300      	movs	r3, #0
 8009adc:	e13f      	b.n	8009d5e <gps_configure+0x5ae>
 8009ade:	bf00      	nop
 8009ae0:	20002ba4 	.word	0x20002ba4
 8009ae4:	20002ba0 	.word	0x20002ba0


    /* Set up 1MHz timepulse on TIMEPULSE pin*/
    tp5_1.sync1 = UBX_SYNC1;
 8009ae8:	23b5      	movs	r3, #181	; 0xb5
 8009aea:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
    tp5_1.sync2 = UBX_SYNC2;
 8009aee:	2362      	movs	r3, #98	; 0x62
 8009af0:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
    tp5_1.class = UBX_CFG;
 8009af4:	2306      	movs	r3, #6
 8009af6:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    tp5_1.id = UBX_CFG_TP5;
 8009afa:	2331      	movs	r3, #49	; 0x31
 8009afc:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    tp5_1.length = sizeof(tp5_1.payload);
 8009b00:	2320      	movs	r3, #32
 8009b02:	f8ad 3038 	strh.w	r3, [sp, #56]	; 0x38

    tp5_1.tp_idx =           0;                   // TIMEPULSE
 8009b06:	2300      	movs	r3, #0
 8009b08:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    tp5_1.version =          0;
 8009b0c:	2300      	movs	r3, #0
 8009b0e:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
    tp5_1.ant_cable_delay =  0;
 8009b12:	2300      	movs	r3, #0
 8009b14:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
    tp5_1.freq_period =      0;           
 8009b18:	2300      	movs	r3, #0
 8009b1a:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
 8009b1e:	2300      	movs	r3, #0
 8009b20:	f8ad 3044 	strh.w	r3, [sp, #68]	; 0x44
    tp5_1.pulse_len_ratio =  0;   
 8009b24:	2300      	movs	r3, #0
 8009b26:	f8ad 304a 	strh.w	r3, [sp, #74]	; 0x4a
 8009b2a:	2300      	movs	r3, #0
 8009b2c:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
    tp5_1.freq_period_lock = 4000000;             // 4 MHz  
 8009b30:	2300      	movs	r3, #0
 8009b32:	f443 6310 	orr.w	r3, r3, #2304	; 0x900
 8009b36:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
 8009b3a:	2300      	movs	r3, #0
 8009b3c:	f043 033d 	orr.w	r3, r3, #61	; 0x3d
 8009b40:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
    tp5_1.pulse_len_ratio_lock = 0xffffffff >> 1; // (2^32/2)/2^32 = 50% duty cycle
 8009b44:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8009b48:	f8ad 304e 	strh.w	r3, [sp, #78]	; 0x4e
 8009b4c:	2300      	movs	r3, #0
 8009b4e:	ea6f 33d3 	mvn.w	r3, r3, lsr #15
 8009b52:	ea6f 33c3 	mvn.w	r3, r3, lsl #15
 8009b56:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
    tp5_1.user_config_delay = 0;
 8009b5a:	2300      	movs	r3, #0
 8009b5c:	f8ad 3052 	strh.w	r3, [sp, #82]	; 0x52
 8009b60:	2300      	movs	r3, #0
 8009b62:	f8ad 3054 	strh.w	r3, [sp, #84]	; 0x54
    tp5_1.flags = (
 8009b66:	2300      	movs	r3, #0
 8009b68:	f043 036f 	orr.w	r3, r3, #111	; 0x6f
 8009b6c:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
 8009b70:	2300      	movs	r3, #0
 8009b72:	f8ad 3058 	strh.w	r3, [sp, #88]	; 0x58
        UBX_CFG_TP5_FLAGS_IS_FREQ                   |
        UBX_CFG_TP5_FLAGS_ALIGN_TO_TOW              |
        UBX_CFG_TP5_FLAGS_POLARITY                  |
        UBX_CFG_TP5_FLAGS_GRID_UTC_GNSS_UTC);
    
    gps_configured &= gps_tx_ack((uint8_t*)&tp5_1);
 8009b76:	ab0d      	add	r3, sp, #52	; 0x34
 8009b78:	4618      	mov	r0, r3
 8009b7a:	f7ff fc69 	bl	8009450 <gps_tx_ack>
 8009b7e:	4603      	mov	r3, r0
 8009b80:	4619      	mov	r1, r3
 8009b82:	4b78      	ldr	r3, [pc, #480]	; (8009d64 <gps_configure+0x5b4>)
 8009b84:	781b      	ldrb	r3, [r3, #0]
 8009b86:	461a      	mov	r2, r3
 8009b88:	460b      	mov	r3, r1
 8009b8a:	4013      	ands	r3, r2
 8009b8c:	2b00      	cmp	r3, #0
 8009b8e:	bf14      	ite	ne
 8009b90:	2301      	movne	r3, #1
 8009b92:	2300      	moveq	r3, #0
 8009b94:	b2da      	uxtb	r2, r3
 8009b96:	4b73      	ldr	r3, [pc, #460]	; (8009d64 <gps_configure+0x5b4>)
 8009b98:	701a      	strb	r2, [r3, #0]
    if(!gps_configured) return false;
 8009b9a:	4b72      	ldr	r3, [pc, #456]	; (8009d64 <gps_configure+0x5b4>)
 8009b9c:	781b      	ldrb	r3, [r3, #0]
 8009b9e:	f083 0301 	eor.w	r3, r3, #1
 8009ba2:	b2db      	uxtb	r3, r3
 8009ba4:	2b00      	cmp	r3, #0
 8009ba6:	d001      	beq.n	8009bac <gps_configure+0x3fc>
 8009ba8:	2300      	movs	r3, #0
 8009baa:	e0d8      	b.n	8009d5e <gps_configure+0x5ae>


    /* Set up 1Hz pulse on SAFEBOOT pin */
    tp5_2.sync1 = UBX_SYNC1;
 8009bac:	ab03      	add	r3, sp, #12
 8009bae:	22b5      	movs	r2, #181	; 0xb5
 8009bb0:	701a      	strb	r2, [r3, #0]
    tp5_2.sync2 = UBX_SYNC2;
 8009bb2:	ab03      	add	r3, sp, #12
 8009bb4:	2262      	movs	r2, #98	; 0x62
 8009bb6:	705a      	strb	r2, [r3, #1]
    tp5_2.class = UBX_CFG;
 8009bb8:	ab03      	add	r3, sp, #12
 8009bba:	2206      	movs	r2, #6
 8009bbc:	709a      	strb	r2, [r3, #2]
    tp5_2.id = UBX_CFG_TP5;
 8009bbe:	ab03      	add	r3, sp, #12
 8009bc0:	2231      	movs	r2, #49	; 0x31
 8009bc2:	70da      	strb	r2, [r3, #3]
    tp5_2.length = sizeof(tp5_2.payload);
 8009bc4:	ab03      	add	r3, sp, #12
 8009bc6:	2220      	movs	r2, #32
 8009bc8:	809a      	strh	r2, [r3, #4]

    tp5_2.tp_idx               = 1;     // Safeboot pin
 8009bca:	ab03      	add	r3, sp, #12
 8009bcc:	2201      	movs	r2, #1
 8009bce:	719a      	strb	r2, [r3, #6]
    tp5_2.version              = 0;
 8009bd0:	ab03      	add	r3, sp, #12
 8009bd2:	2200      	movs	r2, #0
 8009bd4:	71da      	strb	r2, [r3, #7]
    tp5_2.ant_cable_delay      = 0;
 8009bd6:	ab03      	add	r3, sp, #12
 8009bd8:	2200      	movs	r2, #0
 8009bda:	815a      	strh	r2, [r3, #10]
    tp5_2.freq_period          = 1;
 8009bdc:	ab03      	add	r3, sp, #12
 8009bde:	2200      	movs	r2, #0
 8009be0:	f042 0201 	orr.w	r2, r2, #1
 8009be4:	81da      	strh	r2, [r3, #14]
 8009be6:	2200      	movs	r2, #0
 8009be8:	821a      	strh	r2, [r3, #16]
    tp5_2.pulse_len_ratio      = 10000; // us
 8009bea:	aa03      	add	r2, sp, #12
 8009bec:	2300      	movs	r3, #0
 8009bee:	f443 531c 	orr.w	r3, r3, #9984	; 0x2700
 8009bf2:	f043 0310 	orr.w	r3, r3, #16
 8009bf6:	82d3      	strh	r3, [r2, #22]
 8009bf8:	2300      	movs	r3, #0
 8009bfa:	8313      	strh	r3, [r2, #24]
    tp5_2.freq_period_lock     = 1;
 8009bfc:	ab03      	add	r3, sp, #12
 8009bfe:	2200      	movs	r2, #0
 8009c00:	f042 0201 	orr.w	r2, r2, #1
 8009c04:	825a      	strh	r2, [r3, #18]
 8009c06:	2200      	movs	r2, #0
 8009c08:	829a      	strh	r2, [r3, #20]
    tp5_2.pulse_len_ratio_lock = 10000;
 8009c0a:	aa03      	add	r2, sp, #12
 8009c0c:	2300      	movs	r3, #0
 8009c0e:	f443 531c 	orr.w	r3, r3, #9984	; 0x2700
 8009c12:	f043 0310 	orr.w	r3, r3, #16
 8009c16:	8353      	strh	r3, [r2, #26]
 8009c18:	2300      	movs	r3, #0
 8009c1a:	8393      	strh	r3, [r2, #28]

    if(rising_edge) {
 8009c1c:	f10d 0305 	add.w	r3, sp, #5
 8009c20:	781b      	ldrb	r3, [r3, #0]
 8009c22:	2b00      	cmp	r3, #0
 8009c24:	d007      	beq.n	8009c36 <gps_configure+0x486>

        /* Rising edge on top of second */
        tp5_2.flags = (
 8009c26:	ab03      	add	r3, sp, #12
 8009c28:	2200      	movs	r2, #0
 8009c2a:	f042 027f 	orr.w	r2, r2, #127	; 0x7f
 8009c2e:	845a      	strh	r2, [r3, #34]	; 0x22
 8009c30:	2200      	movs	r2, #0
 8009c32:	849a      	strh	r2, [r3, #36]	; 0x24
 8009c34:	e006      	b.n	8009c44 <gps_configure+0x494>
            UBX_CFG_TP5_FLAGS_POLARITY                  |
            UBX_CFG_TP5_FLAGS_GRID_UTC_GNSS_UTC);
    } else {

        /* Falling edge on top of second */
        tp5_2.flags = (
 8009c36:	ab03      	add	r3, sp, #12
 8009c38:	2200      	movs	r2, #0
 8009c3a:	f042 023f 	orr.w	r2, r2, #63	; 0x3f
 8009c3e:	845a      	strh	r2, [r3, #34]	; 0x22
 8009c40:	2200      	movs	r2, #0
 8009c42:	849a      	strh	r2, [r3, #36]	; 0x24
            UBX_CFG_TP5_FLAGS_IS_LENGTH                 |
            UBX_CFG_TP5_FLAGS_ALIGN_TO_TOW              |
            UBX_CFG_TP5_FLAGS_GRID_UTC_GNSS_UTC);
    }

    gps_configured &= gps_tx_ack((uint8_t*)&tp5_2);
 8009c44:	ab03      	add	r3, sp, #12
 8009c46:	4618      	mov	r0, r3
 8009c48:	f7ff fc02 	bl	8009450 <gps_tx_ack>
 8009c4c:	4603      	mov	r3, r0
 8009c4e:	4619      	mov	r1, r3
 8009c50:	4b44      	ldr	r3, [pc, #272]	; (8009d64 <gps_configure+0x5b4>)
 8009c52:	781b      	ldrb	r3, [r3, #0]
 8009c54:	461a      	mov	r2, r3
 8009c56:	460b      	mov	r3, r1
 8009c58:	4013      	ands	r3, r2
 8009c5a:	2b00      	cmp	r3, #0
 8009c5c:	bf14      	ite	ne
 8009c5e:	2301      	movne	r3, #1
 8009c60:	2300      	moveq	r3, #0
 8009c62:	b2da      	uxtb	r2, r3
 8009c64:	4b3f      	ldr	r3, [pc, #252]	; (8009d64 <gps_configure+0x5b4>)
 8009c66:	701a      	strb	r2, [r3, #0]
    if(!gps_configured) return false;
 8009c68:	4b3e      	ldr	r3, [pc, #248]	; (8009d64 <gps_configure+0x5b4>)
 8009c6a:	781b      	ldrb	r3, [r3, #0]
 8009c6c:	f083 0301 	eor.w	r3, r3, #1
 8009c70:	b2db      	uxtb	r3, r3
 8009c72:	2b00      	cmp	r3, #0
 8009c74:	d001      	beq.n	8009c7a <gps_configure+0x4ca>
 8009c76:	2300      	movs	r3, #0
 8009c78:	e071      	b.n	8009d5e <gps_configure+0x5ae>

    
    /* Enable NAV PVT messages */
    if(nav_pvt){
 8009c7a:	f10d 0307 	add.w	r3, sp, #7
 8009c7e:	781b      	ldrb	r3, [r3, #0]
 8009c80:	2b00      	cmp	r3, #0
 8009c82:	d032      	beq.n	8009cea <gps_configure+0x53a>
        msg.sync1 = UBX_SYNC1;
 8009c84:	23b5      	movs	r3, #181	; 0xb5
 8009c86:	f88d 30bc 	strb.w	r3, [sp, #188]	; 0xbc
        msg.sync2 = UBX_SYNC2;
 8009c8a:	2362      	movs	r3, #98	; 0x62
 8009c8c:	f88d 30bd 	strb.w	r3, [sp, #189]	; 0xbd
        msg.class = UBX_CFG;
 8009c90:	2306      	movs	r3, #6
 8009c92:	f88d 30be 	strb.w	r3, [sp, #190]	; 0xbe
        msg.id = UBX_CFG_MSG;
 8009c96:	2301      	movs	r3, #1
 8009c98:	f88d 30bf 	strb.w	r3, [sp, #191]	; 0xbf
        msg.length = sizeof(msg.payload);
 8009c9c:	2303      	movs	r3, #3
 8009c9e:	f8ad 30c0 	strh.w	r3, [sp, #192]	; 0xc0

        msg.msg_class = UBX_NAV;
 8009ca2:	2301      	movs	r3, #1
 8009ca4:	f88d 30c2 	strb.w	r3, [sp, #194]	; 0xc2
        msg.msg_id    = UBX_NAV_PVT;
 8009ca8:	2307      	movs	r3, #7
 8009caa:	f88d 30c3 	strb.w	r3, [sp, #195]	; 0xc3
        msg.rate      = 1;
 8009cae:	2301      	movs	r3, #1
 8009cb0:	f88d 30c4 	strb.w	r3, [sp, #196]	; 0xc4
        
        gps_configured &= gps_tx_ack((uint8_t*)&msg);
 8009cb4:	ab2f      	add	r3, sp, #188	; 0xbc
 8009cb6:	4618      	mov	r0, r3
 8009cb8:	f7ff fbca 	bl	8009450 <gps_tx_ack>
 8009cbc:	4603      	mov	r3, r0
 8009cbe:	4619      	mov	r1, r3
 8009cc0:	4b28      	ldr	r3, [pc, #160]	; (8009d64 <gps_configure+0x5b4>)
 8009cc2:	781b      	ldrb	r3, [r3, #0]
 8009cc4:	461a      	mov	r2, r3
 8009cc6:	460b      	mov	r3, r1
 8009cc8:	4013      	ands	r3, r2
 8009cca:	2b00      	cmp	r3, #0
 8009ccc:	bf14      	ite	ne
 8009cce:	2301      	movne	r3, #1
 8009cd0:	2300      	moveq	r3, #0
 8009cd2:	b2da      	uxtb	r2, r3
 8009cd4:	4b23      	ldr	r3, [pc, #140]	; (8009d64 <gps_configure+0x5b4>)
 8009cd6:	701a      	strb	r2, [r3, #0]
        if(!gps_configured) return false;
 8009cd8:	4b22      	ldr	r3, [pc, #136]	; (8009d64 <gps_configure+0x5b4>)
 8009cda:	781b      	ldrb	r3, [r3, #0]
 8009cdc:	f083 0301 	eor.w	r3, r3, #1
 8009ce0:	b2db      	uxtb	r3, r3
 8009ce2:	2b00      	cmp	r3, #0
 8009ce4:	d001      	beq.n	8009cea <gps_configure+0x53a>
 8009ce6:	2300      	movs	r3, #0
 8009ce8:	e039      	b.n	8009d5e <gps_configure+0x5ae>
    }

    
    /* Enable NAV POSECEF messages */
    if (nav_posecef){
 8009cea:	f10d 0306 	add.w	r3, sp, #6
 8009cee:	781b      	ldrb	r3, [r3, #0]
 8009cf0:	2b00      	cmp	r3, #0
 8009cf2:	d032      	beq.n	8009d5a <gps_configure+0x5aa>
        msg2.sync1 = UBX_SYNC1;
 8009cf4:	23b5      	movs	r3, #181	; 0xb5
 8009cf6:	f88d 30b0 	strb.w	r3, [sp, #176]	; 0xb0
        msg2.sync2 = UBX_SYNC2;
 8009cfa:	2362      	movs	r3, #98	; 0x62
 8009cfc:	f88d 30b1 	strb.w	r3, [sp, #177]	; 0xb1
        msg2.class = UBX_CFG;
 8009d00:	2306      	movs	r3, #6
 8009d02:	f88d 30b2 	strb.w	r3, [sp, #178]	; 0xb2
        msg2.id = UBX_CFG_MSG;
 8009d06:	2301      	movs	r3, #1
 8009d08:	f88d 30b3 	strb.w	r3, [sp, #179]	; 0xb3
        msg2.length = sizeof(msg2.payload);
 8009d0c:	2303      	movs	r3, #3
 8009d0e:	f8ad 30b4 	strh.w	r3, [sp, #180]	; 0xb4

        msg2.msg_class = UBX_NAV;
 8009d12:	2301      	movs	r3, #1
 8009d14:	f88d 30b6 	strb.w	r3, [sp, #182]	; 0xb6
        msg2.msg_id    = UBX_NAV_POSECEF;
 8009d18:	2301      	movs	r3, #1
 8009d1a:	f88d 30b7 	strb.w	r3, [sp, #183]	; 0xb7
        msg2.rate      = 1;
 8009d1e:	2301      	movs	r3, #1
 8009d20:	f88d 30b8 	strb.w	r3, [sp, #184]	; 0xb8
        
        gps_configured &= gps_tx_ack((uint8_t*)&msg2);
 8009d24:	ab2c      	add	r3, sp, #176	; 0xb0
 8009d26:	4618      	mov	r0, r3
 8009d28:	f7ff fb92 	bl	8009450 <gps_tx_ack>
 8009d2c:	4603      	mov	r3, r0
 8009d2e:	4619      	mov	r1, r3
 8009d30:	4b0c      	ldr	r3, [pc, #48]	; (8009d64 <gps_configure+0x5b4>)
 8009d32:	781b      	ldrb	r3, [r3, #0]
 8009d34:	461a      	mov	r2, r3
 8009d36:	460b      	mov	r3, r1
 8009d38:	4013      	ands	r3, r2
 8009d3a:	2b00      	cmp	r3, #0
 8009d3c:	bf14      	ite	ne
 8009d3e:	2301      	movne	r3, #1
 8009d40:	2300      	moveq	r3, #0
 8009d42:	b2da      	uxtb	r2, r3
 8009d44:	4b07      	ldr	r3, [pc, #28]	; (8009d64 <gps_configure+0x5b4>)
 8009d46:	701a      	strb	r2, [r3, #0]
        if(!gps_configured) return false;
 8009d48:	4b06      	ldr	r3, [pc, #24]	; (8009d64 <gps_configure+0x5b4>)
 8009d4a:	781b      	ldrb	r3, [r3, #0]
 8009d4c:	f083 0301 	eor.w	r3, r3, #1
 8009d50:	b2db      	uxtb	r3, r3
 8009d52:	2b00      	cmp	r3, #0
 8009d54:	d001      	beq.n	8009d5a <gps_configure+0x5aa>
 8009d56:	2300      	movs	r3, #0
 8009d58:	e001      	b.n	8009d5e <gps_configure+0x5ae>
    }

    return gps_configured;
 8009d5a:	4b02      	ldr	r3, [pc, #8]	; (8009d64 <gps_configure+0x5b4>)
 8009d5c:	781b      	ldrb	r3, [r3, #0]
}
 8009d5e:	4618      	mov	r0, r3
 8009d60:	b044      	add	sp, #272	; 0x110
 8009d62:	bd10      	pop	{r4, pc}
 8009d64:	20002ba4 	.word	0x20002ba4
	...

08009d70 <gps_init>:

/* Configure uBlox GPS - public function */
void gps_init(SerialDriver* seriald, bool nav_pvt, bool nav_posecef,
                bool rising_edge){
 8009d70:	b500      	push	{lr}
 8009d72:	b083      	sub	sp, #12
 8009d74:	9001      	str	r0, [sp, #4]
 8009d76:	4608      	mov	r0, r1
 8009d78:	4611      	mov	r1, r2
 8009d7a:	461a      	mov	r2, r3
 8009d7c:	4603      	mov	r3, r0
 8009d7e:	f88d 3003 	strb.w	r3, [sp, #3]
 8009d82:	460b      	mov	r3, r1
 8009d84:	f88d 3002 	strb.w	r3, [sp, #2]
 8009d88:	4613      	mov	r3, r2
 8009d8a:	f88d 3001 	strb.w	r3, [sp, #1]

    /* Set global serial driver */
    gps_seriald = seriald;
 8009d8e:	4a1a      	ldr	r2, [pc, #104]	; (8009df8 <gps_init+0x88>)
 8009d90:	9b01      	ldr	r3, [sp, #4]
 8009d92:	6013      	str	r3, [r2, #0]

    /* Reset uBlox */
    palClearLine(LINE_GPS_RST);
 8009d94:	4b19      	ldr	r3, [pc, #100]	; (8009dfc <gps_init+0x8c>)
 8009d96:	2220      	movs	r2, #32
 8009d98:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(300);
 8009d9a:	f640 30b8 	movw	r0, #3000	; 0xbb8
 8009d9e:	f7f7 fb77 	bl	8001490 <chThdSleep>
    palSetLine(LINE_GPS_RST);
 8009da2:	4b16      	ldr	r3, [pc, #88]	; (8009dfc <gps_init+0x8c>)
 8009da4:	2220      	movs	r2, #32
 8009da6:	831a      	strh	r2, [r3, #24]

    /* Wait for GPS to restart */
    chThdSleepMilliseconds(500);
 8009da8:	f241 3088 	movw	r0, #5000	; 0x1388
 8009dac:	f7f7 fb70 	bl	8001490 <chThdSleep>

    sdStart(gps_seriald, &serial_cfg);
 8009db0:	4b11      	ldr	r3, [pc, #68]	; (8009df8 <gps_init+0x88>)
 8009db2:	681b      	ldr	r3, [r3, #0]
 8009db4:	4912      	ldr	r1, [pc, #72]	; (8009e00 <gps_init+0x90>)
 8009db6:	4618      	mov	r0, r3
 8009db8:	f7fa fbaa 	bl	8004510 <sdStart>
 8009dbc:	e006      	b.n	8009dcc <gps_init+0x5c>

    while(!gps_configure(nav_pvt, nav_posecef, rising_edge)) {
        
        set_status(STATUS_ERROR);
 8009dbe:	2002      	movs	r0, #2
 8009dc0:	f000 f866 	bl	8009e90 <set_status>
        chThdSleepMilliseconds(1000);
 8009dc4:	f242 7010 	movw	r0, #10000	; 0x2710
 8009dc8:	f7f7 fb62 	bl	8001490 <chThdSleep>
    while(!gps_configure(nav_pvt, nav_posecef, rising_edge)) {
 8009dcc:	f89d 2001 	ldrb.w	r2, [sp, #1]
 8009dd0:	f89d 1002 	ldrb.w	r1, [sp, #2]
 8009dd4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009dd8:	4618      	mov	r0, r3
 8009dda:	f7ff fce9 	bl	80097b0 <gps_configure>
 8009dde:	4603      	mov	r3, r0
 8009de0:	f083 0301 	eor.w	r3, r3, #1
 8009de4:	b2db      	uxtb	r3, r3
 8009de6:	2b00      	cmp	r3, #0
 8009de8:	d1e9      	bne.n	8009dbe <gps_init+0x4e>
    }
    
    set_status(STATUS_GOOD);
 8009dea:	2001      	movs	r0, #1
 8009dec:	f000 f850 	bl	8009e90 <set_status>
    
    return;
}
 8009df0:	b003      	add	sp, #12
 8009df2:	f85d fb04 	ldr.w	pc, [sp], #4
 8009df6:	bf00      	nop
 8009df8:	20002ba0 	.word	0x20002ba0
 8009dfc:	40020400 	.word	0x40020400
 8009e00:	20000018 	.word	0x20000018
	...

08009e10 <gps_thd>:


/* Thread to Run State Machine */
static THD_WORKING_AREA(gps_thd_wa, 512);
static THD_FUNCTION(gps_thd, arg) {
 8009e10:	b500      	push	{lr}
 8009e12:	b083      	sub	sp, #12
 8009e14:	9001      	str	r0, [sp, #4]

    (void)arg;
    chRegSetThreadName("GPS");
 8009e16:	480c      	ldr	r0, [pc, #48]	; (8009e48 <gps_thd+0x38>)
 8009e18:	f7ff fa52 	bl	80092c0 <chRegSetThreadName.lto_priv.2>

    while(true) {
    
        if(gps_configured) {
 8009e1c:	4b0b      	ldr	r3, [pc, #44]	; (8009e4c <gps_thd+0x3c>)
 8009e1e:	781b      	ldrb	r3, [r3, #0]
 8009e20:	2b00      	cmp	r3, #0
 8009e22:	d00b      	beq.n	8009e3c <gps_thd+0x2c>
            
            ublox_state_machine(sdGet(gps_seriald));
 8009e24:	4b0a      	ldr	r3, [pc, #40]	; (8009e50 <gps_thd+0x40>)
 8009e26:	681b      	ldr	r3, [r3, #0]
 8009e28:	330c      	adds	r3, #12
 8009e2a:	4618      	mov	r0, r3
 8009e2c:	f7ff fa58 	bl	80092e0 <chIQGet>
 8009e30:	4603      	mov	r3, r0
 8009e32:	b2db      	uxtb	r3, r3
 8009e34:	4618      	mov	r0, r3
 8009e36:	f7ff fb43 	bl	80094c0 <ublox_state_machine>
 8009e3a:	e7ef      	b.n	8009e1c <gps_thd+0xc>
        }
        else {
        
            set_status(STATUS_ERROR);
 8009e3c:	2002      	movs	r0, #2
 8009e3e:	f000 f827 	bl	8009e90 <set_status>
            
            break;
        }
    }
}
 8009e42:	b003      	add	sp, #12
 8009e44:	f85d fb04 	ldr.w	pc, [sp], #4
 8009e48:	0800adb0 	.word	0x0800adb0
 8009e4c:	20002ba4 	.word	0x20002ba4
 8009e50:	20002ba0 	.word	0x20002ba0
	...

08009e60 <gps_thd_init>:


/* Init GPS Thread */
void gps_thd_init(void) {
 8009e60:	b500      	push	{lr}
 8009e62:	b083      	sub	sp, #12

    chThdCreateStatic(gps_thd_wa, sizeof(gps_thd_wa), NORMALPRIO, gps_thd, NULL);
 8009e64:	2300      	movs	r3, #0
 8009e66:	9300      	str	r3, [sp, #0]
 8009e68:	4b04      	ldr	r3, [pc, #16]	; (8009e7c <gps_thd_init+0x1c>)
 8009e6a:	2240      	movs	r2, #64	; 0x40
 8009e6c:	f44f 715c 	mov.w	r1, #880	; 0x370
 8009e70:	4803      	ldr	r0, [pc, #12]	; (8009e80 <gps_thd_init+0x20>)
 8009e72:	f7f7 fadd 	bl	8001430 <chThdCreateStatic>
}
 8009e76:	b003      	add	sp, #12
 8009e78:	f85d fb04 	ldr.w	pc, [sp], #4
 8009e7c:	08009e11 	.word	0x08009e11
 8009e80:	20002bb8 	.word	0x20002bb8
	...

08009e90 <set_status>:
#include "hal.h"

#include "status.h"

/* Set Status */
void set_status(uint8_t status) {
 8009e90:	b082      	sub	sp, #8
 8009e92:	4603      	mov	r3, r0
 8009e94:	f88d 3007 	strb.w	r3, [sp, #7]

    if (status == STATUS_GOOD){
 8009e98:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009e9c:	2b01      	cmp	r3, #1
 8009e9e:	d103      	bne.n	8009ea8 <set_status+0x18>
        palSetPad(GPIOC, GPIOC_STATUS);
 8009ea0:	4b06      	ldr	r3, [pc, #24]	; (8009ebc <set_status+0x2c>)
 8009ea2:	2240      	movs	r2, #64	; 0x40
 8009ea4:	831a      	strh	r2, [r3, #24]
 8009ea6:	e006      	b.n	8009eb6 <set_status+0x26>
    } 
    
    else if (status == STATUS_ERROR){
 8009ea8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009eac:	2b02      	cmp	r3, #2
 8009eae:	d102      	bne.n	8009eb6 <set_status+0x26>
        palClearPad(GPIOC, GPIOC_STATUS);
 8009eb0:	4b02      	ldr	r3, [pc, #8]	; (8009ebc <set_status+0x2c>)
 8009eb2:	2240      	movs	r2, #64	; 0x40
 8009eb4:	835a      	strh	r2, [r3, #26]
    }
}
 8009eb6:	b002      	add	sp, #8
 8009eb8:	4770      	bx	lr
 8009eba:	bf00      	nop
 8009ebc:	40020800 	.word	0x40020800

08009ec0 <port_lock.lto_priv.130>:
static inline void port_lock(void) {
 8009ec0:	b082      	sub	sp, #8
 8009ec2:	2320      	movs	r3, #32
 8009ec4:	9301      	str	r3, [sp, #4]
 8009ec6:	9b01      	ldr	r3, [sp, #4]
 8009ec8:	f383 8811 	msr	BASEPRI, r3
}
 8009ecc:	b002      	add	sp, #8
 8009ece:	4770      	bx	lr

08009ed0 <port_unlock.lto_priv.100>:
static inline void port_unlock(void) {
 8009ed0:	b082      	sub	sp, #8
 8009ed2:	2300      	movs	r3, #0
 8009ed4:	9301      	str	r3, [sp, #4]
 8009ed6:	9b01      	ldr	r3, [sp, #4]
 8009ed8:	f383 8811 	msr	BASEPRI, r3
}
 8009edc:	b002      	add	sp, #8
 8009ede:	4770      	bx	lr

08009ee0 <port_lock_from_isr.lto_priv.193>:
static inline void port_lock_from_isr(void) {
 8009ee0:	b508      	push	{r3, lr}
  port_lock();
 8009ee2:	f7ff ffed 	bl	8009ec0 <port_lock.lto_priv.130>
}
 8009ee6:	bd08      	pop	{r3, pc}
	...

08009ef0 <port_unlock_from_isr.lto_priv.180>:
static inline void port_unlock_from_isr(void) {
 8009ef0:	b508      	push	{r3, lr}
  port_unlock();
 8009ef2:	f7ff ffed 	bl	8009ed0 <port_unlock.lto_priv.100>
}
 8009ef6:	bd08      	pop	{r3, pc}
	...

08009f00 <chSysLockFromISR.lto_priv.167>:
static inline void chSysLockFromISR(void) {
 8009f00:	b508      	push	{r3, lr}
  port_lock_from_isr();
 8009f02:	f7ff ffed 	bl	8009ee0 <port_lock_from_isr.lto_priv.193>
  _stats_start_measure_crit_isr();
 8009f06:	f7f7 fcfb 	bl	8001900 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8009f0a:	f7f6 fd39 	bl	8000980 <_dbg_check_lock_from_isr>
}
 8009f0e:	bd08      	pop	{r3, pc}

08009f10 <chSysUnlockFromISR.lto_priv.157>:
static inline void chSysUnlockFromISR(void) {
 8009f10:	b508      	push	{r3, lr}
  _dbg_check_unlock_from_isr();
 8009f12:	f7f6 fd4d 	bl	80009b0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8009f16:	f7f7 fcfb 	bl	8001910 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 8009f1a:	f7ff ffe9 	bl	8009ef0 <port_unlock_from_isr.lto_priv.180>
}
 8009f1e:	bd08      	pop	{r3, pc}

08009f20 <osalSysLockFromISR.lto_priv.147>:
static inline void osalSysLockFromISR(void) {
 8009f20:	b508      	push	{r3, lr}
  chSysLockFromISR();
 8009f22:	f7ff ffed 	bl	8009f00 <chSysLockFromISR.lto_priv.167>
}
 8009f26:	bd08      	pop	{r3, pc}
	...

08009f30 <osalSysUnlockFromISR.lto_priv.139>:
static inline void osalSysUnlockFromISR(void) {
 8009f30:	b508      	push	{r3, lr}
  chSysUnlockFromISR();
 8009f32:	f7ff ffed 	bl	8009f10 <chSysUnlockFromISR.lto_priv.157>
}
 8009f36:	bd08      	pop	{r3, pc}
	...

08009f40 <get_descriptor>:
 * handled here.
 */
static const USBDescriptor *get_descriptor(USBDriver *usbp,
                                           uint8_t dtype,
                                           uint8_t dindex,
                                           uint16_t lang) {
 8009f40:	b082      	sub	sp, #8
 8009f42:	9001      	str	r0, [sp, #4]
 8009f44:	4608      	mov	r0, r1
 8009f46:	4611      	mov	r1, r2
 8009f48:	461a      	mov	r2, r3
 8009f4a:	4603      	mov	r3, r0
 8009f4c:	f88d 3003 	strb.w	r3, [sp, #3]
 8009f50:	460b      	mov	r3, r1
 8009f52:	f88d 3002 	strb.w	r3, [sp, #2]
 8009f56:	4613      	mov	r3, r2
 8009f58:	f8ad 3000 	strh.w	r3, [sp]

  (void)usbp;
  (void)lang;
  switch (dtype) {
 8009f5c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009f60:	2b02      	cmp	r3, #2
 8009f62:	d005      	beq.n	8009f70 <get_descriptor+0x30>
 8009f64:	2b03      	cmp	r3, #3
 8009f66:	d005      	beq.n	8009f74 <get_descriptor+0x34>
 8009f68:	2b01      	cmp	r3, #1
 8009f6a:	d10d      	bne.n	8009f88 <get_descriptor+0x48>
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
 8009f6c:	4b08      	ldr	r3, [pc, #32]	; (8009f90 <get_descriptor+0x50>)
 8009f6e:	e00c      	b.n	8009f8a <get_descriptor+0x4a>
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
 8009f70:	4b08      	ldr	r3, [pc, #32]	; (8009f94 <get_descriptor+0x54>)
 8009f72:	e00a      	b.n	8009f8a <get_descriptor+0x4a>
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 8009f74:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8009f78:	2b03      	cmp	r3, #3
 8009f7a:	d805      	bhi.n	8009f88 <get_descriptor+0x48>
      return &vcom_strings[dindex];
 8009f7c:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8009f80:	00db      	lsls	r3, r3, #3
 8009f82:	4a05      	ldr	r2, [pc, #20]	; (8009f98 <get_descriptor+0x58>)
 8009f84:	4413      	add	r3, r2
 8009f86:	e000      	b.n	8009f8a <get_descriptor+0x4a>
  }
  return NULL;
 8009f88:	2300      	movs	r3, #0
}
 8009f8a:	4618      	mov	r0, r3
 8009f8c:	b002      	add	sp, #8
 8009f8e:	4770      	bx	lr
 8009f90:	0800ade0 	.word	0x0800ade0
 8009f94:	0800ae40 	.word	0x0800ae40
 8009f98:	0800aec0 	.word	0x0800aec0
 8009f9c:	00000000 	.word	0x00000000

08009fa0 <usb_event>:
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8009fa0:	b500      	push	{lr}
 8009fa2:	b083      	sub	sp, #12
 8009fa4:	9001      	str	r0, [sp, #4]
 8009fa6:	460b      	mov	r3, r1
 8009fa8:	f88d 3003 	strb.w	r3, [sp, #3]
  extern SerialUSBDriver SDU1;

  switch (event) {
 8009fac:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009fb0:	2b06      	cmp	r3, #6
 8009fb2:	d82a      	bhi.n	800a00a <usb_event+0x6a>
 8009fb4:	a201      	add	r2, pc, #4	; (adr r2, 8009fbc <usb_event+0x1c>)
 8009fb6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009fba:	bf00      	nop
 8009fbc:	0800a00b 	.word	0x0800a00b
 8009fc0:	0800a00b 	.word	0x0800a00b
 8009fc4:	08009fd9 	.word	0x08009fd9
 8009fc8:	0800a00b 	.word	0x0800a00b
 8009fcc:	08009ffd 	.word	0x08009ffd
 8009fd0:	0800a00b 	.word	0x0800a00b
 8009fd4:	0800a00b 	.word	0x0800a00b
  case USB_EVENT_RESET:
    return;
  case USB_EVENT_ADDRESS:
    return;
  case USB_EVENT_CONFIGURED:
    chSysLockFromISR();
 8009fd8:	f7ff ff92 	bl	8009f00 <chSysLockFromISR.lto_priv.167>

    /* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 8009fdc:	4a0c      	ldr	r2, [pc, #48]	; (800a010 <usb_event+0x70>)
 8009fde:	2101      	movs	r1, #1
 8009fe0:	9801      	ldr	r0, [sp, #4]
 8009fe2:	f7fb fa45 	bl	8005470 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 8009fe6:	4a0b      	ldr	r2, [pc, #44]	; (800a014 <usb_event+0x74>)
 8009fe8:	2102      	movs	r1, #2
 8009fea:	9801      	ldr	r0, [sp, #4]
 8009fec:	f7fb fa40 	bl	8005470 <usbInitEndpointI>

    /* Resetting the state of the CDC subsystem.*/
    sduConfigureHookI(&SDU1);
 8009ff0:	4809      	ldr	r0, [pc, #36]	; (800a018 <usb_event+0x78>)
 8009ff2:	f7fa fdbd 	bl	8004b70 <sduConfigureHookI>

    chSysUnlockFromISR();
 8009ff6:	f7ff ff8b 	bl	8009f10 <chSysUnlockFromISR.lto_priv.157>
 8009ffa:	e006      	b.n	800a00a <usb_event+0x6a>
    return;
  case USB_EVENT_UNCONFIGURED:
    return;
  case USB_EVENT_SUSPEND:
    chSysLockFromISR();
 8009ffc:	f7ff ff80 	bl	8009f00 <chSysLockFromISR.lto_priv.167>

    /* Disconnection event on suspend.*/
    sduDisconnectI(&SDU1);
 800a000:	4805      	ldr	r0, [pc, #20]	; (800a018 <usb_event+0x78>)
 800a002:	f7fa fd9d 	bl	8004b40 <sduDisconnectI>

    chSysUnlockFromISR();
 800a006:	f7ff ff83 	bl	8009f10 <chSysUnlockFromISR.lto_priv.157>
    return;
  case USB_EVENT_STALLED:
    return;
  }
  return;
}
 800a00a:	b003      	add	sp, #12
 800a00c:	f85d fb04 	ldr.w	pc, [sp], #4
 800a010:	0800aee0 	.word	0x0800aee0
 800a014:	0800af10 	.word	0x0800af10
 800a018:	20002fb4 	.word	0x20002fb4
 800a01c:	00000000 	.word	0x00000000

0800a020 <sof_handler>:

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 800a020:	b500      	push	{lr}
 800a022:	b083      	sub	sp, #12
 800a024:	9001      	str	r0, [sp, #4]

  (void)usbp;

  osalSysLockFromISR();
 800a026:	f7ff ff7b 	bl	8009f20 <osalSysLockFromISR.lto_priv.147>
  sduSOFHookI(&SDU1);
 800a02a:	4804      	ldr	r0, [pc, #16]	; (800a03c <sof_handler+0x1c>)
 800a02c:	f7fa fe00 	bl	8004c30 <sduSOFHookI>
  osalSysUnlockFromISR();
 800a030:	f7ff ff7e 	bl	8009f30 <osalSysUnlockFromISR.lto_priv.139>
}
 800a034:	b003      	add	sp, #12
 800a036:	f85d fb04 	ldr.w	pc, [sp], #4
 800a03a:	bf00      	nop
 800a03c:	20002fb4 	.word	0x20002fb4

0800a040 <port_lock.lto_priv.131>:
static inline void port_lock(void) {
 800a040:	b082      	sub	sp, #8
 800a042:	2320      	movs	r3, #32
 800a044:	9301      	str	r3, [sp, #4]
 800a046:	9b01      	ldr	r3, [sp, #4]
 800a048:	f383 8811 	msr	BASEPRI, r3
}
 800a04c:	b002      	add	sp, #8
 800a04e:	4770      	bx	lr

0800a050 <port_unlock.lto_priv.101>:
static inline void port_unlock(void) {
 800a050:	b082      	sub	sp, #8
 800a052:	2300      	movs	r3, #0
 800a054:	9301      	str	r3, [sp, #4]
 800a056:	9b01      	ldr	r3, [sp, #4]
 800a058:	f383 8811 	msr	BASEPRI, r3
}
 800a05c:	b002      	add	sp, #8
 800a05e:	4770      	bx	lr

0800a060 <chSysLock.lto_priv.71>:
static inline void chSysLock(void) {
 800a060:	b508      	push	{r3, lr}
  port_lock();
 800a062:	f7ff ffed 	bl	800a040 <port_lock.lto_priv.131>
  _stats_start_measure_crit_thd();
 800a066:	f7f7 fc3b 	bl	80018e0 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800a06a:	f7f6 fc59 	bl	8000920 <_dbg_check_lock>
}
 800a06e:	bd08      	pop	{r3, pc}

0800a070 <chSysUnlock.lto_priv.30>:
static inline void chSysUnlock(void) {
 800a070:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 800a072:	f7f6 fc6d 	bl	8000950 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800a076:	f7f7 fc3b 	bl	80018f0 <_stats_stop_measure_crit_thd>
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800a07a:	4b09      	ldr	r3, [pc, #36]	; (800a0a0 <chSysUnlock.lto_priv.30+0x30>)
 800a07c:	681b      	ldr	r3, [r3, #0]
 800a07e:	4a08      	ldr	r2, [pc, #32]	; (800a0a0 <chSysUnlock.lto_priv.30+0x30>)
 800a080:	4293      	cmp	r3, r2
 800a082:	d00a      	beq.n	800a09a <chSysUnlock.lto_priv.30+0x2a>
 800a084:	4b06      	ldr	r3, [pc, #24]	; (800a0a0 <chSysUnlock.lto_priv.30+0x30>)
 800a086:	699b      	ldr	r3, [r3, #24]
 800a088:	689a      	ldr	r2, [r3, #8]
 800a08a:	4b05      	ldr	r3, [pc, #20]	; (800a0a0 <chSysUnlock.lto_priv.30+0x30>)
 800a08c:	681b      	ldr	r3, [r3, #0]
 800a08e:	689b      	ldr	r3, [r3, #8]
 800a090:	429a      	cmp	r2, r3
 800a092:	d202      	bcs.n	800a09a <chSysUnlock.lto_priv.30+0x2a>
 800a094:	4803      	ldr	r0, [pc, #12]	; (800a0a4 <chSysUnlock.lto_priv.30+0x34>)
 800a096:	f7f6 fbbb 	bl	8000810 <chSysHalt>
  port_unlock();
 800a09a:	f7ff ffd9 	bl	800a050 <port_unlock.lto_priv.101>
}
 800a09e:	bd08      	pop	{r3, pc}
 800a0a0:	20002128 	.word	0x20002128
 800a0a4:	0800af80 	.word	0x0800af80
	...

0800a0b0 <chVTGetSystemTimeX.lto_priv.7>:
  return ch.vtlist.vt_systime;
 800a0b0:	4b01      	ldr	r3, [pc, #4]	; (800a0b8 <chVTGetSystemTimeX.lto_priv.7+0x8>)
 800a0b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
 800a0b4:	4618      	mov	r0, r3
 800a0b6:	4770      	bx	lr
 800a0b8:	20002128 	.word	0x20002128
 800a0bc:	00000000 	.word	0x00000000

0800a0c0 <chVTGetSystemTime>:
static inline systime_t chVTGetSystemTime(void) {
 800a0c0:	b500      	push	{lr}
 800a0c2:	b083      	sub	sp, #12
  chSysLock();
 800a0c4:	f7ff ffcc 	bl	800a060 <chSysLock.lto_priv.71>
  systime = chVTGetSystemTimeX();
 800a0c8:	f7ff fff2 	bl	800a0b0 <chVTGetSystemTimeX.lto_priv.7>
 800a0cc:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800a0ce:	f7ff ffcf 	bl	800a070 <chSysUnlock.lto_priv.30>
  return systime;
 800a0d2:	9b01      	ldr	r3, [sp, #4]
}
 800a0d4:	4618      	mov	r0, r3
 800a0d6:	b003      	add	sp, #12
 800a0d8:	f85d fb04 	ldr.w	pc, [sp], #4
 800a0dc:	0000      	movs	r0, r0
	...

0800a0e0 <chRegSetThreadName.lto_priv.3>:
static inline void chRegSetThreadName(const char *name) {
 800a0e0:	b082      	sub	sp, #8
 800a0e2:	9001      	str	r0, [sp, #4]
  ch.rlist.r_current->p_name = name;
 800a0e4:	4b02      	ldr	r3, [pc, #8]	; (800a0f0 <chRegSetThreadName.lto_priv.3+0x10>)
 800a0e6:	699b      	ldr	r3, [r3, #24]
 800a0e8:	9a01      	ldr	r2, [sp, #4]
 800a0ea:	619a      	str	r2, [r3, #24]
}
 800a0ec:	b002      	add	sp, #8
 800a0ee:	4770      	bx	lr
 800a0f0:	20002128 	.word	0x20002128
	...

0800a100 <USBThread>:
                      __attribute__((section(".ccm")));
                                                
    
/* USB Serial Thread */
static THD_WORKING_AREA(waUSBThread, 2048);
static THD_FUNCTION(USBThread, arg) {
 800a100:	b510      	push	{r4, lr}
 800a102:	b084      	sub	sp, #16
 800a104:	9001      	str	r0, [sp, #4]

    (void)arg;
    chRegSetThreadName("USB");
 800a106:	4814      	ldr	r0, [pc, #80]	; (800a158 <USBThread+0x58>)
 800a108:	f7ff ffea 	bl	800a0e0 <chRegSetThreadName.lto_priv.3>
    /* Mailbox Variables */             
    msg_t mailbox_res;       
    intptr_t data_msg;     

    /* Initalise Memory */
    mem_init();
 800a10c:	f000 f830 	bl	800a170 <mem_init>
    
    /* Initalise USB Serial */
    usb_driver_init();
 800a110:	f000 f84e 	bl	800a1b0 <usb_driver_init>
    
    
    while (true) {

        /* Wait for message to be avaliable */
        mailbox_res = chMBFetch(&usb_mailbox, (msg_t*)&data_msg, MS2ST(100));
 800a114:	ab02      	add	r3, sp, #8
 800a116:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800a11a:	4619      	mov	r1, r3
 800a11c:	480f      	ldr	r0, [pc, #60]	; (800a15c <USBThread+0x5c>)
 800a11e:	f7f7 ff77 	bl	8002010 <chMBFetch>
 800a122:	9003      	str	r0, [sp, #12]

        /* Re-attempt if mailbox was reset or fetch failed */
        if (mailbox_res != MSG_OK || data_msg == 0) continue;
 800a124:	9b03      	ldr	r3, [sp, #12]
 800a126:	2b00      	cmp	r3, #0
 800a128:	d114      	bne.n	800a154 <USBThread+0x54>
 800a12a:	9b02      	ldr	r3, [sp, #8]
 800a12c:	2b00      	cmp	r3, #0
 800a12e:	d011      	beq.n	800a154 <USBThread+0x54>

        /* Spit out queued message and free from memory pool */
        chnWriteTimeout(&SDU1, (void*)data_msg, packet_size, MS2ST(100));
 800a130:	4b0b      	ldr	r3, [pc, #44]	; (800a160 <USBThread+0x60>)
 800a132:	681b      	ldr	r3, [r3, #0]
 800a134:	699c      	ldr	r4, [r3, #24]
 800a136:	9b02      	ldr	r3, [sp, #8]
 800a138:	4619      	mov	r1, r3
 800a13a:	4b0a      	ldr	r3, [pc, #40]	; (800a164 <USBThread+0x64>)
 800a13c:	681b      	ldr	r3, [r3, #0]
 800a13e:	461a      	mov	r2, r3
 800a140:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800a144:	4806      	ldr	r0, [pc, #24]	; (800a160 <USBThread+0x60>)
 800a146:	47a0      	blx	r4
        chPoolFree(&usb_mempool, (void*)data_msg);
 800a148:	9b02      	ldr	r3, [sp, #8]
 800a14a:	4619      	mov	r1, r3
 800a14c:	4806      	ldr	r0, [pc, #24]	; (800a168 <USBThread+0x68>)
 800a14e:	f7f8 fc17 	bl	8002980 <chPoolFree>
 800a152:	e7df      	b.n	800a114 <USBThread+0x14>
        if (mailbox_res != MSG_OK || data_msg == 0) continue;
 800a154:	bf00      	nop
 800a156:	e7dd      	b.n	800a114 <USBThread+0x14>
 800a158:	0800af60 	.word	0x0800af60
 800a15c:	20003484 	.word	0x20003484
 800a160:	20002fb4 	.word	0x20002fb4
 800a164:	0800af70 	.word	0x0800af70
 800a168:	20003478 	.word	0x20003478
 800a16c:	00000000 	.word	0x00000000

0800a170 <mem_init>:
    }    
}


/* Initialise Mailbox and Memorypool */
static void mem_init(void) {
 800a170:	b508      	push	{r3, lr}
    
    chMBObjectInit(&usb_mailbox, (msg_t*)usb_mailbox_buffer, USB_MEMPOOL_ITEMS);
 800a172:	2240      	movs	r2, #64	; 0x40
 800a174:	4907      	ldr	r1, [pc, #28]	; (800a194 <mem_init+0x24>)
 800a176:	4808      	ldr	r0, [pc, #32]	; (800a198 <mem_init+0x28>)
 800a178:	f7f7 feaa 	bl	8001ed0 <chMBObjectInit>
    chPoolObjectInit(&usb_mempool, sizeof(packet_log), NULL);
 800a17c:	2200      	movs	r2, #0
 800a17e:	2180      	movs	r1, #128	; 0x80
 800a180:	4806      	ldr	r0, [pc, #24]	; (800a19c <mem_init+0x2c>)
 800a182:	f7f8 fb55 	bl	8002830 <chPoolObjectInit>

    /* Fill Memory Pool with Statically Allocated Bits of Memory */
    chPoolLoadArray(&usb_mempool, (void*)usb_mempool_buffer, USB_MEMPOOL_ITEMS);
 800a186:	2240      	movs	r2, #64	; 0x40
 800a188:	4905      	ldr	r1, [pc, #20]	; (800a1a0 <mem_init+0x30>)
 800a18a:	4804      	ldr	r0, [pc, #16]	; (800a19c <mem_init+0x2c>)
 800a18c:	f7f8 fb70 	bl	8002870 <chPoolLoadArray>
}
 800a190:	bd08      	pop	{r3, pc}
 800a192:	bf00      	nop
 800a194:	20002028 	.word	0x20002028
 800a198:	20003484 	.word	0x20003484
 800a19c:	20003478 	.word	0x20003478
 800a1a0:	20000028 	.word	0x20000028
	...

0800a1b0 <usb_driver_init>:


/* Initialise Serial USB Objects */
static void usb_driver_init(void) {
 800a1b0:	b508      	push	{r3, lr}

    /* Serial Driver Setup */
    sduObjectInit(&SDU1);
 800a1b2:	4813      	ldr	r0, [pc, #76]	; (800a200 <usb_driver_init+0x50>)
 800a1b4:	f7fa fc44 	bl	8004a40 <sduObjectInit>
    sduStart(&SDU1, &serusbcfg);
 800a1b8:	4912      	ldr	r1, [pc, #72]	; (800a204 <usb_driver_init+0x54>)
 800a1ba:	4811      	ldr	r0, [pc, #68]	; (800a200 <usb_driver_init+0x50>)
 800a1bc:	f7fa fc78 	bl	8004ab0 <sduStart>

    /* USB Setup */
    usbDisconnectBus(serusbcfg.usbp);
 800a1c0:	4b10      	ldr	r3, [pc, #64]	; (800a204 <usb_driver_init+0x54>)
 800a1c2:	681b      	ldr	r3, [r3, #0]
 800a1c4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800a1c6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800a1c8:	4b0e      	ldr	r3, [pc, #56]	; (800a204 <usb_driver_init+0x54>)
 800a1ca:	681b      	ldr	r3, [r3, #0]
 800a1cc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800a1ce:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 800a1d2:	639a      	str	r2, [r3, #56]	; 0x38
    chThdSleepMilliseconds(1500);
 800a1d4:	f643 2098 	movw	r0, #15000	; 0x3a98
 800a1d8:	f7f7 f95a 	bl	8001490 <chThdSleep>
    usbStart(serusbcfg.usbp, &usbcfg);
 800a1dc:	4b09      	ldr	r3, [pc, #36]	; (800a204 <usb_driver_init+0x54>)
 800a1de:	681b      	ldr	r3, [r3, #0]
 800a1e0:	4909      	ldr	r1, [pc, #36]	; (800a208 <usb_driver_init+0x58>)
 800a1e2:	4618      	mov	r0, r3
 800a1e4:	f7fb f904 	bl	80053f0 <usbStart>
    usbConnectBus(serusbcfg.usbp);    
 800a1e8:	4b06      	ldr	r3, [pc, #24]	; (800a204 <usb_driver_init+0x54>)
 800a1ea:	681b      	ldr	r3, [r3, #0]
 800a1ec:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800a1ee:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800a1f0:	4b04      	ldr	r3, [pc, #16]	; (800a204 <usb_driver_init+0x54>)
 800a1f2:	681b      	ldr	r3, [r3, #0]
 800a1f4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800a1f6:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800a1fa:	639a      	str	r2, [r3, #56]	; 0x38
}
 800a1fc:	bd08      	pop	{r3, pc}
 800a1fe:	bf00      	nop
 800a200:	20002fb4 	.word	0x20002fb4
 800a204:	0800af50 	.word	0x0800af50
 800a208:	0800af40 	.word	0x0800af40
 800a20c:	00000000 	.word	0x00000000

0800a210 <usb_serial_init>:


/* Start USB Serial Thread */
void usb_serial_init(void) {    
 800a210:	b500      	push	{lr}
 800a212:	b083      	sub	sp, #12
    
    chThdCreateStatic(waUSBThread, sizeof(waUSBThread), NORMALPRIO, USBThread, NULL);
 800a214:	2300      	movs	r3, #0
 800a216:	9300      	str	r3, [sp, #0]
 800a218:	4b04      	ldr	r3, [pc, #16]	; (800a22c <usb_serial_init+0x1c>)
 800a21a:	2240      	movs	r2, #64	; 0x40
 800a21c:	f44f 6117 	mov.w	r1, #2416	; 0x970
 800a220:	4803      	ldr	r0, [pc, #12]	; (800a230 <usb_serial_init+0x20>)
 800a222:	f7f7 f905 	bl	8001430 <chThdCreateStatic>
}
 800a226:	b003      	add	sp, #12
 800a228:	f85d fb04 	ldr.w	pc, [sp], #4
 800a22c:	0800a101 	.word	0x0800a101
 800a230:	200034b0 	.word	0x200034b0
	...

0800a240 <_upload_log>:


/* Pass a formatted packet to the USB vomit thread */
void _upload_log(packet_log *packet) {
 800a240:	b500      	push	{lr}
 800a242:	b085      	sub	sp, #20
 800a244:	9001      	str	r0, [sp, #4]

    void* msg;
    msg_t retval;

    /* Allocate space for the packet in the mempool */
    msg = chPoolAlloc(&usb_mempool);
 800a246:	480e      	ldr	r0, [pc, #56]	; (800a280 <_upload_log+0x40>)
 800a248:	f7f8 fb6a 	bl	8002920 <chPoolAlloc>
 800a24c:	9003      	str	r0, [sp, #12]
    if (msg == NULL) return;
 800a24e:	9b03      	ldr	r3, [sp, #12]
 800a250:	2b00      	cmp	r3, #0
 800a252:	d012      	beq.n	800a27a <_upload_log+0x3a>
    
    /* Copy the packet into the mempool */
    memcpy(msg, (void*)packet, sizeof(packet_log));
 800a254:	2280      	movs	r2, #128	; 0x80
 800a256:	9901      	ldr	r1, [sp, #4]
 800a258:	9803      	ldr	r0, [sp, #12]
 800a25a:	f7f6 f861 	bl	8000320 <memcpy>
    
    /* Post the location of the packet into the mailbox */
    retval = chMBPost(&usb_mailbox, (intptr_t)msg, TIME_IMMEDIATE);
 800a25e:	9b03      	ldr	r3, [sp, #12]
 800a260:	2200      	movs	r2, #0
 800a262:	4619      	mov	r1, r3
 800a264:	4807      	ldr	r0, [pc, #28]	; (800a284 <_upload_log+0x44>)
 800a266:	f7f7 fe6b 	bl	8001f40 <chMBPost>
 800a26a:	9002      	str	r0, [sp, #8]
    if (retval != MSG_OK) {
 800a26c:	9b02      	ldr	r3, [sp, #8]
 800a26e:	2b00      	cmp	r3, #0
 800a270:	d003      	beq.n	800a27a <_upload_log+0x3a>
        chPoolFree(&usb_mempool, msg);
 800a272:	9903      	ldr	r1, [sp, #12]
 800a274:	4802      	ldr	r0, [pc, #8]	; (800a280 <_upload_log+0x40>)
 800a276:	f7f8 fb83 	bl	8002980 <chPoolFree>
        return;
    }
}
 800a27a:	b005      	add	sp, #20
 800a27c:	f85d fb04 	ldr.w	pc, [sp], #4
 800a280:	20003478 	.word	0x20003478
 800a284:	20003484 	.word	0x20003484
	...

0800a290 <upload_position_packet>:

/* UPLOAD FUNCTIONS */

/* Log a NAV-PVT Message */
void upload_position_packet(position_packet *pos_data) {
 800a290:	b500      	push	{lr}
 800a292:	b0a3      	sub	sp, #140	; 0x8c
 800a294:	9001      	str	r0, [sp, #4]

    packet_log pkt;
    pkt.type = MESSAGE_POS;
 800a296:	2301      	movs	r3, #1
 800a298:	f88d 3008 	strb.w	r3, [sp, #8]
    pkt.timestamp = chVTGetSystemTime();
 800a29c:	f7ff ff10 	bl	800a0c0 <chVTGetSystemTime>
 800a2a0:	4603      	mov	r3, r0
 800a2a2:	f8cd 3009 	str.w	r3, [sp, #9]
    memset(pkt.payload, 0, 123);
 800a2a6:	ab02      	add	r3, sp, #8
 800a2a8:	3305      	adds	r3, #5
 800a2aa:	227b      	movs	r2, #123	; 0x7b
 800a2ac:	2100      	movs	r1, #0
 800a2ae:	4618      	mov	r0, r3
 800a2b0:	f000 f80e 	bl	800a2d0 <memset>
    memcpy(pkt.payload, pos_data, sizeof(position_packet));
 800a2b4:	ab02      	add	r3, sp, #8
 800a2b6:	3305      	adds	r3, #5
 800a2b8:	220e      	movs	r2, #14
 800a2ba:	9901      	ldr	r1, [sp, #4]
 800a2bc:	4618      	mov	r0, r3
 800a2be:	f7f6 f82f 	bl	8000320 <memcpy>
    _upload_log(&pkt);
 800a2c2:	ab02      	add	r3, sp, #8
 800a2c4:	4618      	mov	r0, r3
 800a2c6:	f7ff ffbb 	bl	800a240 <_upload_log>
}
 800a2ca:	b023      	add	sp, #140	; 0x8c
 800a2cc:	f85d fb04 	ldr.w	pc, [sp], #4

0800a2d0 <memset>:
 800a2d0:	b4f0      	push	{r4, r5, r6, r7}
 800a2d2:	0786      	lsls	r6, r0, #30
 800a2d4:	d043      	beq.n	800a35e <memset+0x8e>
 800a2d6:	1e54      	subs	r4, r2, #1
 800a2d8:	2a00      	cmp	r2, #0
 800a2da:	d03e      	beq.n	800a35a <memset+0x8a>
 800a2dc:	b2ca      	uxtb	r2, r1
 800a2de:	4603      	mov	r3, r0
 800a2e0:	e002      	b.n	800a2e8 <memset+0x18>
 800a2e2:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
 800a2e6:	d338      	bcc.n	800a35a <memset+0x8a>
 800a2e8:	f803 2b01 	strb.w	r2, [r3], #1
 800a2ec:	079d      	lsls	r5, r3, #30
 800a2ee:	d1f8      	bne.n	800a2e2 <memset+0x12>
 800a2f0:	2c03      	cmp	r4, #3
 800a2f2:	d92b      	bls.n	800a34c <memset+0x7c>
 800a2f4:	b2cd      	uxtb	r5, r1
 800a2f6:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800a2fa:	2c0f      	cmp	r4, #15
 800a2fc:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800a300:	d916      	bls.n	800a330 <memset+0x60>
 800a302:	f1a4 0710 	sub.w	r7, r4, #16
 800a306:	093f      	lsrs	r7, r7, #4
 800a308:	f103 0620 	add.w	r6, r3, #32
 800a30c:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 800a310:	f103 0210 	add.w	r2, r3, #16
 800a314:	e942 5504 	strd	r5, r5, [r2, #-16]
 800a318:	e942 5502 	strd	r5, r5, [r2, #-8]
 800a31c:	3210      	adds	r2, #16
 800a31e:	42b2      	cmp	r2, r6
 800a320:	d1f8      	bne.n	800a314 <memset+0x44>
 800a322:	f004 040f 	and.w	r4, r4, #15
 800a326:	3701      	adds	r7, #1
 800a328:	2c03      	cmp	r4, #3
 800a32a:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 800a32e:	d90d      	bls.n	800a34c <memset+0x7c>
 800a330:	461e      	mov	r6, r3
 800a332:	4622      	mov	r2, r4
 800a334:	3a04      	subs	r2, #4
 800a336:	2a03      	cmp	r2, #3
 800a338:	f846 5b04 	str.w	r5, [r6], #4
 800a33c:	d8fa      	bhi.n	800a334 <memset+0x64>
 800a33e:	1f22      	subs	r2, r4, #4
 800a340:	f022 0203 	bic.w	r2, r2, #3
 800a344:	3204      	adds	r2, #4
 800a346:	4413      	add	r3, r2
 800a348:	f004 0403 	and.w	r4, r4, #3
 800a34c:	b12c      	cbz	r4, 800a35a <memset+0x8a>
 800a34e:	b2c9      	uxtb	r1, r1
 800a350:	441c      	add	r4, r3
 800a352:	f803 1b01 	strb.w	r1, [r3], #1
 800a356:	429c      	cmp	r4, r3
 800a358:	d1fb      	bne.n	800a352 <memset+0x82>
 800a35a:	bcf0      	pop	{r4, r5, r6, r7}
 800a35c:	4770      	bx	lr
 800a35e:	4614      	mov	r4, r2
 800a360:	4603      	mov	r3, r0
 800a362:	e7c5      	b.n	800a2f0 <memset+0x20>
	...

0800a370 <ram_areas>:
 800a370:	d0b4 0800 3e20 2000 3e20 2000 3e20 2000     .... >.  >.  >. 
 800a380:	d0b4 0800 0000 2000 0000 2000 0000 2000     ....... ... ... 
 800a390:	d0b4 0800 c000 2001 c000 2001 c000 2001     ....... ... ... 
 800a3a0:	d0b4 0800 0000 0000 0000 0000 0000 0000     ................
 800a3b0:	d0b4 0800 0800 1000 0800 1000 0800 1000     ................
 800a3c0:	d0b4 0800 4000 4002 4000 4002 4000 4002     .....@.@.@.@.@.@
 800a3d0:	d0b4 0800 0000 0000 0000 0000 0000 0000     ................
 800a3e0:	d0b4 0800 0000 0000 0000 0000 0000 0000     ................
 800a3f0:	6469 656c 0000 0000 0000 0000 0000 0000     idle............
 800a400:	5653 3323 0000 0000 0000 0000 0000 0000     SV#3............
 800a410:	5653 3423 0000 0000 0000 0000 0000 0000     SV#4............
 800a420:	5653 3523 0000 0000 0000 0000 0000 0000     SV#5............
 800a430:	5653 3623 0000 0000 0000 0000 0000 0000     SV#6............
 800a440:	5653 3723 0000 0000 0000 0000 0000 0000     SV#7............
 800a450:	5653 3823 0000 0000 0000 0000 0000 0000     SV#8............
 800a460:	5653 3923 0000 0000 0000 0000 0000 0000     SV#9............
 800a470:	5653 3123 0030 0000 0000 0000 0000 0000     SV#10...........
 800a480:	5653 3123 0031 0000 0000 0000 0000 0000     SV#11...........

0800a490 <__func__.7813.lto_priv.292>:
 800a490:	6863 5456 6f44 6553 4974 0000 0000 0000     chVTDoSetI......

0800a4a0 <__func__.7820>:
 800a4a0:	6863 5456 6f44 6552 6573 4974 0000 0000     chVTDoResetI....
 800a4b0:	7473 6361 206b 766f 7265 6c66 776f 0000     stack overflow..

0800a4c0 <__func__.7810.lto_priv.333>:
 800a4c0:	6863 6353 5268 6165 7964 0049 0000 0000     chSchReadyI.....

0800a4d0 <__func__.7838.lto_priv.337>:
 800a4d0:	6863 6353 5768 6b61 7565 5370 0000 0000     chSchWakeupS....

0800a4e0 <__func__.7822>:
 800a4e0:	6863 6854 4364 6572 7461 4965 0000 0000     chThdCreateI....

0800a4f0 <__func__.7105.lto_priv.32>:
 800a4f0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800a500 <__func__.7276>:
 800a500:	6863 6854 5364 656c 7065 0053 0000 0000     chThdSleepS.....

0800a510 <__func__.7866>:
 800a510:	6863 6854 4564 6978 5374 0000 0000 0000     chThdExitS......

0800a520 <__func__.7876>:
 800a520:	6863 6854 5364 7375 6570 646e 0053 0000     chThdSuspendS...

0800a530 <__func__.7888>:
 800a530:	6863 6854 5264 7365 6d75 4965 0000 0000     chThdResumeI....

0800a540 <__func__.7288>:
 800a540:	6863 6854 4464 446f 7165 6575 6575 654e     chThdDoDequeueNe
 800a550:	7478 0049 0000 0000 0000 0000 0000 0000     xtI.............

0800a560 <ch_debug>:
 800a560:	616d 6e69 1600 1881 0404 0860 100c 1814     main......`.....
 800a570:	201c 2221 0000 0000 0000 0000 0000 0000     . !"............

0800a580 <__func__.7805.lto_priv.321>:
 800a580:	6863 744d 4f78 6a62 6365 4974 696e 0074     chMtxObjectInit.

0800a590 <__func__.7105.lto_priv.36>:
 800a590:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800a5a0 <__func__.7813.lto_priv.293>:
 800a5a0:	6863 744d 4c78 636f 536b 0000 0000 0000     chMtxLockS......

0800a5b0 <__func__.7836>:
 800a5b0:	6863 744d 5578 6c6e 636f 006b 0000 0000     chMtxUnlock.....

0800a5c0 <__func__.7830.lto_priv.319>:
 800a5c0:	6863 7645 4274 6f72 6461 6163 7473 6c46     chEvtBroadcastFl
 800a5d0:	6761 4973 0000 0000 0000 0000 0000 0000     agsI............

0800a5e0 <__func__.7847.lto_priv.301>:
 800a5e0:	6863 7645 5374 6769 616e 496c 0000 0000     chEvtSignalI....

0800a5f0 <__func__.7807.lto_priv.297>:
 800a5f0:	6863 424d 624f 656a 7463 6e49 7469 0000     chMBObjectInit..

0800a600 <__func__.7105.lto_priv.40>:
 800a600:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800a610 <__func__.7827.lto_priv.304>:
 800a610:	6863 424d 6f50 7473 0053 0000 0000 0000     chMBPostS.......

0800a620 <__func__.7867>:
 800a620:	6863 424d 6546 6374 5368 0000 0000 0000     chMBFetchS......

0800a630 <__func__.7105.lto_priv.41>:
 800a630:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800a640 <__func__.7833>:
 800a640:	6863 5149 6552 6461 6954 656d 756f 0074     chIQReadTimeout.

0800a650 <__func__.7869>:
 800a650:	6863 514f 7257 7469 5465 6d69 6f65 7475     chOQWriteTimeout
	...

0800a670 <__func__.7105.lto_priv.42>:
 800a670:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800a680 <__func__.7807.lto_priv.298>:
 800a680:	6863 6f50 6c6f 624f 656a 7463 6e49 7469     chPoolObjectInit
	...

0800a6a0 <__func__.7813.lto_priv.295>:
 800a6a0:	6863 6f50 6c6f 6f4c 6461 7241 6172 0079     chPoolLoadArray.

0800a6b0 <__func__.7821.lto_priv.291>:
 800a6b0:	6863 6f50 6c6f 6c41 6f6c 4963 0000 0000     chPoolAllocI....

0800a6c0 <__func__.7105.lto_priv.43>:
 800a6c0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800a6d0 <__func__.7831>:
 800a6d0:	6863 6f50 6c6f 7246 6565 0049 0000 0000     chPoolFreeI.....

0800a6e0 <__func__.9571>:
 800a6e0:	6269 4f71 6a62 6365 4974 696e 0074 0000     ibqObjectInit...

0800a6f0 <__func__.9582>:
 800a6f0:	6269 5071 736f 4674 6c75 426c 6675 6566     ibqPostFullBuffe
 800a700:	4972 0000 0000 0000 0000 0000 0000 0000     rI..............

0800a710 <__func__.7506.lto_priv.237>:
 800a710:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800a720 <__func__.9596>:
 800a720:	6269 4771 7465 7546 6c6c 7542 6666 7265     ibqGetFullBuffer
 800a730:	6954 656d 756f 5374 0000 0000 0000 0000     TimeoutS........

0800a740 <__func__.9603>:
 800a740:	6269 5271 6c65 6165 6573 6d45 7470 4279     ibqReleaseEmptyB
 800a750:	6675 6566 5372 0000 0000 0000 0000 0000     ufferS..........

0800a760 <__func__.9629>:
 800a760:	626f 4f71 6a62 6365 4974 696e 0074 0000     obqObjectInit...

0800a770 <__func__.9640>:
 800a770:	626f 5271 6c65 6165 6573 6d45 7470 4279     obqReleaseEmptyB
 800a780:	6675 6566 4972 0000 0000 0000 0000 0000     ufferI..........

0800a790 <__func__.9654>:
 800a790:	626f 4771 7465 6d45 7470 4279 6675 6566     obqGetEmptyBuffe
 800a7a0:	5472 6d69 6f65 7475 0053 0000 0000 0000     rTimeoutS.......

0800a7b0 <__func__.9663>:
 800a7b0:	626f 5071 736f 4674 6c75 426c 6675 6566     obqPostFullBuffe
 800a7c0:	5372 0000 0000 0000 0000 0000 0000 0000     rS..............

0800a7d0 <__func__.9171>:
 800a7d0:	6d5f 636d 6473 675f 7465 735f 696c 6563     _mmcsd_get_slice
	...

0800a7f0 <__func__.9178>:
 800a7f0:	6d5f 636d 6473 675f 7465 635f 7061 6361     _mmcsd_get_capac
 800a800:	7469 0079 0000 0000 0000 0000 0000 0000     ity.............

0800a810 <__func__.9186>:
 800a810:	6d5f 636d 6473 675f 7465 635f 7061 6361     _mmcsd_get_capac
 800a820:	7469 5f79 7865 0074 0000 0000 0000 0000     ity_ext.........

0800a830 <sdc_vmt>:
 800a830:	9241 0800 9251 0800 3e41 0800 4021 0800     A...Q...A>..!@..
 800a840:	40a1 0800 4121 0800 41a1 0800 41f1 0800     .@..!A...A...A..

0800a850 <__func__.9621>:
 800a850:	6d6d 5f63 6d63 3664 635f 6e6f 7473 7572     mmc_cmd6_constru
 800a860:	7463 0000 0000 0000 0000 0000 0000 0000     ct..............

0800a870 <__func__.9628>:
 800a870:	6473 5f63 6d63 3664 635f 6e6f 7473 7572     sdc_cmd6_constru
 800a880:	7463 0000 0000 0000 0000 0000 0000 0000     ct..............

0800a890 <__func__.9672>:
 800a890:	6d6d 5f63 6573 5f74 7562 5f73 6977 7464     mmc_set_bus_widt
 800a8a0:	0068 0000 0000 0000 0000 0000 0000 0000     h...............

0800a8b0 <__func__.7506.lto_priv.238>:
 800a8b0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800a8c0 <__func__.9704>:
 800a8c0:	6473 4363 6e6f 656e 7463 0000 0000 0000     sdcConnect......

0800a8d0 <__func__.9715>:
 800a8d0:	6473 4463 7369 6f63 6e6e 6365 0074 0000     sdcDisconnect...

0800a8e0 <__func__.9723>:
 800a8e0:	6473 5263 6165 0064 0000 0000 0000 0000     sdcRead.........

0800a8f0 <__func__.9731>:
 800a8f0:	6473 5763 6972 6574 0000 0000 0000 0000     sdcWrite........

0800a900 <__func__.9741>:
 800a900:	6473 5363 6e79 0063 0000 0000 0000 0000     sdcSync.........

0800a910 <__func__.9746>:
 800a910:	6473 4763 7465 6e49 6f66 0000 0000 0000     sdcGetInfo......

0800a920 <vmt.lto_priv.194>:
 800a920:	4341 0800 4371 0800 43a1 0800 43d1 0800     AC..qC...C...C..
 800a930:	43f1 0800 4421 0800 4441 0800 4471 0800     .C..!D..AD..qD..

0800a940 <__func__.9213>:
 800a940:	6473 7453 7261 0074 0000 0000 0000 0000     sdStart.........

0800a950 <__func__.7105.lto_priv.45>:
 800a950:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800a960 <__func__.9222>:
 800a960:	6473 6e49 6f63 696d 676e 6144 6174 0049     sdIncomingDataI.

0800a970 <vmt.lto_priv.195>:
 800a970:	4791 0800 47d1 0800 4811 0800 4851 0800     .G...G...H..QH..
 800a980:	4891 0800 48d1 0800 4911 0800 4951 0800     .H...H...I..QI..

0800a990 <__func__.9227.lto_priv.254>:
 800a990:	6473 5375 6174 7472 0000 0000 0000 0000     sduStart........

0800a9a0 <__func__.7105.lto_priv.46>:
 800a9a0:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800a9b0 <__func__.9251>:
 800a9b0:	6473 5375 464f 6f48 6b6f 0049 0000 0000     sduSOFHookI.....

0800a9c0 <zero_status>:
	...

0800a9d0 <active_status>:
	...

0800a9e0 <halted_status>:
 800a9e0:	0001 0000 0000 0000 0000 0000 0000 0000     ................

0800a9f0 <__func__.9619.lto_priv.208>:
 800a9f0:	7375 5362 6174 7472 0000 0000 0000 0000     usbStart........

0800aa00 <__func__.7506.lto_priv.239>:
 800aa00:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800aa10 <__func__.9636>:
 800aa10:	7375 4962 696e 4574 646e 6f70 6e69 4974     usbInitEndpointI
	...

0800aa30 <__func__.9641>:
 800aa30:	7375 4462 7369 6261 656c 6e45 7064 696f     usbDisableEndpoi
 800aa40:	746e 4973 0000 0000 0000 0000 0000 0000     ntsI............

0800aa50 <__func__.9652>:
 800aa50:	7375 5362 6174 7472 6552 6563 7669 4965     usbStartReceiveI
	...

0800aa70 <__func__.9660>:
 800aa70:	7375 5362 6174 7472 7254 6e61 6d73 7469     usbStartTransmit
 800aa80:	0049 0000 0000 0000 0000 0000 0000 0000     I...............

0800aa90 <__func__.9718>:
 800aa90:	755f 6273 655f 3070 6e69 0000 0000 0000     _usb_ep0in......

0800aaa0 <__func__.9732>:
 800aaa0:	755f 6273 655f 3070 756f 0074 0000 0000     _usb_ep0out.....

0800aab0 <__func__.9173>:
 800aab0:	766e 6369 6553 5374 7379 6574 486d 6e61     nvicSetSystemHan
 800aac0:	6c64 7265 7250 6f69 6972 7974 0000 0000     dlerPriority....

0800aad0 <_stm32_dma_streams>:
 800aad0:	6010 4002 6008 4002 0000 000b 6028 4002     .`.@.`.@....(`.@
 800aae0:	6008 4002 0106 000c 6040 4002 6008 4002     .`.@....@`.@.`.@
 800aaf0:	0210 000d 6058 4002 6008 4002 0316 000e     ....X`.@.`.@....
 800ab00:	6070 4002 600c 4002 0400 000f 6088 4002     p`.@.`.@.....`.@
 800ab10:	600c 4002 0506 0010 60a0 4002 600c 4002     .`.@.....`.@.`.@
 800ab20:	0610 0011 60b8 4002 600c 4002 0716 002f     .....`.@.`.@../.
 800ab30:	6410 4002 6408 4002 0800 0038 6428 4002     .d.@.d.@..8.(d.@
 800ab40:	6408 4002 0906 0039 6440 4002 6408 4002     .d.@..9.@d.@.d.@
 800ab50:	0a10 003a 6458 4002 6408 4002 0b16 003b     ..:.Xd.@.d.@..;.
 800ab60:	6470 4002 640c 4002 0c00 003c 6488 4002     pd.@.d.@..<..d.@
 800ab70:	640c 4002 0d06 0044 64a0 4002 640c 4002     .d.@..D..d.@.d.@
 800ab80:	0e10 0045 64b8 4002 640c 4002 0f16 0046     ..E..d.@.d.@..F.

0800ab90 <ep0config>:
 800ab90:	0000 0000 5911 0800 5a71 0800 5bc1 0800     .....Y..qZ...[..
 800aba0:	0040 0040 26e0 2000 26e0 2000 0001 0000     @.@..&. .&. ....
 800abb0:	26f4 2000 0000 0000 0000 0000 0000 0000     .&. ............

0800abc0 <hsparams>:
 800abc0:	0100 0000 0400 0000 0005 0000 0000 0000     ................
 800abd0:	7375 5f62 6c6c 5f64 7570 706d 0000 0000     usb_lld_pump....

0800abe0 <__func__.9612>:
 800abe0:	746f 5f67 6172 5f6d 6c61 6f6c 0063 0000     otg_ram_alloc...

0800abf0 <__func__.9618>:
 800abf0:	746f 5f67 6966 6f66 775f 6972 6574 665f     otg_fifo_write_f
 800ac00:	6f72 5f6d 7562 6666 7265 0000 0000 0000     rom_buffer......

0800ac10 <__func__.7673>:
 800ac10:	6863 6854 5364 6174 7472 0049 0000 0000     chThdStartI.....

0800ac20 <__func__.7506.lto_priv.240>:
 800ac20:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800ac30 <__func__.9574>:
 800ac30:	6473 5f63 6c6c 5f64 7270 7065 7261 5f65     sdc_lld_prepare_
 800ac40:	6572 6461 625f 7479 7365 0000 0000 0000     read_bytes......

0800ac50 <__func__.7506.lto_priv.241>:
 800ac50:	6863 7953 5573 6c6e 636f 006b 0000 0000     chSysUnlock.....

0800ac60 <__func__.9696>:
 800ac60:	6473 5f63 6c6c 5f64 6572 6461 615f 696c     sdc_lld_read_ali
 800ac70:	6e67 6465 0000 0000 0000 0000 0000 0000     gned............

0800ac80 <__func__.9705>:
 800ac80:	6473 5f63 6c6c 5f64 7277 7469 5f65 6c61     sdc_lld_write_al
 800ac90:	6769 656e 0064 0000 0000 0000 0000 0000     igned...........

0800aca0 <default_config>:
 800aca0:	2580 0000 0000 4000 0000 0000 0000 0000     .%.....@........

0800acb0 <pal_default_config>:
 800acb0:	0002 2800 0000 0000 ffff ffff 5555 6555     ...(........UUUe
 800acc0:	ffff 0000 0001 0000 0000 0000 a400 a00a     ................
 800acd0:	0300 0000 ffff ffff 5555 5955 ffff 0000     ........UUUY....
 800ace0:	0000 7700 0044 cc00 1000 0000 0000 0000     ...wD...........
 800acf0:	ffff ffff 5555 5555 ffbf 0000 0000 0000     ....UUUU........
	...
 800ad0c:	ffff ffff 5555 5555 ffff 0000 0000 0000     ....UUUU........
	...
 800ad28:	ffff ffff 5555 5555 ffff 0000 0000 0000     ....UUUU........
	...
 800ad44:	ffff ffff 5555 5555 ffff 0000 0000 0000     ....UUUU........
	...
 800ad60:	ffff ffff 5555 5555 ffff 0000 0000 0000     ....UUUU........
	...
 800ad7c:	ffff ffff 5555 5555 ffff 0000 0000 0000     ....UUUU........
	...
 800ad98:	ffff ffff 5555 5555 ffff 0000 0000 0000     ....UUUU........
	...
 800adb0:	5047 0053 0000 0000 0000 0000 0000 0000     GPS.............

0800adc0 <vcom_device_descriptor_data>:
 800adc0:	0112 0110 0002 4000 0483 5740 0200 0201     .......@..@W....
 800add0:	0103 0000 0000 0000 0000 0000 0000 0000     ................

0800ade0 <vcom_device_descriptor>:
 800ade0:	0012 0000 adc0 0800 0000 0000 0000 0000     ................

0800adf0 <vcom_configuration_descriptor_data>:
 800adf0:	0209 0043 0102 c000 0932 0004 0100 0202     ..C.....2.......
 800ae00:	0001 2405 1000 0501 0124 0100 2404 0202     ...$....$....$..
 800ae10:	2405 0006 0701 8205 0803 ff00 0409 0001     .$..............
 800ae20:	0a02 0000 0700 0105 4002 0000 0507 0281     .........@......
 800ae30:	0040 0000 0000 0000 0000 0000 0000 0000     @...............

0800ae40 <vcom_configuration_descriptor>:
 800ae40:	0043 0000 adf0 0800 0000 0000 0000 0000     C...............

0800ae50 <vcom_string0>:
 800ae50:	0304 0409 0000 0000 0000 0000 0000 0000     ................

0800ae60 <vcom_string1>:
 800ae60:	0326 0043 0055 0020 0053 0070 0061 0063     &.C.U. .S.p.a.c.
 800ae70:	0065 0066 006c 0069 0067 0068 0074 0000     e.f.l.i.g.h.t...

0800ae80 <vcom_string2>:
 800ae80:	0338 0054 004f 0041 0044 0020 0056 0069     8.T.O.A.D. .V.i.
 800ae90:	0072 0074 0075 0061 006c 0020 0043 004f     r.t.u.a.l. .C.O.
 800aea0:	004d 0020 0050 006f 0072 0074 0000 0000     M. .P.o.r.t.....

0800aeb0 <vcom_string3>:
 800aeb0:	0308 0031 0000 0000 0000 0000 0000 0000     ..1.............

0800aec0 <vcom_strings>:
 800aec0:	0004 0000 ae50 0800 001e 0000 ae60 0800     ....P.......`...
 800aed0:	002c 0000 ae80 0800 0004 0000 aeb0 0800     ,...............

0800aee0 <ep1config>:
 800aee0:	0002 0000 0000 0000 4cc1 0800 4da1 0800     .........L...M..
 800aef0:	0040 0040 343c 2000 3450 2000 0002 0000     @.@.<4. P4. ....
	...

0800af10 <ep2config>:
 800af10:	0003 0000 0000 0000 4e21 0800 0000 0000     ........!N......
 800af20:	0010 0000 3464 2000 0000 0000 0001 0000     ....d4. ........
	...

0800af40 <usbcfg>:
 800af40:	9fa1 0800 9f41 0800 4bb1 0800 a021 0800     ....A....K..!...

0800af50 <serusbcfg>:
 800af50:	2468 2000 0101 0002 0000 0000 0000 0000     h$. ............
 800af60:	5355 0042 0000 0000 0000 0000 0000 0000     USB.............

0800af70 <packet_size.9659>:
 800af70:	0080 0000 0000 0000 0000 0000 0000 0000     ................

0800af80 <__func__.7105.lto_priv.48>:
 800af80:	6863 7953 5573 6c6e 636f 006b               chSysUnlock.
